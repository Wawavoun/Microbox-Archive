                      ;* NAM Mon09
                      ;* STTL Ver 5.0C    Ph. Roehr   28/05/2025
                      ;******************************************
                      ;******************************************
                      ;** MON09  Ver 5.0C                      **
                      ;** Original design Micro Concepts 1985  **
                      ;**                                      **
                      ;** Compact Flash adaptation 2025        **
                      ;** by Ph. Roehr                         **
                      ;**                                      **
                      ;******************************************
                      ;******************************************
                      ;*
                      ;******************************************
                      ;* This program is the core section of a  *
                      ;* general 6809(E) system monitor. It can *
                      ;* be configured to a particular system   *
                      ;* at assembly time by including on the   *
                      ;* source disk libary files containing    *
                      ;* the system specific code for the disk  *
                      ;* and console drivers and extra commands *
                      ;* and subroutines. These files are:-     *
                      ;*  SCRATCH.....Contains RMB's for extra  *
                      ;*              temp storage.             *
                      ;*  FDB.........Contains the jump table   *
                      ;*              entries for extra subs.   *
                      ;*  COMTABLE....Contains the extra jump   *
                      ;*              table entries for commands*
                      ;*  MINIT.......Contains the power on     *
                      ;*              and reset code.           *
                      ;*  CONSOLE.....Contains the console      *
                      ;*              driver code.              *
                      ;*  DISK........Contains the disk driver  *
                      ;*              code.                     *
                      ;*  SUBS........Contains the code for any *
                      ;*              extra system subroutines. *
                      ;*  BOOT........Contains the boot routine.*
                      ;*  COMMANDS....Contains the code for any *
                      ;*              extra commands.           *
                      ;******************************************
                      ;*
                      ;*
                      ;*
                      ;**************************
                      ;* Common System Equates  *
                      ;**************************
                      ;*
                      ;* LIB STARTADD
                      ;*
                      ;* FLEX variables ?
                      ;*
CC00                  TTYBS   EQU   $CC00
D3E5                  CINCHN  EQU   $D3E5        ; FLEX ?
                      ;*
                      ;* Other addresses
                      ;*
E000                  PROM    EQU   $E000        ; Start of PROM
CD00                  COLDS   EQU   $CD00        ; FLEX Cold Start
CA00                  TXTRAM  EQU   $CA00        ; TEXT RAM
CA02                  MCA02   EQU   $CA02        ; ?
                      ;*
DE00                  RAM     EQU   $DE00        ; Scratch ram + stack space.
FF00                  IO      EQU   $FF00        ; base address.
DE6F                  SSTACK  EQU   (RAM+127-16) ; Top of system stack.
DF80                  SCRAT   EQU   (RAM+384)    ; Start of scratch space.
                      ;*
                      ;* I/O
                      ;*
FF00                  PIA1    EQU   IO           ; $FF00
FF02                  SYSREG  EQU   PIA1+2       ; $FF02
FF04                  ACIA2   EQU   IO+4         ; $FF04
FF08                  ACIA1   EQU   IO+8         ; $FF08
FF0C                  BAUD    EQU   IO+12        ; $FF0C
FF10                  COMREG  EQU   IO+16        ; $FF10 : FDC Control register
FF13                  DATREG  EQU   COMREG+3     ; $FF13 : FDC Data register
FF14                  GDC     EQU   IO+20        ; $FF14
FF18                  RTC     EQU   IO+24        ; $FF18
FF1C                  PIA2    EQU   IO+28        ; $FF1C
                      ;*
                      ;* SAM Registers
                      ;*
FFD6                  CLR_R0  EQU   $FFD6
FFD7                  SET_R0  EQU   $FFD7
FFD8                  CLR_R1  EQU   $FFD8
FFD9                  SET_R1  EQU   $FFD9
                      
                      ;*********************************
                      ;* Compact Flash System Equates  *
                      ;*********************************
                      
                      ;* ABSOLUTE PIA PORT ADDRESSES
                      
FF1C                  PORTA               EQU     PIA2
FF1D                  PORTB               EQU     PIA2+1
FF1E                  PORTC               EQU     PIA2+2
FF1F                  PORTCTRL            EQU     PIA2+3
00FF                  PIA2PAG             EQU     PIA2>>8
                      
                      ;* PIA CONTROL BYTES FOR READ AND WRITE TO IDE DRIVE
                      
0092                  RD_IDE_8255         EQU     $92     ; %10010010 PORT C CTRL OUT, PORT A/B DATA INPUT
0080                  WR_IDE_8255         EQU     $80     ; %10000000 ALL 3 PORTS OUTPUT
                      
                      ;* PIA CTRL PORT BIT FUNCTIONS
                      
0001                  IDE_A0              EQU     $01
0002                  IDE_A1              EQU     $02
0004                  IDE_A2              EQU     $04
0008                  IDE_CS0             EQU     $08     ; INVERTED ON BOARD - SO SET FOR SELECT
0010                  IDE_CS1             EQU     $10     ; INVERTED - SO SET FOR SELECT
0020                  IDE_WR              EQU     $20     ; INVERTED - SO SET FOR WRITE
0040                  IDE_RD              EQU     $40     ; INVERTED - SO SET FOR READ
0080                  IDE_RST             EQU     $80     ; INVERTED - SO SET FOR RESET
                      
                      ; COMPACT FLASH REGISTER CONSTANTS FOR A BETTER READING OF THE CODE
                      
0008                  IDE_DATA            EQU     IDE_CS0                      ; DATA R/W
0009                  IDE_ERR             EQU     IDE_CS0+IDE_A0               ; READ ERROR CODE
0009                  IDE_SET_FEAT        EQU     IDE_CS0+IDE_A0               ; WRITE FEATURE
000A                  IDE_SEC_CNT         EQU     IDE_CS0+IDE_A1               ; NUMBER OF SECTORS TO TRANSFER
000B                  IDE_LBA0            EQU     IDE_CS0+IDE_A1+IDE_A0        ; SECTOR ADDRESS LBA 0 [BITS 0:7]
000C                  IDE_LBA1            EQU     IDE_CS0+IDE_A2               ; SECTOR ADDRESS LBA 1 [BITS 8:15]
000D                  IDE_LBA2            EQU     IDE_CS0+IDE_A2+IDE_A0        ; SECTOR ADDRESS LBA 2 [BITS 16:23]
000E                  IDE_LBA3            EQU     IDE_CS0+IDE_A2+IDE_A1        ; SECTOR ADDRESS LBA 3 [BITS 24:27 (LSB)]
000F                  IDE_COMMAND         EQU     IDE_CS0+IDE_A2+IDE_A1+IDE_A0 ; WRITE COMMAND
000F                  IDE_STATUS          EQU     IDE_CS0+IDE_A2+IDE_A1+IDE_A0 ; READ CF STATUS
                      
                      ;* IDE COMMAND CONSTANTS. THESE SHOULD NEVER CHANGE.
                      
0020                  IDE_CMD_READ        EQU     $20                 ; READ A LBA
0030                  IDE_CMD_WRITE       EQU     $30                 ; WRITE A LBA
00EF                  IDE_CMD_SET_FEAT    EQU     $EF                 ; SET FEATURES
                      
                      ;* FEATURE REQUESTS
                      
0081                  IDE_FEA_16BIT       EQU     $81
00E0                  LBA3MST             EQU     $E0                 ; LBA3 FOR IDE MASTER
00F0                  LBA3SLV             EQU     $F0                 ; LBA3 FOR IDE SLAVE
                      
                      ; CF CONTROL BITS
                      
0008                  DRQBIT              EQU     %00001000           ; DATA REQUEST BIT = CF STATUS BIT 3
0040                  RDYBIT              EQU     %01000000           ; READY BIT = BIT 6
0080                  BSYBIT              EQU     %10000000           ; BUSY BIT = BIT 7
0001                  ERRBIT              EQU     %00000001           ; ERROR BIT = BIT 0
                      
                      ;**************************
                      ;* scratch storage space  *
                      ;**************************
                      
                      ;* PARAMS TABLE FOR CF
                      
DE78                          ORG   (RAM+128-8)
                      
DE78                  SETFEA  RMB   1          ; SET FEATURE 16 BITS MODE
DE79                  SCTCNT  RMB   1          ; SECTOR COUNT FOR R/W (ALWAYS 1)
DE7A                  LBA0    RMB   1          ; LBA7 TO LBA0
DE7B                  LBA1    RMB   1          ; LBA15 TO LBA8
DE7C                  LBA2    RMB   1          ; LBA23 TO LBA 16
DE7D                  LBA3    RMB   1          ; B7=1 / B6=1 FOR LBA / B5=1 / B4=0 MASTER B4=1 SLAVE / B3->B0 LBA27 TO LBA24
DE7E                  MSTCFOK RMB   1          ; CF PRESENT FLAGS BY DEFAULT NOT
DE7F                  SLVCFOK RMB   1          ; BOTH SET BY INITCF ROUTINE
                      
DE80                          ORG   (RAM+128)
                      
DE80                  BUFFER  RMB   256          ; Floppy interface sector buffer.
                      
DF80                          ORG   SCRAT
                      
DF80                  STACK   RMB   2            ; User system stack.
DF82                  NMIV    RMB   2            ; NMI interrupt vector.
DF84                  IRQV    RMB   2            ; IRQ interrupt vector.
DF86                  FIRQV   RMB   2            ; FIRQ interrupt vector.
DF88                  SWI2V   RMB   2            ; SWI2 interrupt vector.
DF8A                  SWI3V   RMB   2            ; SWI3 interrupt vector.
DF8C                  IPORT   RMB   1            ; Active input port.
DF8D                  OPORT   RMB   1            ; Active output port.
DF8E                  DRIVE   RMB   1            ; Format drive value.
DF8F                  TRACK   RMB   1            ; Format track value.
DF90                  SECTOR  RMB   1            ; Format sector value.
DF91                  TEMP    RMB   1
DF92                  XTEMP   RMB   2
DF94                  YTEMP   RMB   2
DF96                  TTO     RMB   2
DF98                  RNDM    RMB   4            ; Random number storage.
DF9C                  WARMS   RMB   1            ; Warm start flag.
DF9D                  DDSTAB  RMB   4            ; Disc driver type table.
DFA1                  REAVEC  RMB   2            ; Disc driver jump tables.
DFA3                  WRIVEC  RMB   2
DFA5                  VERVEC  RMB   2
DFA7                  RSTVEC  RMB   2
DFA9                  DRVVEC  RMB   2
DFAB                  CHKVEC  RMB   2
DFAD                  QUIVEC  RMB   2
DFAF                  INIVEC  RMB   2
DFB1                  WARVEC  RMB   2
DFB3                  SEEVEC  RMB   2
                      
                      ;*********************************************
                      ;* Extra scratch space for system dependant  *
                      ;* routines fits here.                       *
                      ;*********************************************
                      ;* LIB SCRATCH
                      ;*
DFB5                  RTCFAIL EQU   $DFB5        ; ?
DFB6                  CURDRV  EQU   $DFB6        ; ?
DFB7                  XCOORD  EQU   $DFB7        ; ?
DFB9                  YCOORD  EQU   $DFB9        ; ?
DFBB                  PART1   EQU   $DFBB        ; ?
DFBF                  PART2   EQU   $DFBF        ; ?
DFC3                  GPARAM  EQU   $DFC3        ; ?
DFC4                  MDFC4   EQU   $DFC4        ; ?
DFCB                  GMODE   EQU   $DFCB        ; ?
DFCC                  GZOOM   EQU   $DFCC        ; ?
DFCD                  GFIGS   EQU   $DFCD        ; ?
DFCE                  DN      EQU   $DFCE        ; ?
DFD0                  D0      EQU   $DFD0        ; ?
DFD1                  D1      EQU   $DFD1        ; ?
DFD2                  D2      EQU   $DFD2        ; ?
DFD4                  D4      EQU   $DFD4        ; ?
DFD6                  DM      EQU   $DFD6        ; ?
DFD8                  CONST   EQU   $DFD8        ; ?
DFD9                  ROW     EQU   $DFD9        ; ?
DFDA                  COL     EQU   $DFDA        ; ?
DFE1                  ATTRI   EQU   $DFE1        ; ?
DFE5                  CURSOR  EQU   $DFE5        ; ?
DFEA                  CTYPE   EQU   $DFEA        ; ?
DFEB                  ESCFLG  EQU   $DFEB        ; ?
DFEC                  TS1     EQU   $DFEC        ; ?
DFEE                  TS2     EQU   $DFEE        ; ?
DFF0                  TL1     EQU   $DFF0        ; ?
DFF2                  TL2     EQU   $DFF2        ; ?
DFF4                  DEN     EQU   $DFF4        ; Density
DFF5                  DEN1    EQU   $DFF5
DFF6                  STEP    EQU   $DFF6        ; Floppy stepping speed
DFF7                  SPEED   EQU   $DFF7        ; SAM speed setting
DFF8                  TSTEP   EQU   $DFF8        ; ?
DFF9                  PSPEED  EQU   $DFF9        ; ?
DFFA                  MDFFA   EQU   $DFFA        ; ?
DFFB                  DROMSZ  EQU   $DFFB        ; !!! NOT RELEVANT IN THIS VERSION !!!
DFFC                  REGDP   EQU   $DFFC        ; Current DP Register
DFFD                  FLASH   EQU   $DFFD        ; ?
DFFF                  BLANKD  EQU   $DFFF        ; ?
                      ;*
                      ;*********************************
                      ;* Monitor part of PROM, disabled when FLEX is running
                      ;*********************************
                      
E000                          ORG     PROM
                      
                      ;* LIB MINIT
E000 0A0D             HDR     FCB     $0A,$0D
E002 2B2B2B204D6F6E30         FCC     "+++ Mon09 Ver 5.0C Ph. Roehr 2025 +++"
     392056657220352E
     30432050682E2052
     6F65687220323032
     35202B2B2B
E027 04                       FCB     $04
E028 0A0D             PROMPT  FCB     $0A,$0D
E02A 3D3E                     FCC     "=>"
E02C 04                       FCB     $04
E02D 07               NOTTHS  FCB     $07
E02E 20556E6B6E6F776E         FCC     " Unknown command! "
     20636F6D6D616E64
     2120
E040 04                       FCB     $04
E041 070707070707     UNMESS  FCB     $07,$07,$07,$07,$07,$07
E047 07070707                 FCB     $07,$07,$07,$07
E04B 554E455850454354         FCC     "UNEXPECTED INTERUPT!!!!!!!!!!"
     454420494E544552
     5550542121212121
     2121212121
E068 04                       FCB     $04
E069 070707           PFAIL   FCB     $07,$07,$07
E06C 506F776572206661         FCC     "Power failure in RTC, reloading defaults"
     696C75726520696E
     205254432C207265
     6C6F6164696E6720
     64656661756C7473
E094 04                       FCB     $04
E095 4D61737465722043 CFMST   FCC     "Master CF detected"
     4620646574656374
     6564
E0A7 04                       FCB     $04
E0A8 536C617665204346 CFSLV   FCC     "Slave CF detected"
     2064657465637465
     64
E0B9 04                       FCB     $04
                      ;*
                      ;* default values for RTC RAM
                      ;*
E0BA 50FF010002       TCONST  FCB     $50,$FF,$01,$00,$02
E0BF 0308003A00               FCB     $03,$08,$00,$3A,$00
E0C4 5000000800               FCB     $50,$00,$00,$08,$00
E0C9 001B00011F               FCB     $00,$1B,$00,$01,$1F
E0CE 2E65080604               FCB     $2E,$65,$08,$06,$04
E0D3 2041000000               FCB     $20,$41,$00,$00,$00
E0D8 0000000000               FCB     $00,$00,$00,$00,$00
E0DD 0000000000               FCB     $00,$00,$00,$00,$00
E0E2 0000000000               FCB     $00,$00,$00,$00,$00
E0E7 0000000000               FCB     $00,$00,$00,$00,$00
                      ;*
                      ;* System dependant init : part 2 of RESET routine
                      ;*
E0EC BFDF98           MINIT1  STX     RNDM
E0EF C60D                     LDB     #$0D
E0F1 BDF5EA                   JSR     GETRTC     ; read D-reg
E0F4 8480                     ANDA    #$80       ; mask off bit 0-6
E0F6 B7DFB5                   STA     RTCFAIL    ; =0 if no power
E0F9 B6FF02                   LDA     SYSREG
E0FC 43                       COMA
E0FD 44                       LSRA
E0FE 44                       LSRA
E0FF 44                       LSRA
E100 44                       LSRA
E101 1F89                     TFR     A,B
E103 C401                     ANDB    #$01
E105 F7DF8C                   STB     IPORT
E108 1F89                     TFR     A,B
E10A 54                       LSRB
E10B C401                     ANDB    #$01
E10D F7DF8D                   STB     OPORT
E110 7DDFB5                   TST     RTCFAIL
E113 260F                     BNE     INIT2      ; RTC data valid ?
E115 8EE0BA                   LDX     #TCONST    ; no, so get default values
E118 C60E                     LDB     #$0E
E11A A680             IRTC    LDA     ,X+
E11C BDF608                   JSR     PUTRTC
E11F 5C                       INCB
E120 C140                     CMPB    #$40
E122 26F6                     BNE     IRTC
E124 C60E             INIT2   LDB     #$0E       ; get RTC saved data
E126 BDF5EA                   JSR     GETRTC
E129 1F89                     TFR     A,B
E12B 8480                     ANDA    #$80
E12D B7DFF9                   STA     PSPEED     ; init cpu speed (?)
E130 1F98                     TFR     B,A
E132 8440                     ANDA    #$40
E134 B7DFFA                   STA     MDFFA      ; init ?
E137 1F98                     TFR     B,A
E139 8430                     ANDA    #$30
E13B 48                       ASLA
E13C 48                       ASLA
E13D 84C0                     ANDA    #$C0
E13F B7DFFB                   STA     DROMSZ     ; !!! NOT RELEVANT IN THIS VERSION !!!
E142 1F98                     TFR     B,A
E144 840C                     ANDA    #$0C
E146 44                       LSRA
E147 44                       LSRA
E148 B7DFF7                   STA     SPEED      ; init cpu speed
E14B 1F98                     TFR     B,A
E14D 8403                     ANDA    #$03
E14F B7DFF8                   STA     TSTEP      ; init disc step speed
E152 4F                       CLRA
E153 BBDFF7                   ADDA    SPEED
E156 B7FF10                   STA     COMREG
E159 7DDFF9                   TST     PSPEED
E15C 2703                     BEQ     INIT3
E15E B7FFD9                   STA     SET_R1     ; init SAM values for FAST/SLOW
E161 86CE             INIT3   LDA     #$CE
E163 B7FF09                   STA     ACIA1+1    ; init acia 1 and 2
E166 B7FF05                   STA     ACIA2+1    ; 2 stop bits,no parity,8 bits,baud rate factor=X16
E169 8627                     LDA     #$27
E16B B7FF09                   STA     ACIA1+1    ; enable reciever & transmitter
E16E B7FF05                   STA     ACIA2+1
E171 C60F                     LDB     #$0F
E173 BDF5EA                   JSR     GETRTC
E176 B7FF0C                   STA     BAUD       ; 9600 baud
E179 44                       LSRA
E17A 44                       LSRA
E17B 44                       LSRA
E17C 44                       LSRA
E17D B7FF0D                   STA     BAUD+1
E180 BDF8D3                   JSR     GDCINI     ; init graphic controler
E183 869B                     LDA     #$9B
E185 B7FF1F                   STA     PIA2+3
E188 C610                     LDB     #$10
E18A 8EDF9D                   LDX     #DDSTAB    ; load disc drive table
E18D BDF5EA           INIT4   JSR     GETRTC
E190 A780                     STA     ,X+
E192 5C                       INCB
E193 C114                     CMPB    #$14
E195 26F6                     BNE     INIT4
E197 7DDFB5                   TST     RTCFAIL    ; message if RTC data not valid
E19A 2606                     BNE     RTCOK
E19C 8EE069                   LDX     #PFAIL
E19F BDF525                   JSR     PSTRNG
                      
                      ;* IDE/CF detection and init
E1A2 8619             RTCOK   LDA     #25
E1A4 BDEFD3                   JSR     WAIT1MS    ; wait > 25 ms after power on
E1A7 8692                     LDA     #RD_IDE_8255
E1A9 B7FF1F                   STA     PORTCTRL   ; set port C as output
E1AC 8680                     LDA     #IDE_RST   ; do a ide bus reset
E1AE B7FF1E                   STA     PORTC
E1B1 860A                     LDA     #10        ; keep reset low > 25 µs
E1B3 4A               LOOPRST DECA
E1B4 26FD                     BNE     LOOPRST
E1B6 7FFF1E                   CLR     PORTC
E1B9 8605                     LDA     #5
E1BB BDEFD3                   JSR     WAIT1MS    ; wait > 5 ms for cf to complete init
E1BE CC0000                   LDD     #$0000     ; init ram cf table
E1C1 FDDE7E                   STD     MSTCFOK    ; clear both cf present flags
E1C4 8681                     LDA     #IDE_FEA_16BIT ; prepare for 16 bits mode
E1C6 B7DE78                   STA     SETFEA
E1C9 8601                     LDA     #$01       ; prepare for rw 1 sector at a time
E1CB B7DE79                   STA     SCTCNT
E1CE 86E0                     LDA     #LBA3MST   ; prepare for master cf
E1D0 B7DE7D                   STA     LBA3
E1D3 7FDE7C                   CLR     LBA2       ; set all lba's to 0
E1D6 7FDE7B                   CLR     LBA1
E1D9 7FDE7A                   CLR     LBA0
E1DC BDF45A                   JSR     INIDT2     ; init typ 2/3 disk
E1DF 7DDE7E                   TST     MSTCFOK    ; master cf ok ?
E1E2 2711                     BEQ     CONTINI    ; no continue init
E1E4 8EE095                   LDX     #CFMST     ; display master cf message
E1E7 BDF525                   JSR     PSTRNG
E1EA 7DDE7F                   TST     SLVCFOK    ; slave cf ok ?
E1ED 2706                     BEQ     CONTINI    ; no continue init
E1EF 8EE0A8                   LDX     #CFSLV     ; display slave cf message
E1F2 BDF525                   JSR     PSTRNG
                      ;* End of IDE/CF init
                      
E1F5 B6FF02           CONTINI LDA     SYSREG
E1F8 43                       COMA               ; autoboot ?
E1F9 102B012C                 LBMI    BO         ; yes, boot FLEX
E1FD 7EF0D9                   JMP     MINITR     ; no, go to monitor
                      ;*
                      ;***************************
                      ;* Jump table for commands *
                      ;***************************
E200 4844             COMTAB  FCC     "HD" ; Hex dump .
E202 E5D3                     FDB     HD
E204 4452                     FCC     "DR" ; Display cpu registers.
E206 E75B                     FDB     DR
                      *
E208 5342                     FCC     "SB" ; Set baud rate for acia's.
E20A EDF5                     FDB     SB
E20C 5349                     FCC     "SI" ; Set input port.
E20E E2C4                     FDB     SI
E210 534F                     FCC     "SO" ; Set output port.
E212 E2EA                     FDB     SO
E214 4344                     FCC     "CD" ; Calculate two's complement branch length.
E216 E4A1                     FDB     CD
                      *
E218 5250                     FCC     "RP" ; Run program .
E21A E561                     FDB     RP
E21C 4A55                     FCC     "JU" ; Jump to program .
E21E E27E                     FDB     JU
E220 4A46                     FCC     "JF" ; Jump to FLEX warm start ($CD03).
E222 E2A4                     FDB     JF
E224 4350                     FCC     "CP" ; Continue program after SWI.
E226 E4F7                     FDB     CP
                      *
E228 4D45                     FCC     "ME" ; Memory examine and alter .
E22A E6E1                     FDB     ME
E22C 504D                     FCC     "PM" ; Poke memory with value (no verify of data).
E22E E646                     FDB     PM
E230 4C4B                     FCC     "LK" ; Load ascii text from keyboard .
E232 E688                     FDB     LK
E234 534D                     FCC     "SM" ; Shift a block of memory .
E236 E7B0                     FDB     SM
E238 464D                     FCC     "FM" ; Fill memory with a constant value.
E23A E523                     FDB     FM
E23C 4649                     FCC     "FI" ; Find ascii string.
E23E ED1F                     FDB     FI
                      *
E240 544D                     FCC     "TM" ; Quick memory test.
E242 E826                     FDB     TM
E244 5453                     FCC     "TS" ; Drive stepping and select test.
E246 EBF7                     FDB     TS
E248 5444                     FCC     "TD" ; Test random read on drive.
E24A EB76                     FDB     TD
                      *
E24C 424F                     FCC     "BO" ; Boot FLEX.COR or FLEX.SYS from logical drive 0
E24E E329                     FDB     BO
E250 5253                     FCC     "RS" ; Read sector from floppy.
E252 E8E3                     FDB     RS
E254 5753                     FCC     "WS" ; Write sector to floppy.
E256 E957                     FDB     WS
E258 4446                     FCC     "DF" ; Format disc to FLEX format.
E25A E9EA                     FDB     DF
                      ;*
                      ;*************************************
                      ;* Extra system dependant command    *
                      ;* entries fit here.                 *
                      ;*************************************
                      ;* LIB COMTABLE
                      ;*
E25C 4246                     FCC     "BF" ; Boot FLEX from floppy 0 regardless of allocation
E25E EC1C                     FDB     BF
E260 4443                     FCC     "DC" ; Display RTC contents
E262 EC3C                     FDB     DC
E264 4D43                     FCC     "MC" ; RTC examine and alter
E266 ECAC                     FDB     MC
                      ;*
E268 FF                       FCB     $FF  ; End of table flag.
                      ;*
                      ;***************************
                      ;* Common system commands. *
                      ;***************************
                      ;*
                      ;* Jump to program.
E269 0D4A756D7020746F JUMES   FCB     $0D,"Jump to program at ",4
     2070726F6772616D
     2061742004
                      
E27E 8EE269           JU      LDX     #JUMES
E281 BDF51E                   JSR     PDATA1
E284 BDF55C                   JSR     BADDR
E287 7EF637                   JMP     MAPOUT
                      ;*
                      ;* Jump to FLEX warm start.
E28A 0D4A756D7020746F JFMES   FCB     $0D,"Jump to FLEX warm start.",4
     20464C4558207761
     726D207374617274
     2E04
                      
E2A4 8EE28A           JF      LDX     #JFMES
E2A7 BDF51E                   JSR     PDATA1
E2AA 8ECD03                   LDX     #$CD03
E2AD 7EF637                   JMP     MAPOUT
                      ;*
                      ;* Set input port.
E2B0 0D53657420696E70 SIMES   FCB     $0D,"Set input port to ",4
     757420706F727420
     746F2004
                      
E2C4 8EE2B0           SI      LDX     #SIMES
E2C7 BDF51E                   JSR     PDATA1
E2CA BDF58C                   JSR     INHEX
E2CD 8403                     ANDA    #$03
E2CF B7DF8C                   STA     IPORT
E2D2 7EF0DF                   JMP     CONTRL
                      ;*
                      ;* Set output port.
E2D5 0D536574206F7574 SOMES   FCB     $0D,"Set output port to ",4
     70757420706F7274
     20746F2004
                      
E2EA 8EE2D5           SO      LDX     #SOMES
E2ED BDF51E                   JSR     PDATA1
E2F0 BDF58C                   JSR     INHEX
E2F3 8403                     ANDA    #$03
E2F5 B7DF8D                   STA     OPORT
E2F8 7EF0DF                   JMP     CONTRL
                      ;*
                      ;********************************
                      ;*    System specific Boot      *
                      ;*    command goes here.        *
                      ;********************************
                      ;* LIB BOOT
E2FB 0D               BOMES   FCB     $0D
E2FC 426F6F74696E6720         FCC     "Booting FLEX...."
     464C45582E2E2E2E
E30C 04                       FCB     $04
E30D 0A0D07           NOFLX   FCB     $0A,$0D,$07
E310 43616E2774206669         FCC     "Can't find FLEX!" ; Can't find FLEX
     6E6420464C455821
E320 04                       FCB     $04
E321 464C4558         BODIS   FCC     "FLEX"
E325 00000000                 FCB     $00,$00,$00,$00
                      
                      ;* Action BO (BOot FLEX from logical drive 0)
E329 8EE2FB           BO      LDX     #BOMES     ; send message
E32C BDF51E                   JSR     PDATA1
E32F 7FDF8E                   CLR     DRIVE      ; select drive 0
E332 8EDF8B                   LDX     #DRIVE-3
E335 BDF4AE                   JSR     RST        ; drive select and track 0
E338 C605                     LDB     #$05       ; sector 5
E33A F7DF90                   STB     SECTOR
E33D 4F                       CLRA
E33E B7DF8F                   STA     TRACK      ; (start of directory)
E341 F6DF90           BO1     LDB     SECTOR
E344 B6DF8F                   LDA     TRACK
E347 8EDE80                   LDX     #BUFFER    ; point to buffer
E34A BDF4A2                   JSR     READ       ; read sector
E34D 8EDE90                   LDX     #BUFFER+16 ; point to 1st name
E350 C60A                     LDB     #$0A       ; names per sector
E352 108EE321         BO2     LDY     #BODIS     ; (compare template)
E356 3410                     PSHS    X          ; save addr of name
E358 A680             BO3     LDA     ,X+        ; compare characters
E35A A1A0                     CMPA    ,Y+
E35C 260D                     BNE     BO4        ; match ?
E35E 108CE329                 CMPY    #BO        ; yes,all done ?
E362 26F4                     BNE     BO3        ; no,compare next
E364 EC05                     LDD     $05,X      ; yes,get start addr
E366 FDDF94                   STD     YTEMP      ; of file & store it
E369 201D                     BRA     RDSEC      ; go and load it
E36B 5A               BO4     DECB               ; no match.next name
E36C 2707                     BEQ     BO5        ; end of sector ?
E36E 3510                     PULS    X          ; no,recover name addr
E370 308818                   LEAX    $18,X      ; point to next name
E373 20DD                     BRA     BO2        ; and try again
E375 FCDE80           BO5     LDD     BUFFER     ; next dir sector
E378 2705                     BEQ     BOFAIL     ; end of directory ?
E37A FDDF8F                   STD     TRACK      ; no,update T/S addr
E37D 20C2                     BRA     BO1        ; and try again
E37F 8EE30D           BOFAIL  LDX     #NOFLX     ; yes,failed !
E382 BDF525                   JSR     PSTRNG     ; send error message
E385 7EF0DF                   JMP     CONTRL     ; and back to Mono9
                      ;* Load FLEX.SYS
E388 FCDF94           RDSEC   LDD     YTEMP      ; (T/S adr. of file)
E38B FDDE80                   STD     BUFFER     ; put in buffer
E38E 108EDF80                 LDY     #BUFFER+256
E392 8D34             BOFL1   BSR     NEXTB
E394 8102                     CMPA    #$02       ; binary record ?
E396 270A                     BEQ     BOFL2      ; yes,go set TTO
E398 8116                     CMPA    #$16       ; transfer addr ?
E39A 26F6                     BNE     BOFL1      ; cont.until 02 or 16
E39C 8D2A                     BSR     NEXTB      ; it was a transfer addr
E39E 8D28                     BSR     NEXTB      ; Discard it and
E3A0 20F0                     BRA     BOFL1      ; find next record
E3A2 8D24             BOFL2   BSR     NEXTB      ; get load adr.Hi
E3A4 B7DF96                   STA     TTO
E3A7 8D1F                     BSR     NEXTB      ; get load adr.Lo
E3A9 B7DF97                   STA     TTO+1
E3AC 8D1A                     BSR     NEXTB      ; get byte count
E3AE 1F89                     TFR     A,B        ; put it in ACC B
E3B0 5D                       TSTB               ; if 0, end of record
E3B1 27DF                     BEQ     BOFL1      ; go find next rec
E3B3 BEDF96                   LDX     TTO        ; else,copy to [TTO]
E3B6 3414             BOFL3   PSHS    X,B        ; save count & adr
E3B8 8D0E                     BSR     NEXTB      ; get a byte
E3BA 3514                     PULS    X,B        ; recall cnt.& adr skip
E3BC 8CDE00                   CMPX    #RAM       ; Microbox loads
E3BF 2202                     BHI     BOFL4      ; this area from tables
E3C1 A780                     STA     ,X+
E3C3 5A               BOFL4   DECB               ; end of record ?
E3C4 26F0                     BNE     BOFL3      ; no,continue
E3C6 20CA                     BRA     BOFL1      ; yes,find next rec
                      
                      ;* This subroutine gets the next byte from the buffer
                      ;* into ACC A. If the buffer is empty,the next sector
                      ;* is first read into the buffer. If all sectors have
                      ;* been read,a branch to 'Read tables & Exit' occures.
                      ;*
E3C8 108CDF80         NEXTB   CMPY    #BUFFER+256
E3CC 2610                     BNE     NEXT2      ; buffer empty ?
E3CE 8EDE80                   LDX     #BUFFER    ; yes,read next sector
E3D1 EC84                     LDD     ,X         ; look at link adr
E3D3 270C                     BEQ     LDTBL      ; no more, do tables
E3D5 BDF4A2                   JSR     READ
                      ;* If read error,density setting is toggled so try again
E3D8 26AE                     BNE     RDSEC      ; error if not 0
E3DA 108EDE84                 LDY     #BUFFER+4  ; point to name
E3DE A6A0             NEXT2   LDA     ,Y+
E3E0 39                       RTS
                      ;*
                      ;* Read Tables & Exit
                      ;*
E3E1 8ED3E5           LDTBL   LDX     #CINCHN    ; load table 1
E3E4 108EE420                 LDY     #TABLE1
E3E8 ECA1             LDTB1   LDD     ,Y++
E3EA ED81                     STD     ,X++
E3EC 8CD3FD                   CMPX    #$D3FD
E3EF 26F7                     BNE     LDTB1
E3F1 8EDE00                   LDX     #RAM
E3F4 108EE438                 LDY     #TABLE2    ; load table 2
E3F8 ECA1             LDTB2   LDD     ,Y++
E3FA ED81                     STD     ,X++
E3FC 8CDE1E                   CMPX    #$DE1E
E3FF 26F7                     BNE     LDTB2
E401 8639                     LDA     #$39
E403 B7CA02                   STA     MCA02
E406 7DDFB5                   TST     RTCFAIL    ; valid data ?
E409 270F                     BEQ     GOFLX      ; no,ignore
E40B 8ECC00                   LDX     #TTYBS     ; else,copy in
E40E C614                     LDB     #$14       ; TTYSET & ASN options
E410 BDF5EA           CPRTC   JSR     GETRTC
E413 A780                     STA     ,X+
E415 5C                       INCB
E416 C121                     CMPB    #$21
E418 26F6                     BNE     CPRTC
E41A 8ECD00           GOFLX   LDX     #COLDS     ; select Cold Start
E41D 7EF637                   JMP     MAPOUT     ; and jump to it
                      ;*
                      ;* Table 1 : console I/O
                      ;*
E420 F153             TABLE1  FDB     INCH1
E422 F130                     FDB     DUMMY
E424 FFFE                     FDB     VCRST
E426 FFFE                     FDB     VCRST
E428 F130                     FDB     DUMMY
E42A F130                     FDB     DUMMY
E42C F130                     FDB     DUMMY
E42E F0DF                     FDB     CONTRL
E430 F130                     FDB     DUMMY
E432 F131                     FDB     STATUS
E434 F16E                     FDB     OUTCH
E436 F16C                     FDB     INCH
                      ;*
                      ;* Table 2 : disk I/O
E438 7EF4A2           TABLE2  JMP     READ
E43B 7EF4A6                   JMP     WRITE
E43E 7EF4AA                   JMP     VERIFY
E441 7EF4AE                   JMP     RST
E444 7EF4B7                   JMP     DRV
E447 7EF4E7                   JMP     CHKRDY
E44A 7EF4EB                   JMP     QUICK
E44D 7EF4EF                   JMP     DINIT
E450 7EF507                   JMP     WARM
E453 7EF50B                   JMP     SEEK
                      ;*
                      ;*         Calculate displacement.
E456 0D43616C63756C61 CALDIS  FCB     $0D,"Calculate displacement from ",4
     746520646973706C
     6163656D656E7420
     66726F6D2004
E474 20746F2004       TOS     FCB     " to ",4
E479 0D0A204C6F6E6720 CALD1   FCB     $0D,$0A," Long or short branch (L/S)? ",4
     6F722073686F7274
     206272616E636820
     284C2F53293F2004
E499 2076616C75652004 VALUES  FCB     " value ",4
                      
E4A1 8EE456           CD      LDX     #CALDIS
E4A4 BDF51E                   JSR     PDATA1
E4A7 BDF55C                   JSR     BADDR      ; get 'from'
E4AA 3002                     LEAX    2,X        ; add 2
E4AC 3410                     PSHS    X          ; save it
E4AE 8EE474                   LDX     #TOS
E4B1 BDF51E                   JSR     PDATA1
E4B4 BDF55C                   JSR     BADDR      ; get 'to'
E4B7 1F12                     TFR     X,Y        ; save in Y
E4B9 8EE479                   LDX     #CALD1
E4BC BDF51E                   JSR     PDATA1
E4BF BDF16C                   JSR     INCH       ; get 'L/S'
E4C2 814C                     CMPA    #"L"       ; was it L ?
E4C4 2606                     BNE     CD1        ; no,branch
E4C6 3510                     PULS    X          ; recall 'from'
E4C8 3002                     LEAX    2,X        ; add 2
E4CA 3410                     PSHS    X          ; save again
E4CC 1F20             CD1     TFR     Y,D        ; D = 'to'
E4CE A3E4                     SUBD    ,S         ; subtract 'from'
E4D0 EDE4                     STD     ,S         ; 'offset' now TO S
E4D2 8EE499                   LDX     #VALUES
E4D5 BDF51E                   JSR     PDATA1
E4D8 3510                     PULS    X
E4DA BDF536                   JSR     PRINTX     ; 'offset'
E4DD 7EF0DF                   JMP     CONTRL
                      ;*(its not format, the program just send a reset command and configure the cf, no relation with the datas stored)
                      ;* Continue program. [There is a BUG in this routine]
E4E0 0D436F6E74696E75 CONPRS  FCB     $0D,"Continue from SWI....",4
     652066726F6D2053
     57492E2E2E2E04
                      
E4F7 8EE4E0           CP      LDX     #CONPRS
E4FA BDF51E                   JSR     PDATA1
E4FD 6C6B                     INC     11,S       ; (PC-low)
E4FF 7EE570                   JMP     RP1        ; recover SP & RTI.
                      ;* BUG here? What if PC-low = $FF ???
                      ;* why not  LDX   10,S
                      ;* LEAX   1,X
                      ;* STX   10,S   ie. Increment PC.
                      ;*
                      ;* Fill memory with constant.
E502 0D46696C6C206D65 FILMES  FCB     $0D,"Fill memory with constant from ",4
     6D6F727920776974
     6820636F6E737461
     6E742066726F6D20
     04
                      
E523 8EE502           FM      LDX     #FILMES
E526 BDF51E                   JSR     PDATA1
E529 BDF55C                   JSR     BADDR      ; get 'from'
E52C 1F12                     TFR     X,Y        ; save in Y
E52E 8EE474                   LDX     #TOS
E531 BDF51E                   JSR     PDATA1
E534 BDF55C                   JSR     BADDR      ; get 'to'
E537 3410                     PSHS    X          ; save in X
E539 8EE499                   LDX     #VALUES
E53C BDF51E                   JSR     PDATA1
E53F BDF567                   JSR     BYTE       ; get 'value'
E542 A7A0             FM1     STA     ,Y+        ; fill until
E544 10ACE4                   CMPY    ,S         ; from = to
E547 26F9                     BNE     FM1        ; then
E549 3510                     PULS    X          ; tidy stack
E54B 7EF0DF                   JMP     CONTRL
                      ;*
                      ;* Go to user routine at XXXX.
E54E 0D52756E2070726F RUNPRS  FCB     $0D,"Run program from ",4
     6772616D2066726F
     6D2004
                      
E561 8EE54E           RP      LDX     #RUNPRS
E564 BDF51E                   JSR     PDATA1
E567 BDF55C                   JSR     BADDR      ; input start addr
E56A AF6A                     STX     10,S       ; stack it as PC
E56C 86FF                     LDA     #$FF
E56E A7E4                     STA     ,S         ; stack as CC
E570 10FEDF80         RP1     LDS     STACK      ; recover SP
E574 3B                       RTI                ; load all registers
                      ;*
                      ;* SWI return from user program.
E575 10FFDF80         SWI     STS     STACK      ; save SP
E579 AE6A                     LDX     10,S       ; get PC
E57B 301F                     LEAX    -1,X       ; decrement it
E57D AF6A                     STX     10,S       ; and put it back
E57F 7EE761                   JMP     DR1        ; display registers
                      ;*
                      ;* Hexdump of memory starting at XXXX.
                      ;* @@ Modified 04/2025 PhR to get also ascii display on each line
E582 0D4865782064756D HEXDUS  FCB     $0D,"Hex dump of memory from ",4
     70206F66206D656D
     6F72792066726F6D
     2004
E59C 2020202020302020 HDMES1  FCB     "     0  1  2  3  4  5  6  7   8  9  A  B  C  D  E  F  ",4
     3120203220203320
     2034202035202036
     2020372020203820
     2039202041202042
     2020432020442020
     45202046202004
                      
E5D3 8EE582           HD      LDX     #HEXDUS
E5D6 BDF51E                   JSR     PDATA1
E5D9 BDF55C                   JSR     BADDR      ; get start addr
E5DC BDF512                   JSR     PCRLF
E5DF 108E0010         HD4     LDY     #16
E5E3 BDF512                   JSR     PCRLF
E5E6 3410                     PSHS    X
E5E8 8EE59C                   LDX     #HDMES1
E5EB BDF525                   JSR     PSTRNG     ; print header
E5EE 3510                     PULS    X
E5F0 BDF512           HD1     JSR     PCRLF
E5F3 BDF536                   JSR     PRINTX     ; print address
E5F6 C610                     LDB     #16        ; byte counter
E5F8 BDF5B3           HD2     JSR     OUT2HS     ; print a byte
E5FB 5A                       DECB
E5FC 2709                     BEQ     HD3        ; end of line ?
E5FE C108                     CMPB    #8         ; half way ?
E600 26F6                     BNE     HD2
E602 BDF5B5                   JSR     OUTS       ; yes,print a space
E605 20F1                     BRA     HD2
                      ; @@ BEGIN ASCII DUMP ADD
E607 BDF5B5           HD3     JSR     OUTS       ; @@ print space
E60A C6F0                     LDB     #-16       ; @@ prepare for 16 loops
E60C A685             ASCLOOP LDA     B,X        ; @@ load byte
E60E 8120                     CMPA    #$20       ; @@ printable ?
E610 2D04                     BLT     NOTPRT     ; @@ no
E612 817F                     CMPA    #$7F       ; @@ printable ?
E614 2D02                     BLT     HDCONT     ; @@ yes
E616 862E             NOTPRT  LDA     #"."       ; @@ if not printable print a dot
E618 BDF16E           HDCONT  JSR     OUTCH      ; @@ now print
E61B 5C                       INCB               ; @@ next byte
E61C 26EE                     BNE     ASCLOOP    ; @@ 16 bytes printed ? no do again
                      ; @@ END ASCII DUMP ADD
E61E 313F                     LEAY    -1,Y       ; end of page ?
E620 26CE                     BNE     HD1        ; no,do another line
E622 BDF16C                   JSR     INCH       ; yes,input a char
E625 810D                     CMPA    #$0D       ; if char == CR
E627 27B6                     BEQ     HD4        ; do another page
E629 812D                     CMPA    #"-"       ; if char == '-'
E62B 10260AB0                 LBNE    CONTRL
E62F 3089FE00                 LEAX    -512,X     ; do previous page
E633 20AA                     BRA     HD4
                      ;*
                      ;* Poke memory.
E635 0D506F6B65206D65 POKMES  FCB     $0D,"Poke memory at ",4
     6D6F727920617420
     04
                      
E646 8EE635           PM      LDX     #POKMES
E649 BDF51E                   JSR     PDATA1
E64C BDF55C                   JSR     BADDR      ; input addr
E64F 1F12                     TFR     X,Y
E651 8EE499                   LDX     #VALUES
E654 BDF51E                   JSR     PDATA1
E657 BDF567                   JSR     BYTE       ; input 'value'
E65A A7A4                     STA     ,Y         ; store at addr
E65C 7EF0DF                   JMP     CONTRL
                      ;*
                      ;* Keyboard to memory.
E65F 0D4C6F6164206D65 LOAKES  FCB     $0D,"Load memory with text from keyboard to ",4
     6D6F727920776974
     6820746578742066
     726F6D206B657962
     6F61726420746F20
     04
                      
E688 8EE65F           LK      LDX     #LOAKES
E68B BDF51E                   JSR     PDATA1
E68E BDF55C                   JSR     BADDR      ; input addr
E691 1F12                     TFR     X,Y
E693 8EE499                   LDX     #VALUES
E696 BDF51E                   JSR     PDATA1
E699 BDF16C           LK1     JSR     INCH       ; input a character
E69C A7A0                     STA     ,Y+        ; store it
E69E 8104                     CMPA    #$04       ; was it EOT ?
E6A0 26F7                     BNE     LK1        ; no,input another
E6A2 7EF0DF                   JMP     CONTRL
                      ;*
                      ;* Memory load and examine.
E6A5 0D4D656D6F727920 MEMEXS   FCB    $0D,"Memory examine and modify from ",4
     6578616D696E6520
     616E64206D6F6469
     66792066726F6D20
     04
E6C6 0720204E6F207261 NORAM    FCB    7,"  No ram at that address!",4
     6D20617420746861
     7420616464726573
     732104
                      
E6E1 8EE6A5           ME      LDX     #MEMEXS
E6E4 BDF51E                   JSR     PDATA1
E6E7 BDF55C                   JSR     BADDR      ; input addr
E6EA BDF512           ME1     JSR     PCRLF
E6ED BDF536                   JSR     PRINTX     ; display addr
E6F0 BDF5B3                   JSR     OUT2HS     ; and content
E6F3 BDF16C                   JSR     INCH       ; input a char
E6F6 812D                     CMPA    #"-"       ; was it a '-' ?
E6F8 2604                     BNE     ME2
E6FA 301E                     LEAX    -2,X       ; yes,back 2 locations
E6FC 20EC                     BRA     ME1
E6FE 810D             ME2     CMPA    #$0D       ; was it CR ?
E700 27E8                     BEQ     ME1        ; yes,display next
E702 8120                     CMPA    #$20       ; was it a space ?
E704 102609D7         MED     LBNE    CONTRL     ; no,abort
E708 BDF567                   JSR     BYTE       ; yes,input byte
E70B A71F                     STA     -1,X       ; overwrite old byte
E70D A11F                     CMPA    -1,X       ; read it back
E70F 27D9                     BEQ     ME1        ; OK,display it
E711 8EE6C6                   LDX     #NORAM     ; cant read,send
E714 BDF51E                   JSR     PDATA1     ; error message
E717 7EF0DF                   JMP     CONTRL
                      ;*
                      ;* Print registers.
E71A 0D446973706C6179 DISRES  FCB     $0D,"Display CPU registers.",4
     2043505520726567
     6973746572732E04
E732 0A0D434320204120 RSTRNG  FCB     $0A,$0D,"CC  A  B DP    X    Y    U   PC    S",$0A,$0D,4
     2042204450202020
     2058202020205920
     2020205520202050
     4320202020530A0D
     04
                      
E75B 8EE71A           DR      LDX     #DISRES
E75E BDF51E                   JSR     PDATA1
E761 8EE732           DR1     LDX     #RSTRNG
E764 BDF51E                   JSR     PDATA1     ; print header
E767 1F41                     TFR     S,X
E769 BDF5B3                   JSR     OUT2HS     ; print registers
E76C BDF5B3                   JSR     OUT2HS
E76F BDF5B3                   JSR     OUT2HS
E772 BDF5B3                   JSR     OUT2HS
E775 BDF5B1                   JSR     OUT4HS
E778 BDF5B1                   JSR     OUT4HS
E77B BDF5B1                   JSR     OUT4HS
E77E BDF5B1                   JSR     OUT4HS
E781 8EDF80                   LDX     #STACK     ; get Stack Pointer
E784 BDF5B1                   JSR     OUT4HS     ; print it
E787 7EF0DF                   JMP     CONTRL
                      ;*
                      ;* Shift blocks of memory.
E78A 0D53686966742062 SHIMES  FCB     $0D,"Shift block of memory from ",4
     6C6F636B206F6620
     6D656D6F72792066
     726F6D2004
E7A7 204C656E67746820 LENGHS  FCB     " Length ",4
     04
                      
E7B0 8EE78A           SM      LDX     #SHIMES
E7B3 BDF51E                   JSR     PDATA1
E7B6 BDF55C                   JSR     BADDR      ; get 'from' addr
E7B9 3440                     PSHS    U
E7BB 1F13                     TFR     X,U        ; store it in U
E7BD 8EE474                   LDX     #TOS
E7C0 BDF51E                   JSR     PDATA1
E7C3 BDF55C                   JSR     BADDR      ; get 'to' addr
E7C6 1F12                     TFR     X,Y        ; store it in Y
E7C8 8EE7A7                   LDX     #LENGHS
E7CB BDF51E                   JSR     PDATA1
E7CE BDF55C                   JSR     BADDR      ; get length of block
E7D1 A6C0             SM1     LDA     ,U+        ; move a byte
E7D3 A7A0                     STA     ,Y+
E7D5 301F                     LEAX    -1,X       ; dec. length
E7D7 26F8                     BNE     SM1        ; repeat 'till end
E7D9 3540                     PULS    U
E7DB 7EF0DF                   JMP     CONTRL
                      ;*
                      ;* Test memory.
E7DE 0D54657374206D65 TESMES  FCB     $0D,"Test memory from ",4
     6D6F72792066726F
     6D2004
E7F1 070A0D4572726F72 TMS1    FCB     7,$0A,$0D,"Error at location ",4
     206174206C6F6361
     74696F6E2004
E807 6368616E67656420 TMS2    FCB     "changed to ",4
     746F2004
E813 2054657374696E67 TMS3    FCB     " Testing now with ",4
     206E6F7720776974
     682004
                      
E826 8EE7DE           TM      LDX     #TESMES
E829 BDF51E                   JSR     PDATA1
E82C BDF55C                   JSR     BADDR      ; get 'from'
E82F 1F12                     TFR     X,Y        ; put in Y
E831 8EE474                   LDX     #TOS
E834 BDF51E                   JSR     PDATA1
E837 BDF55C                   JSR     BADDR      ; get 'to'
E83A BFDF92                   STX     XTEMP      ; store it
E83D 5F                       CLRB
E83E 8EE813                   LDX     #TMS3
E841 BDF51E                   JSR     PDATA1
E844 F7DF91           TM5     STB     TEMP       ; store 'with'
E847 8EDF91                   LDX     #TEMP
E84A BDF5A9                   JSR     OUT2H      ; display 'with'
E84D 1F21                     TFR     Y,X
E84F E7A4             TM1     STB     ,Y         ; write/read test
E851 E1A4                     CMPB    ,Y
E853 261A                     BNE     TM2        ; test fails,branch
E855 3121             TM4     LEAY    1,Y        ; else,next location
E857 10BCDF92                 CMPY    XTEMP      ; all done ?
E85B 26F2                     BNE     TM1
E85D 5C                       INCB               ; yes,next 'with' byte
E85E 270C                     BEQ     TM3        ; done 'em all.Exit
E860 8608                     LDA     #$08       ; else,update 'with'
E862 BDF16E                   JSR     OUTCH      ; byte,return to
E865 BDF16E                   JSR     OUTCH      ; first location
E868 1F12                     TFR     X,Y        ; and continue
E86A 20D8                     BRA     TM5
E86C 7EF0DF           TM3     JMP     CONTRL
E86F 8EE7F1           TM2     LDX     #TMS1      ; error message
E872 BDF51E                   JSR     PDATA1
E875 10BFDF92                 STY     XTEMP
E879 8EDF92                   LDX     #XTEMP     ; (faulty location)
E87C BDF5B1                   JSR     OUT4HS
E87F BDF5B5                   JSR     OUTS
E882 BDF5B5                   JSR     OUTS
E885 F7DF91                   STB     TEMP       ; (test byte)
E888 8EDF91                   LDX     #TEMP
E88B BDF5B3                   JSR     OUT2HS
E88E 8EE807                   LDX     #TMS2
E891 BDF51E                   JSR     PDATA1
E894 A6A4                     LDA     ,Y         ; (byte read back)
E896 B7DF91                   STA     TEMP
E899 8EDF91                   LDX     #TEMP
E89C BDF5B3                   JSR     OUT2HS
E89F 20CB                     BRA     TM3        ; exit
                      ;*
                      ;*
                      ;* Read floppy sector.
E8A1 0D52656164206672 REASES  FCB     $0D,"Read from sector on drive ",4
     6F6D20736563746F
     72206F6E20647269
     76652004
E8BD 20747261636B2004 TRACS   FCB     " track ",4
E8C5 20736563746F7220 SECS    FCB     " sector ",4
     04
E8CE 0D0A074644432065 ERR1    FCB     $0D,$0A,7,"FDC error code = ",4
     72726F7220636F64
     65203D2004
                      
E8E3 8EE8A1           RS      LDX     #REASES
E8E6 BDF51E                   JSR     PDATA1
E8E9 BDF58C                   JSR     INHEX      ; get drive No
E8EC B7DF8E                   STA     DRIVE
E8EF 8EDF8B                   LDX     #(DRIVE-3)
E8F2 BDF4B7                   JSR     DRV        ; get drive
E8F5 8EE8BD                   LDX     #TRACS
E8F8 BDF51E                   JSR     PDATA1
E8FB BDF567                   JSR     BYTE       ; get track
E8FE B7DF8F                   STA     TRACK
E901 8EE8C5                   LDX     #SECS
E904 BDF51E                   JSR     PDATA1
E907 BDF567                   JSR     BYTE       ; get sector
E90A B7DF90                   STA     SECTOR
E90D 8EE474                   LDX     #TOS
E910 BDF51E                   JSR     PDATA1
E913 BDF55C                   JSR     BADDR      ; get load addr
E916 B6DF8F                   LDA     TRACK
E919 F6DF90                   LDB     SECTOR
E91C BDF4A2                   JSR     READ       ; read it in
E91F 102707BC                 LBEQ    CONTRL     ; if no read error
E923 8EE8CE                   LDX     #ERR1
E926 BDF51E                   JSR     PDATA1     ; else,error message
E929 F7DF91                   STB     TEMP       ; (status,masked)
E92C 8EDF91                   LDX     #TEMP
E92F BDF5B3                   JSR     OUT2HS     ; error No
E932 7EF0DF                   JMP     CONTRL
                      ;*
                      ;* Write floppy sector
E935 0D57726974652074 WRIMES  FCB     $0D,"Write to sector on drive ",4
     6F20736563746F72
     206F6E2064726976
     652004
E950 2066726F6D2004   FROMS   FCB     " from ",4
                      
E957 8EE935           WS      LDX     #WRIMES
E95A BDF51E                   JSR     PDATA1
E95D BDF58C                   JSR     INHEX      ; get drive No
E960 B7DF8E                   STA     DRIVE
E963 8EDF8B                   LDX     #(DRIVE-3)
E966 BDF4B7                   JSR     DRV        ; get drive
E969 8EE8BD                   LDX     #TRACS
E96C BDF51E                   JSR     PDATA1
E96F BDF567                   JSR     BYTE       ; get track
E972 B7DF8F                   STA     TRACK
E975 8EE8C5                   LDX     #SECS
E978 BDF51E                   JSR     PDATA1
E97B BDF567                   JSR     BYTE       ; get sector
E97E B7DF90                   STA     SECTOR
E981 8EE950                   LDX     #FROMS
E984 BDF51E                   JSR     PDATA1
E987 BDF55C                   JSR     BADDR      ; get data addr
E98A B6DF8F                   LDA     TRACK
E98D F6DF90                   LDB     SECTOR
E990 BDF4A6                   JSR     WRITE      ; write sector
E993 10270748                 LBEQ    CONTRL     ; if no write error
E997 8EE8CE                   LDX     #ERR1
E99A BDF51E                   JSR     PDATA1     ; else,error message
E99D F7DF91                   STB     TEMP
E9A0 8EDF91                   LDX     #TEMP
E9A3 BDF5B3                   JSR     OUT2HS
E9A6 7EF0DF                   JMP     CONTRL
                      ;*
                      ;* Format disc to FLEX standard.
E9A9 0D466F726D617420 DISFOS  FCB     $0D,"Format disc to FLEX standard on drive ",4
     6469736320746F20
     464C455820737461
     6E64617264206F6E
     2064726976652004
E9D1 2073637261746368 SURES   FCB     " scratch disc in drive? ",4
     206469736320696E
     2064726976653F20
     04
                      
E9EA 8EE9A9           DF      LDX     #DISFOS
E9ED BDF51E                   JSR     PDATA1
E9F0 BDF58C                   JSR     INHEX      ; get drive No
E9F3 B7DF8E                   STA     DRIVE
E9F6 8EDF8B                   LDX     #DRIVE-3
E9F9 BDF4AE                   JSR     RST        ; restore to 00
E9FC 7FDFF4                   CLR     DEN        ; set single density
E9FF 8EE9D1                   LDX     #SURES     ; prompt for scratch
EA02 BDF51E                   JSR     PDATA1     ; disc in drive
EA05 BDF16C                   JSR     INCH       ; get reply
EA08 8159                     CMPA    #"Y"       ; if not 'Y'
EA0A 102606D1                 LBNE    CONTRL     ; then abort
EA0E 86FF             FMT     LDA     #$FF       ; else,initialise
EA10 B7DF8F                   STA     TRACK      ; (01-1)
EA13 108E0002                 LDY     #$0002     ; (track/sector)
EA17 4F               FMT1    CLRA
EA18 B7DF90                   STA     SECTOR     ; (01-1)
EA1B 7CDF8F                   INC     TRACK
EA1E B6DF8F                   LDA     TRACK
EA21 C601                     LDB     #1
EA23 BDF50B                   JSR     SEEK
                      ;* This is written to all tracks
EA26 4F                       CLRA
EA27 8E0190                   LDX     #400       ; starting this addr
EA2A C606                     LDB     #6
EA2C 1700FA                   LBSR    WABT       ; 6 bytes---00
EA2F 86FC                     LDA     #$FC
EA31 A780                     STA     ,X+        ; 1 bytes---FC
EA33 CCFF07                   LDD     #$FF07
EA36 1700F0                   LBSR    WABT       ; 7 bytes---FF
                      ;* This written to all sectors
EA39 4F               FMT2    CLRA
EA3A 7CDF90                   INC     SECTOR
EA3D C606                     LDB     #6
EA3F 1700E7                   LBSR    WABT       ; 6 bytes---00
EA42 86FE                     LDA     #$FE
EA44 A780                     STA     ,X+        ; 1 bytes---FE
EA46 B6DF8F                   LDA     TRACK
EA49 A780                     STA     ,X+        ; 1 bytes---[TRACK]
EA4B 4F                       CLRA
EA4C A780                     STA     ,X+        ; 1 bytes---00
EA4E B6DF90                   LDA     SECTOR
EA51 A780                     STA     ,X+        ; 1 bytes---[SECTOR]
EA53 8601                     LDA     #1
EA55 A780                     STA     ,X+        ; 1 bytes---01
EA57 86F7                     LDA     #$F7
EA59 A780                     STA     ,X+        ; 1 bytes---F7
EA5B CCFF0B                   LDD     #$FF0B
EA5E 1700C8                   LBSR    WABT       ; 11 bytes---FF
EA61 4F                       CLRA
EA62 C606                     LDB     #6
EA64 1700C2                   LBSR    WABT       ; 6 bytes---00
EA67 86FB                     LDA     #$FB
EA69 A780                     STA     ,X+        ; 1 bytes---FB
                      ;* Enter track/sector link, clear data bytes,
                      ;* update track/sector link.
EA6B 1F20                     TFR     Y,D        ; get T/S link addr
EA6D ED81                     STD     ,X++       ; enter it
EA6F 5C                       INCB
EA70 C10B                     CMPB    #11        ; all sectors done ?
EA72 260A                     BNE     FMT3       ; no,continue
EA74 4C                       INCA               ; yes,update T/S
EA75 C601                     LDB     #1         ; link address
EA77 8128                     CMPA    #40        ; all tracks done ?
EA79 2603                     BNE     FMT3       ; no,continue
EA7B CC0000                   LDD     #0         ; yes,clear T/S link
EA7E 1F02             FMT3    TFR     D,Y        ; save updated link
EA80 4F                       CLRA               ; clear data bytes
EA81 C6FE                     LDB     #254       ; 254 bytes---00
EA83 1700A3                   LBSR    WABT
EA86 86F7                     LDA     #$F7
EA88 A780                     STA     ,X+        ; 1 bytes---F7
EA8A CCFF0E                   LDD     #$FF0E
EA8D 170099                   LBSR    WABT       ; 14 bytes---FF
EA90 B6DF90                   LDA     SECTOR
EA93 810A                     CMPA    #10        ; last sector ?
EA95 26A2                     BNE     FMT2       ; no,do next
EA97 86FF                     LDA     #$FF
EA99 5F                       CLRB
EA9A 17008C                   LBSR    WABT       ; 256 bytes---FF
                      ;* Write a track to disc
EA9D 8E0190                   LDX     #400
EAA0 86F4                     LDA     #$F4       ; write track cmd.
EAA2 17077D                   LBSR    FCMD
EAA5 B6FF10           FMT4    LDA     COMREG     ; get status
EAA8 8502                     BITA    #2         ; D-reg empty ?
EAAA 2705                     BEQ     FMT5
EAAC A680                     LDA     ,X+        ; yes,load it
EAAE B7FF13                   STA     DATREG
EAB1 B6FF10           FMT5    LDA     COMREG
EAB4 8501                     BITA    #1         ; busy ?
EAB6 26ED                     BNE     FMT4       ; yes,wait
EAB8 B6DF8F                   LDA     TRACK
EABB 8127                     CMPA    #39        ; last track ?
EABD 1026FF56                 LBNE    FMT1       ; no,do next
                      ;* Remove link addr.from final directory sector
EAC1 8EDF8B                   LDX     #DRIVE-3
EAC4 BDF4AE                   JSR     RST
EAC7 8EDE80                   LDX     #BUFFER    ; read T/S 00/0A
EACA 4F                       CLRA               ; into buffer
EACB C60A                     LDB     #10        ; zero the link addr
EACD BDF4A2                   JSR     READ       ; (no more directory sectors)
EAD0 8EDE80                   LDX     #BUFFER
EAD3 6F84                     CLR     ,X
EAD5 6F01                     CLR     1,X
EAD7 4F                       CLRA
EAD8 C60A                     LDB     #10        ; and write it
EADA BDF4A6                   JSR     WRITE      ; back to disc
                      ;* Enter data to Sys.Information sector
EADD 8EDE80                   LDX     #BUFFER
EAE0 4F                       CLRA
EAE1 C603                     LDB     #3
EAE3 BDF4A2                   JSR     READ       ; read T/S 00/03
EAE6 8EDE80                   LDX     #BUFFER
EAE9 6F84                     CLR     ,X         ; clear link addr
EAEB 6F01                     CLR     1,X
EAED CC5343                   LDD     #$5343     ; enter name of disc
EAF0 ED8810                   STD     16,X
EAF3 CC5241                   LDD     #$5241     ; (SCRATCH!)
EAF6 ED8812                   STD     18,X
EAF9 CC5443                   LDD     #$5443
EAFC ED8814                   STD     20,X
EAFF CC4821                   LDD     #$4821
EB02 ED8816                   STD     22,X
EB05 CC0001                   LDD     #1         ; enter Vol. No
EB08 ED881B                   STD     27,X
EB0B CC0101                   LDD     #$0101     ; enter start of
EB0E ED881D                   STD     29,X       ; free chain
EB11 CC270A                   LDD     #$270A     ; enter end of
EB14 ED881F                   STD     31,X       ; free chain and
EB17 ED8826                   STD     38,X       ; highest sector adr
EB1A CC0186                   LDD     #$0186     ; enter length of
EB1D ED8821                   STD     33,X       ; free chain. (ie.
EB20 4F                       CLRA               ; sectors left)
EB21 C603                     LDB     #3
EB23 BDF4A6                   JSR     WRITE      ; write it back
EB26 7EF0DF                   JMP     CONTRL
                      ;*
                      ;* This subroutine stores ACCA in [B] locations
                      ;* starting at location [X]
EB29 3404             WABT    PSHS    B
EB2B A780             WABT1   STA     ,X+
EB2D 5A                       DECB
EB2E 26FB                     BNE     WABT1
EB30 3584                     PULS    B,PC
                      ;*
                      ;* Random read test on drive.
EB32 0D52616E646F6D20 TDMES   FCB     $0D,"Random sector read on drive ",4
     736563746F722072
     656164206F6E2064
     726976652004
EB50 48697420616E7920 TDMES1  FCB     "Hit any key to stop.",4
     6B657920746F2073
     746F702E04
EB65 617420747261636B ERR2    FCB     "at track/sector ",4
     2F736563746F7220
     04
                      
EB76 8EEB32           TD      LDX     #TDMES
EB79 BDF51E                   JSR     PDATA1
EB7C BDF58C                   JSR     INHEX      ; get drive No
EB7F B7DF8E                   STA     DRIVE
EB82 8EEB50                   LDX     #TDMES1
EB85 BDF525                   JSR     PSTRNG
EB88 8EDF8B                   LDX     #(DRIVE-3)
EB8B BDF4AE                   JSR     RST
EB8E BDF5BA           TDLOOP  JSR     RANDOM     ; get a random No
EB91 840F                     ANDA    #$0F       ; 15 max
EB93 8B01                     ADDA    #1         ; >0
EB95 810A                     CMPA    #10        ; >10 ?
EB97 2EF5                     BGT     TDLOOP     ; yes,get another
EB99 B7DF90                   STA     SECTOR     ; else,store it
EB9C BDF5BA           TDLP2   JSR     RANDOM     ; get a random No
EB9F 843F                     ANDA    #$3F       ; 63 max
EBA1 8127                     CMPA    #39        ; >39 ?
EBA3 2EF7                     BGT     TDLP2      ; yes,get another
EBA5 B7DF8F                   STA     TRACK      ; else,set random
EBA8 F6DF90                   LDB     SECTOR     ; track and sector
EBAB 8EDE80                   LDX     #BUFFER
EBAE BDF4A2                   JSR     READ       ; read into buffer
EBB1 260E                     BNE     TDLP9      ; read error if <> 0
EBB3 BDF131                   JSR     STATUS     ; key pressed ?
EBB6 27D6                     BEQ     TDLOOP     ; no,continue
EBB8 8EDF8B                   LDX     #(DRIVE-3) ; yes,
EBBB BDF4AE                   JSR     RST        ; restore to 00
EBBE 7EF0DF                   JMP     CONTRL     ; and abort
EBC1 8EE8CE           TDLP9   LDX     #ERR1      ; report ----
EBC4 BDF51E                   JSR     PDATA1
EBC7 F7DF91                   STB     TEMP
EBCA 8EDF91                   LDX     #TEMP
EBCD BDF5B3                   JSR     OUT2HS     ; error No.'x', at
EBD0 8EEB65                   LDX     #ERR2
EBD3 BDF51E                   JSR     PDATA1
EBD6 8EDF8F                   LDX     #TRACK
EBD9 BDF5B1                   JSR     OUT4HS     ; 'track/sector'
EBDC 20B0                     BRA     TDLOOP     ; continue
                      ;*
                      ;* Test drive stepping.
EBDE 0D54657374207374 TSMESS  FCB     $0D,"Test stepping on drive ",4
     657070696E67206F
     6E20647269766520
     04
                      
EBF7 8EEBDE           TS      LDX     #TSMESS
EBFA BDF51E                   JSR     PDATA1
EBFD BDF58C                   JSR     INHEX      ; get drive No
EC00 B7DF8E                   STA     DRIVE
EC03 8EDF8B                   LDX     #(DRIVE-3)
EC06 BDF4B7                   JSR     DRV        ; select drive
EC09 8628             TSLOOP  LDA     #40        ; track 40,sector 1
EC0B C601                     LDB     #1
EC0D BDF50B                   JSR     SEEK
EC10 BDF4AE                   JSR     RST        ; restore to 00
EC13 BDF131                   JSR     STATUS     ; key pressed ?
EC16 102604C5                 LBNE    CONTRL     ; yes,abort
EC1A 20ED                     BRA     TSLOOP     ; no,do it again
                      ;*
                      ;*
                      ;********************************************
                      ;* Extra system dependant commands go here. *
                      ;********************************************
                      ;* LIB COMMANDS
                      ;* Boot FLEX from floppy 0 regardless of allocation
EC1C 7FDF9D           BF      CLR     DDSTAB     ; set Drv.0=floppy 0
EC1F 16F707                   LBRA    BO         ; jump to loader
EC22 7EF0DF                   JMP     CONTRL     ; this appears to be redundant ?
                      ;*
                      ;* Display RTC non volatile data
EC25 0D               DCMES   FCB     $0D
EC26 446973706C617920         FCC     "Display RTC contents."
     52544320636F6E74
     656E74732E
EC3B 04                       FCB     $04
                      
EC3C 8EEC25           DC      LDX     #DCMES     ; print header
EC3F BDF51E                   JSR     PDATA1
EC42 BDF512                   JSR     PCRLF
EC45 5F                       CLRB               ; point to 1st byte
EC46 8E000E                   LDX     #$000E
EC49 8D2B                     BSR     PBLIN      ; time, date & regs (14 bytes)
EC4B 8E0001                   LDX     #$0001
EC4E 8D26                     BSR     PBLIN      ; configuration SW (1byte)
EC50 8E0001                   LDX     #$0001
EC53 8D21                     BSR     PBLIN      ; baudrates (1 byte)
EC55 8E0004                   LDX     #$0004
EC58 8D1C                     BSR     PBLIN      ; disc allocations (4 bytes)
EC5A 8E000B                   LDX     #$000B
EC5D 8D17                     BSR     PBLIN      ; ttyset (11 bytes)
EC5F 8E0002                   LDX     #$0002
EC62 8D12                     BSR     PBLIN      ; asn (2 bytes)
EC64 8E0008                   LDX     #$0008
EC67 8D0D                     BSR     PBLIN      ; GDC defaults (8 bytes)
EC69 8E0007                   LDX     #$0007
EC6C 8D08                     BSR     PBLIN      ; reserved (7 bytes)
EC6E 8E0010                   LDX     #$0010
EC71 8D03                     BSR     PBLIN      ; not used (16 bytes available)
EC73 7EF0DF                   JMP     CONTRL
                      ;*
                      ;* Prints a line of bytes
EC76 BDF5EA           PBLIN   JSR     GETRTC     ; get byte
EC79 5C                       INCB               ; point to next
EC7A B7DF91                   STA     TEMP
EC7D 3410                     PSHS    X
EC7F 8EDF91                   LDX     #TEMP      ; output bytes
EC82 BDF5B3                   JSR     OUT2HS
EC85 3510                     PULS    X
EC87 301F                     LEAX    -$01,X
EC89 26EB                     BNE     PBLIN      ; until line finished
EC8B BDF512                   JSR     PCRLF
EC8E 39                       RTS
                      ;*
                      ;* Modify RTC non volatile data
EC8F 0D               MCMES   FCB     $0D
EC90 525443206578616D         FCC     "RTC examine and alter"
     696E6520616E6420
     616C746572
ECA5 2066726F6D20             FCC     " from "
ECAB 04                       FCB     $04
                      
ECAC 8EEC8F           MC      LDX     #MCMES
ECAF BDF51E                   JSR     PDATA1     ; print header
ECB2 BDF567                   JSR     BYTE       ; input offset
ECB5 1F89                     TFR     A,B
ECB7 C43F             MC1     ANDB    #$3F
ECB9 BDF512                   JSR     PCRLF
ECBC F7DF91                   STB     TEMP
ECBF 8EDF91                   LDX     #TEMP
ECC2 BDF5B3                   JSR     OUT2HS     ; print offset
ECC5 BDF5EA                   JSR     GETRTC     ; get that byte
ECC8 B7DF91                   STA     TEMP
ECCB 8EDF91                   LDX     #TEMP
ECCE BDF5A9                   JSR     OUT2H      ; and print it
ECD1 BDF16C                   JSR     INCH       ; input a char
ECD4 8120                     CMPA    #$20       ; was it a space ?
ECD6 2609                     BNE     MC2
ECD8 BDF567                   JSR     BYTE       ; yes,input a byte
ECDB BDF608                   JSR     PUTRTC     ; put in RTC
ECDE 5C                       INCB               ; point to next
ECDF 20D6                     BRA     MC1        ; and jump to it
ECE1 810D             MC2     CMPA    #$0D       ; was it <cr> ?
ECE3 2603                     BNE     MC3
ECE5 5C                       INCB               ; yes,point to next
ECE6 20CF                     BRA     MC1
ECE8 812D             MC3     CMPA    #$2D       ; was it a '-' ?
ECEA 102603F1                 LBNE    CONTRL     ; no,exit
ECEE 5A                       DECB               ; yes,backpeddle 1
ECEF 20C6                     BRA     MC1
                      ;*
                      ;* Find byte string [There is a BUG in this routine ?]
                      ;*
ECF1 0D               FIMES   FCB     $0D
ECF2 46696E6420627974         FCC     "Find byte string from"
     6520737472696E67
     2066726F6D
ED07 20                       FCC     " "
ED08 04                       FCB     $04
ED09 0D0A             EBSMS   FCB     $0D,$0A
ED0B 656E746572206279         FCC     "enter byte string  "
     746520737472696E
     672020
ED1E 04                       FCB     $04
                      ;* Get start & end addresses and load the string templet
ED1F 8EECF1           FI      LDX     #FIMES
ED22 BDF51E                   JSR     PDATA1
ED25 BDF55C                   JSR     BADDR      ; input 'from'
ED28 BFDF94                   STX     YTEMP      ; store it
ED2B 8EE474                   LDX     #TOS
ED2E BDF51E                   JSR     PDATA1
ED31 BDF55C                   JSR     BADDR      ; input 'to'
ED34 BFDF96                   STX     TTO        ; store it
ED37 8EED09                   LDX     #EBSMS
ED3A BDF51E                   JSR     PDATA1
ED3D 8EDE80                   LDX     #BUFFER
ED40 5F                       CLRB               ; clr. count
ED41 BDF567           FI1     JSR     BYTE       ; input a byte
ED44 A780                     STA     ,X+        ; put in buffer
ED46 5C                       INCB               ; inc. count
ED47 BDF16C                   JSR     INCH       ; input a char
ED4A 8120                     CMPA    #$20       ; was it a space ?
ED4C 27F3                     BEQ     FI1        ; yes,get next byte
                      ;* Search for a match with the templet
ED4E F7DF91                   STB     TEMP       ; length of templet
ED51 BEDF94                   LDX     YTEMP      ; point to start adr
ED54 108EDE80                 LDY     #BUFFER    ; & start of templet
ED58 A680             FI2     LDA     ,X+        ; compare charater
ED5A A1A0                     CMPA    ,Y+
ED5C 2608                     BNE     FI3        ; no match, branch
ED5E 5A                       DECB               ; end of string ?
ED5F 26F7                     BNE     FI2        ; no, try next char
ED61 BDF512                   JSR     PCRLF      ; yes,do CRLF
ED64 8D11                     BSR     FI5        ; print out result
ED66 F6DF91           FI3     LDB     TEMP       ; reset count
ED69 108EDE80                 LDY     #BUFFER    ; point to 1st char
ED6D BCDF96                   CMPX    TTO        ; end of search block ?
ED70 2702                     BEQ     FI4        ; yes,exit
                      ;* BUG here. Should LEAX -1,X first...
ED72 20E4                     BRA     FI2        ; no,continue search
ED74 7EF0DF           FI4     JMP     CONTRL
                      ;* Print results (if any)
ED77 3436             FI5     PSHS    Y,X,D
ED79 B6DF91                   LDA     TEMP       ; get length of string
ED7C 40                       NEGA
ED7D 3086                     LEAX    A,X        ; sub.from current adr
ED7F 1F12                     TFR     X,Y        ; copy to Y
ED81 313A                     LEAY    -$06,Y     ; Y points to string-6
ED83 BFDF92                   STX     XTEMP
ED86 8EDF92                   LDX     #XTEMP     ; get addr.of string
ED89 BDF5B1                   JSR     OUT4HS     ; print it
ED8C 1F21                     TFR     Y,X        ; point to string-6
ED8E C610                     LDB     #$10       ; print out 16 bytes
ED90 A6A0             FI6     LDA     ,Y+
ED92 B7DF92                   STA     XTEMP
ED95 8EDF92                   LDX     #XTEMP
ED98 BDF5B3                   JSR     OUT2HS
ED9B 5A                       DECB
ED9C 26F2                     BNE     FI6
ED9E BDF5B5                   JSR     OUTS       ; followed by 2 spaces
EDA1 BDF5B5                   JSR     OUTS
EDA4 3130                     LEAY    -$10,Y     ; back to string-6
EDA6 C610                     LDB     #$10       ; now print ascii
EDA8 A6A0             FI7     LDA     ,Y+
EDAA 8120                     CMPA    #$20       ; is it printable ?
EDAC 2C02                     BGE     FI8        ; yes,print it
EDAE 862E                     LDA     #$2E       ; no,substitute dot
EDB0 BDF16E           FI8     JSR     OUTCH
EDB3 5A                       DECB
EDB4 26F2                     BNE     FI7
EDB6 35B6                     PULS    PC,Y,X,D
                      ;*
                      ;* Set baud Rate
                      ;*
EDB8 0D               SBMES   FCB     $0D
EDB9 5365742062617564         FCC     "Set baud rate for acia "
     207261746520666F
     72206163696120
EDD0 04                       FCB     $04
EDD1 2062617564207261 SBRMS   FCC     " baud rate = "
     7465203D20
EDDE 04                       FCB     $04
EDDF 2042617564207261 EBRNK   FCC     " Baud rate not known."
     7465206E6F74206B
     6E6F776E2E
EDF4 04                       FCB     $04
                      
EDF5 8EEDB8           SB      LDX     #SBMES
EDF8 BDF51E                   JSR     PDATA1
EDFB BDF58C                   JSR     INHEX      ; get acia No
EDFE 8401                     ANDA    #$01       ; NB.if acia2,A=0
EE00 B7DF91                   STA     TEMP       ; store it
EE03 8EEDD1                   LDX     #SBRMS     ; ask for baud rate
EE06 BDF51E                   JSR     PDATA1
EE09 BDF16C                   JSR     INCH       ; input first 2 digits
EE0C 1F89                     TFR     A,B        ; (ascii/decimal),of
EE0E BDF16C                   JSR     INCH       ; reqd.baud rate
EE11 1E89                     EXG     A,B        ; put them in order
EE13 1E02                     EXG     D,Y        ; and store in Y
EE15 8EEE77                   LDX     #TBAUD     ; use look-up table
EE18 10AC84           SB1     CMPY    ,X         ; found it ?
EE1B 2710                     BEQ     SB2
EE1D 3006                     LEAX    $06,X      ; no,try next
EE1F 8CEED1                   CMPX    #EBAUD
EE22 26F4                     BNE     SB1        ; all tried ?
EE24 8EEDDF                   LDX     #EBRNK     ; yes,error exit
EE27 BDF51E                   JSR     PDATA1
EE2A 7EF0DF                   JMP     CONTRL
EE2D A602             SB2     LDA     $02,X      ; print out last 3 digits
EE2F BDF16E                   JSR     OUTCH      ; of baud rate
EE32 A603                     LDA     $03,X
EE34 BDF16E                   JSR     OUTCH
EE37 A604                     LDA     $04,X
EE39 BDF16E                   JSR     OUTCH
EE3C A605                     LDA     $05,X      ; pick-up RTC code and set baud rate
EE3E 8EFF0C                   LDX     #BAUD      ; select register for
EE41 F6DF91                   LDB     TEMP       ; nominated acia
EE44 F7DF92                   STB     XTEMP
EE47 3A                       ABX
EE48 A784                     STA     ,X         ; load code
EE4A B7DF91                   STA     TEMP       ; save code
EE4D C60F                     LDB     #$0F       ; get existing RTC
EE4F BDF5EA                   JSR     GETRTC
EE52 7DDF92                   TST     XTEMP      ; which acia ?
EE55 2607                     BNE     SB3        ; acia1,branch
EE57 84F0                     ANDA    #$F0       ; erase acia2 code
EE59 BBDF91                   ADDA    TEMP       ; subs. new code
EE5C 2011                     BRA     SB4        ; go put in clock
EE5E F6DF91           SB3     LDB     TEMP       ; was acia1. get code
EE61 58                       ASLB               ; shift into high nibble
EE62 58                       ASLB
EE63 58                       ASLB
EE64 58                       ASLB
EE65 C4F0                     ANDB    #$F0
EE67 840F                     ANDA    #$0F       ; erase acia1 code
EE69 F7DF91                   STB     TEMP
EE6C BBDF91                   ADDA    TEMP       ; subs. new code
EE6F C60F             SB4     LDB     #$0F       ; store in RTC
EE71 BDF608                   JSR     PUTRTC
EE74 7EF0DF                   JMP     CONTRL
                      * Look-up table
EE77 3530202020       TBAUD   FCC     "50   "
EE7C 00                       FCB     $00
EE7D 3735202020               FCC     "75   "
EE82 01                       FCB     $01
EE83 3131302020               FCC     "110  "
EE88 02                       FCB     $02
EE89 3133352020               FCC     "135  "
EE8E 03                       FCB     $03
EE8F 3135302020               FCC     "150  "
EE94 04                       FCB     $04
EE95 3330302020               FCC     "300  "
EE9A 06                       FCB     $06
EE9B 3630302020               FCC     "600  "
EEA0 07                       FCB     $07
EEA1 3132303020               FCC     "1200 "
EEA6 08                       FCB     $08
EEA7 3138303020               FCC     "1800 "
EEAC 09                       FCB     $09
EEAD 3234303020               FCC     "2400 "
EEB2 0A                       FCB     $0A
EEB3 3336303020               FCC     "3600 "
EEB8 0B                       FCB     $0B
EEB9 3438303020               FCC     "4800 "
EEBE 0C                       FCB     $0C
EEBF 3732303020               FCC     "7200 "
EEC4 0D                       FCB     $0D
EEC5 3936303020               FCC     "9600 "
EECA 0E                       FCB     $0E
EECB 3139323030               FCC     "19200"
EED0 0F                       FCB     $0F
                      ;*
                      ;* Seems to be not used...
                      ;*
EED1 FF29FFAB0052     EBAUD   FCB     $FF,$29,$FF,$AB,$00,$52  ;EEFE: FF 29 FF AB 00 52 '.)...R'
EED7 FFA90250FFAB             FCB     $FF,$A9,$02,$50,$FF,$AB  ;EF04: FF A9 02 50 FF AB '...P..'
EEDD 0012FFAB0210             FCB     $00,$12,$FF,$AB,$02,$10  ;EF0A: 00 12 FF AB 02 10 '......'
EEE3 FFAB0010FFAB             FCB     $FF,$AB,$00,$10,$FF,$AB  ;EF10: FF AB 00 10 FF AB '......'
EEE9 0250FFAB0212             FCB     $02,$50,$FF,$AB,$02,$12  ;EF16: 02 50 FF AB 02 12 '.P....'
EEEF FFAB0050FFA9             FCB     $FF,$AB,$00,$50,$FF,$A9  ;EF1C: FF AB 00 50 FF A9 '...P..'
EEF5 0252FFAB0050             FCB     $02,$52,$FF,$AB,$00,$50  ;EF22: 02 52 FF AB 00 50 '.R...P'
EEFB FFA90212FFAB             FCB     $FF,$A9,$02,$12,$FF,$AB  ;EF28: FF A9 02 12 FF AB '......'
EF01 0250FFEB0010             FCB     $02,$50,$FF,$EB,$00,$10  ;EF2E: 02 50 FF EB 00 10 '.P....'
EF07 FFAB0010FFAB             FCB     $FF,$AB,$00,$10,$FF,$AB  ;EF34: FF AB 00 10 FF AB '......'
EF0D 0050FF0B0010             FCB     $00,$50,$FF,$0B,$00,$10  ;EF3A: 00 50 FF 0B 00 10 '.P....'
EF13 0000FBFF0000             FCB     $00,$00,$FB,$FF,$00,$00  ;EF40: 00 00 FB FF 00 00 '......'
EF19 FBFF0000FBFF             FCB     $FB,$FF,$00,$00,$FB,$FF  ;EF46: FB FF 00 00 FB FF '......'
EF1F 0000FBFF0000             FCB     $00,$00,$FB,$FF,$00,$00  ;EF4C: 00 00 FB FF 00 00 '......'
EF25 FBFF0000FFFF             FCB     $FB,$FF,$00,$00,$FF,$FF  ;EF52: FB FF 00 00 FF FF '......'
EF2B 0000FBFF0000             FCB     $00,$00,$FB,$FF,$00,$00  ;EF58: 00 00 FB FF 00 00 '......'
EF31 FFFF0000FBFF             FCB     $FF,$FF,$00,$00,$FB,$FF  ;EF5E: FF FF 00 00 FB FF '......'
EF37 0000FFFF0000             FCB     $00,$00,$FF,$FF,$00,$00  ;EF64: 00 00 FF FF 00 00 '......'
EF3D FBFF0000FBFF             FCB     $FB,$FF,$00,$00,$FB,$FF  ;EF6A: FB FF 00 00 FB FF '......'
EF43 0000FFFF0000             FCB     $00,$00,$FF,$FF,$00,$00  ;EF70: 00 00 FF FF 00 00 '......'
EF49 FBFF0000FFFF             FCB     $FB,$FF,$00,$00,$FF,$FF  ;EF76: FB FF 00 00 FF FF '......'
EF4F 0800FFFFA9FF             FCB     $08,$00,$FF,$FF,$A9,$FF  ;EF7C: 08 00 FF FF A9 FF '......'
EF55 1000A9FF5000             FCB     $10,$00,$A9,$FF,$50,$00  ;EF82: 10 00 A9 FF 50 00 '....P.'
EF5B ABFF1000A9FD             FCB     $AB,$FF,$10,$00,$A9,$FD  ;EF88: AB FF 10 00 A9 FD '......'
EF61 5000A9FF5000             FCB     $50,$00,$A9,$FF,$50,$00  ;EF8E: 50 00 A9 FF 50 00 'P...P.'
EF67 A9FF5200A9FF             FCB     $A9,$FF,$52,$00,$A9,$FF  ;EF94: A9 FF 52 00 A9 FF '..R...'
EF6D 5200A9FD5002             FCB     $52,$00,$A9,$FD,$50,$02  ;EF9A: 52 00 A9 FD 50 02 'R...P.'
EF73 A9FF1200A9FD             FCB     $A9,$FF,$12,$00,$A9,$FD  ;EFA0: A9 FF 12 00 A9 FD '......'
EF79 1002A9FF5000             FCB     $10,$02,$A9,$FF,$50,$00  ;EFA6: 10 02 A9 FF 50 00 '....P.'
EF7F A9FD5002A1FF             FCB     $A9,$FD,$50,$02,$A1,$FF  ;EFAC: A9 FD 50 02 A1 FF '..P...'
EF85 5200A9FD1202             FCB     $52,$00,$A9,$FD,$12,$02  ;EFB2: 52 00 A9 FD 12 02 'R.....'
EF8B A9FF5200A9FD             FCB     $A9,$FF,$52,$00,$A9,$FD  ;EFB8: A9 FF 52 00 A9 FD '..R...'
EF91 52020000FFFF             FCB     $52,$02,$00,$00,$FF,$FF  ;EFBE: 52 02 00 00 FF FF 'R.....'
EF97 0000FFFB0000             FCB     $00,$00,$FF,$FB,$00,$00  ;EFC4: 00 00 FF FB 00 00 '......'
EF9D FFFB0000FFFB             FCB     $FF,$FB,$00,$00,$FF,$FB  ;EFCA: FF FB 00 00 FF FB '......'
EFA3 0000FFFB0000             FCB     $00,$00,$FF,$FB,$00,$00  ;EFD0: 00 00 FF FB 00 00 '......'
EFA9 FFFB0000FFFB             FCB     $FF,$FB,$00,$00,$FF,$FB  ;EFD6: FF FB 00 00 FF FB '......'
EFAF 0000FFFB0000             FCB     $00,$00,$FF,$FB,$00,$00  ;EFDC: 00 00 FF FB 00 00 '......'
EFB5 FFFF0000FFFB             FCB     $FF,$FF,$00,$00,$FF,$FB  ;EFE2: FF FF 00 00 FF FB '......'
EFBB 0000FFFB0000             FCB     $00,$00,$FF,$FB,$00,$00  ;EFE8: 00 00 FF FB 00 00 '......'
EFC1 FFFB0000FFFB             FCB     $FF,$FB,$00,$00,$FF,$FB  ;EFEE: FF FB 00 00 FF FB '......'
EFC7 0008FFFB0000             FCB     $00,$08,$FF,$FB,$00,$00  ;EFF4: 00 08 FF FB 00 00 '......'
EFCD FFFF0038FFC9             FCB     $FF,$FF,$00,$38,$FF,$C9  ;EFFA: FF FF 00 38 FF C9 '...8..'
                      ;*
                      ;* Wait 1ms routine
                      ;* Input A = number of ms to wait
EFD3 C6C8             WAIT1MS LDB     #200
EFD5 5A               LOOPW   DECB
EFD6 26FD                     BNE     LOOPW
EFD8 4A                       DECA
EFD9 26F8                     BNE     WAIT1MS
EFDB 39                       RTS
                      ;*
                      ;*
F000                         ORG   PROM+$1000
                      ;*
                      ;*
                      ;********************************************
                      ;* Table of jump addresses for subroutines. *
                      ;* To use these subroutines use the         *
                      ;* indirect jump to subroutine thus:-       *
                      ;*        DELAY EQU $F014                   *
                      ;*        JSR [DELAY]                       *
                      ;********************************************
F000 F08E                    FDB   RESET        ; Cold start.
F002 F0DF                    FDB   CONTRL       ; Warm  start.
F004 F153                    FDB   INCH1        ; Input char without an echo.
F006 F16C                    FDB   INCH         ; Input char.
F008 F131                    FDB   STATUS       ; Check for char.
F00A F16E                    FDB   OUTCH        ; Output char.
F00C F51E                    FDB   PDATA1       ; Print string terminated by hex(04).
F00E F512                    FDB   PCRLF        ; Print a cr followed by a lf.
F010 F525                    FDB   PSTRNG       ; PCRLF followed by PDATA1.
F012 F130                    FDB   DUMMY        ; No init code.
F014 F542                    FDB   DELAY        ; Delay for (XREG) m/S.
F016 F55C                    FDB   BADDR        ; Get a four digit hex address into X.
F018 F567                    FDB   BYTE         ; Get a two hex digit number into A.
F01A F58C                    FDB   INHEX        ; Get a one digit hex char into A.
F01C F5A9                    FDB   OUT2H        ; Output two hex chars pointed to by X.
F01E F5B3                    FDB   OUT2HS       ; OUT2H plus a space.
F020 F5B1                    FDB   OUT4HS       ; Output four hex chars etc.
F022 F57D                    FDB   OUTHR        ; Output right hex digit in A.
F024 F579                    FDB   OUTHL        ; Output left hex digit in A.
F026 F5B5                    FDB   OUTS         ; Output a space.
F028 F5BA                    FDB   RANDOM       ; Returns a random number in the range 0-255.
F02A F52A                    FDB   PRINTA       ; Output the contents of A.
F02C F536                    FDB   PRINTX       ; Output the contents of X.
F02E F4A2                    FDB   READ         ; Read sector routine.
F030 F4A6                    FDB   WRITE        ; Write sector routine.
F032 F4AA                    FDB   VERIFY       ; Verify sector routine.
F034 F4AE                    FDB   RST          ; Restore to track 00.
F036 F4B7                    FDB   DRV          ; Drive select.
F038 F4E7                    FDB   CHKRDY       ; Check for drive ready.
F03A F4EB                    FDB   QUICK        ; Quick check for drive ready.
F03C F4EF                    FDB   DINIT        ; Drive cold start.
F03E F507                    FDB   WARM         ; Drive warm start.
F040 F50B                    FDB   SEEK         ; Seek to track.
                      ;*************************************
                      ;* Extra FDB'S for system dependant  *
                      ;* subroutines fit here.             *
                      ;*************************************
                      ;* LIB FDB
F042 F5DD                    FDB   GETTIM
F044 F5FB                    FDB   PUTTIM
F046 F5EA                    FDB   GETRTC
F048 F608                    FDB   PUTRTC
F04A F61D                    FDB   BEEP
F04C F641                    FDB   GCOM
F04E F653                    FDB   GPRM
F050 F662                    FDB   GPRMI
F052 F66D                    FDB   MASK
F054 F67F                    FDB   SETPEN
F056 F696                    FDB   SETPAT
F058 F6A9                    FDB   FIGSF
F05A F6CE                    FDB   FIGSG
F05C F6F7                    FDB   SETPAR
F05E F75B                    FDB   SETCRG
F060 F7B2                    FDB   GETCRG
F062 FA68                    FDB   SETCRT
F064 FA85                    FDB   GETCRT
F066 F7FC                    FDB   OFF
F068 F808                    FDB   ON
F06A F814                    FDB   GRAPH
F06C FAA4                    FDB   TEXT
F06E F82F                    FDB   MODE
F070 F846                    FDB   ZOOM
F072 F85D                    FDB   FILL
F074 F89E                    FDB   CLEARX
F076 F87C                    FDB   CLEAR
F078 FAC2                    FDB   CLEART
F07A F8D3                    FDB   GDCINI
F07C FB1C                    FDB   VIDCH
F07E F18D                    FDB   INKEY
F080 F91F                    FDB   POINT
F082 F92B                    FDB   LINE
F084 F9AB                    FDB   RECT
F086 F9D8                    FDB   CIRCLE
F088 FA29                    FDB   ARC
F08A FAF1                    FDB   CLINK
F08C F749                    FDB   VSYNC
                      ;*
                      ;**************************************
                      ;* Start of monitor  Entered on reset *
                      ;**************************************
                      ;*
F08E B7FFDD           RESET  STA   $FFDD         ; Set up SAM for 64k dynamic ram.
F091 B7FFDF                  STA   $FFDF         ; Set up SAM for map type 1.
                      ;*
F094 B6DF9C                  LDA   WARMS
F097 81AA                    CMPA  #$AA          ; Test for power down.
F099 2718                    BEQ   U1
                      ;*
F09B 4F                      CLRA
F09C 8EDF80                  LDX   #SCRAT
F09F A780             L1     STA   ,X+           ; Clear out scratch storage.
F0A1 8CE000                  CMPX   #(RAM+512)
F0A4 26F9                    BNE   L1
F0A6 86AA                    LDA   #$AA
F0A8 B7DF9C                  STA   WARMS
                      ;*
F0AB 10CEDE6F                LDS   #SSTACK       ; Set initial stack pointer.
F0AF 10FFDF80                STS   STACK         ; Same for user stack location.
                      ;*
F0B3 108EF111         U1     LDY   #UNEXP
F0B7 8EDF82                  LDX   #NMIV
F0BA 10AF81           U1L    STY   ,X++
F0BD 8CDF8C                  CMPX  #NMIV+10
F0C0 26F8                    BNE   U1L
                      ;*
                      ;***********************************
                      ;* System dependant init code goes *
                      ;* here. It should set the initial *
                      ;* input and output ports then     *
                      ;* check for auto boot.            *
                      ;***********************************
                      ;* LIB MINIT1
                      ;*
F0C2 864F                    LDA   #$4F
F0C4 B7FF02                  STA   SYSREG        ; set DDRA
F0C7 863C                    LDA   #$3C          ; Hi-nib=in
F0C9 B7FF03                  STA   SYSREG+1      ; Lo-nib=out
F0CC 8634                    LDA   #$34
F0CE B7FF01                  STA   PIA1+1        ; setup keyboard port
F0D1 8606                    LDA   #$06          ; set Drv 0,SD,and
F0D3 B7FF02                  STA   SYSREG        ; Rom at $E000
F0D6 7EE0EC                  JMP   MINIT1        ; do rest of setup
                      ;* (jump back here)
F0D9 8EE000           MINITR LDX   #HDR          ; Print header after reset.
F0DC BDF51E                  JSR   PDATA1
                      ;* Action control (Warm start entry)
F0DF B6FF02           CONTRL LDA   SYSREG
F0E2 8A04                    ORA   #4            ; Map in bottom 4k of eprom.
F0E4 B7FF02                  STA   SYSREG
F0E7 8EE028                  LDX   #PROMPT
F0EA BDF51E                  JSR   PDATA1
F0ED 8D7D                    BSR   INCH          ; Get two byte command into Y.
F0EF 1F89                    TFR   A,B
F0F1 8D79                    BSR   INCH
F0F3 1E89                    EXG   A,B
F0F5 1F02                    TFR   D,Y
F0F7 8EE200           PARSE  LDX   #COMTAB       ; Point to start of command table.
F0FA 10AC81           NEXT   CMPY  ,X++          ; Look for match.
F0FD 2602                    BNE   NOPE          ; No match.
F0FF 6E94                    JMP   [,X]          ; Found it, so jump to routine.
F101 3002             NOPE   LEAX  2,X           ; If no match then jump over address.
F103 A684                    LDA   ,X            ; Check for end of table.
F105 81FF                    CMPA  #$FF
F107 26F1                    BNE   NEXT          ; If not the end then try next entry.
F109 8EE02D           WHAT   LDX   #NOTTHS       ; No match so print message.
F10C BDF51E                  JSR   PDATA1
F10F 20CE                    BRA   CONTRL
                      *
F111 8EE041           UNEXP  LDX   #UNMESS       ; Unexpected interrupt ... Don't Panic!
F114 BDF525                  JSR   PSTRNG
F117 1A50                    ORCC  #%01010000    ; Set interupt masks.
F119 7EF08E                  JMP   RESET
                      ;*
                      ;* Interrupt vector routines.
                      ;*
F11C 6E9FDF82         NMI    JMP   [NMIV]
F120 6E9FDF84         IRQ    JMP   [IRQV]
F124 6E9FDF86         FIRQ   JMP   [FIRQV]
F128 6E9FDF88         SWI2   JMP   [SWI2V]
F12C 6E9FDF8A         SWI3   JMP   [SWI3V]
                      ;* No action goes here
F130 39               DUMMY  RTS
                      ;*
                      ;*****************************************************
                      ;* Console drivers                                   *
                      ;* ---------------                                   *
                      ;* The system dependant code for the console drivers *
                      ;* fits here. The entries in the jump tables INITAB  *
                      ;* INTAB,OUTTAB and STATAB should be changed to suit *
                      ;* these routines. For a description of the drivers  *
                      ;* for an 6850 acia see section 3 of the general     *
                      ;* FLEX adaptation guide (pp6-8).                    *
                      ;*****************************************************
                      ;*
                      ;* LIB CONSOLE
                      ;*
                      ;* Check for character
F131 3416             STATUS  PSHS    X,D
F133 7DDF8D                   TST     OPORT      ; video monitor ?
F136 2610                     BNE     STAT2      ; no,skip flash routine
F138 BEDFFD                   LDX     FLASH      ; used here as counter
F13B 2606                     BNE     STAT1      ; if <> 0,go decrement
F13D BDFB4A                   JSR     FLCUR      ; else toggle cursor
F140 8E0FA0                   LDX     #$0FA0     ; & reset counter
F143 301F             STAT1   LEAX    -$01,X
F145 BFDFFD                   STX     FLASH
F148 8EF187           STAT2   LDX     #TQINT
F14B F6DF8C                   LDB     IPORT
F14E 58                       ASLB
F14F AD95                     JSR     [B,X]      ; check for interrupt
F151 3596                     PULS    PC,X,D     ; Z=1 if no interrupt
                      ;* Input char without echo
F153 3414             INCH1   PSHS    X,B
F155 8DDA             INC1    BSR     STATUS     ; wait for interrupt
F157 27FC                     BEQ     INC1
F159 7DDFFF                   TST     BLANKD     ; cursor blanked ?
F15C 2703                     BEQ     INC2       ; no,skip
F15E BDFB4A                   JSR     FLCUR      ; yes,toggle again
F161 8EF17B           INC2    LDX     #TABIN
F164 F6DF8C                   LDB     IPORT
F167 58                       ASLB
F168 AD95                     JSR     [B,X]      ; get char.into ACCA
F16A 3594                     PULS    PC,X,B
                      ;* Input character
F16C 8DE5             INCH    BSR     INCH1
                      ;* Output character
F16E 3414             OUTCH   PSHS    X,B
F170 8EF181                   LDX     #TABOUT
F173 F6DF8D                   LDB     OPORT
F176 58                       ASLB
F177 AD95                     JSR     [B,X]
F179 3594                     PULS    PC,X,B
                      ;* Console I/O function table
F17B F18D             TABIN   FDB     INKEY
F17D F193                     FDB     GETA1
F17F F199                     FDB     GETA2
F181 F19F             TABOUT  FDB     PUTVID
F183 F1A2                     FDB     PUTA1
F185 F1AD                     FDB     PUTA2
F187 F1B8             TQINT   FDB     QINT0
F189 F1BE                     FDB     QINT1
F18B F1C4                     FDB     QINT2
                      ;* Get char from keyboard
F18D B6FF00           INKEY   LDA     PIA1
F190 847F                     ANDA    #$7F
F192 39                       RTS
                      ;* Get char from acia port 1
F193 B6FF08           GETA1   LDA     ACIA1
F196 847F                     ANDA    #$7F
F198 39                       RTS
                      ;* Get char from acia port 2
F199 B6FF04           GETA2   LDA     ACIA2
F19C 847F                     ANDA    #$7F
F19E 39                       RTS
                      ;* Send char to video
F19F 7EFB1C           PUTVID  JMP     VIDCH
                      ;* Send char to acia port 1
F1A2 F6FF09           PUTA1   LDB     ACIA1+1    ; check status
F1A5 C501                     BITB    #$01       ; TX ready ?
F1A7 27F9                     BEQ     PUTA1      ; no,wait
F1A9 B7FF08                   STA     ACIA1      ; yes,send char
F1AC 39                       RTS
                      ;* Send char to acia port 2
F1AD F6FF05           PUTA2   LDB     ACIA2+1
F1B0 C501                     BITB    #$01
F1B2 27F9                     BEQ     PUTA2
F1B4 B7FF04                   STA     ACIA2
F1B7 39                       RTS
                      ;* Check for interrupt, port 0 (keyboard)
F1B8 B6FF01           QINT0   LDA     PIA1+1
F1BB 8580                     BITA    #$80       ; test flag
F1BD 39                       RTS                ; if not,Z=1
                      ;* Check for interrupt, port 1 (acia 1)
F1BE B6FF09           QINT1   LDA     ACIA1+1
F1C1 8402                     ANDA    #$02
F1C3 39                       RTS
                      ;* Check for interrupt, port 2 (acia 2)
F1C4 B6FF05           QINT2   LDA     ACIA2+1
F1C7 8402                     ANDA    #$02
F1C9 39                       RTS
                      ;*
                      ;* Disc drive vector table (1 read, 2 write, 3 verify,
                      ;* 4 reset, 5 select, 6 check, 7 quick, 8 init, 9 warm, 10 seek)
                      ;*
                      ; floppy drive 0
F1CA F231             TABSRT  FDB     RDFLP      ; read
F1CC F272                     FDB     WRFLP      ; write
F1CE F2A3                     FDB     VRFLP      ; verify
F1D0 F2AE                     FDB     RSFLP      ; restore
F1D2 F2FC                     FDB     SELD0      ; drive select
F1D4 F336                     FDB     NVC0Z1     ; check
F1D6 F336                     FDB     NVC0Z1     ; quick
F1D8 F336                     FDB     NVC0Z1     ; init
F1DA F336                     FDB     NVC0Z1     ; warm
F1DC F2C4                     FDB     SKFLP      ; seek
                      ;* floppy drive 1
F1DE F231                     FDB     RDFLP      ; read
F1E0 F272                     FDB     WRFLP      ; write
F1E2 F2A3                     FDB     VRFLP      ; verify
F1E4 F2AE                     FDB     RSFLP      ; restore
F1E6 F306                     FDB     SELD1      ; drive select
F1E8 F336                     FDB     NVC0Z1     ; check
F1EA F336                     FDB     NVC0Z1     ; quick
F1EC F336                     FDB     NVC0Z1     ; init
F1EE F336                     FDB     NVC0Z1     ; warm
F1F0 F2C4                     FDB     SKFLP      ; seek
                      ;* Disk typ 2 -  IDE master
F1F2 F3EA                     FDB     RDDT2      ; read
F1F4 F406                     FDB     WRDT2      ; write
F1F6 F336                     FDB     NVC0Z1     ; verify
F1F8 F365                     FDB     DRVDT2     ; restore because -MUST- call drive select
F1FA F365                     FDB     DRVDT2     ; drive select
F1FC F439                     FDB     CHKDT2     ; check
F1FE F336                     FDB     NVC0Z1     ; quick
F200 F45A                     FDB     INIDT2     ; init
F202 F336                     FDB     NVC0Z1     ; warm
F204 F336                     FDB     NVC0Z1     ; seek
                      ;* Disk typ 3 - IDE slave
F206 F3EA                     FDB     RDDT2      ; read
F208 F406                     FDB     WRDT2      ; write
F20A F336                     FDB     NVC0Z1     ; verify
F20C F365                     FDB     DRVDT2     ; restore because -MUST- call drive select
F20E F365                     FDB     DRVDT2     ; drive select
F210 F439                     FDB     CHKDT2     ; check
F212 F336                     FDB     NVC0Z1     ; quick
F214 F336                     FDB     NVC0Z1     ; init already done by typ 2 disk
F216 F336                     FDB     NVC0Z1     ; warm
F218 F336                     FDB     NVC0Z1     ; seek
                      
                      ;*
                      ;* DISC I/O
                      ;*
                      ;* Query FDC busy status
F21A F6FF10           QBUSY   LDB     COMREG     ; get status register
F21D C501                     BITB    #$01       ; inspect bit 0
F21F 26F9                     BNE     QBUSY      ; if busy, wait
F221 39                       RTS
                      
                      * Load FDC command
F222 8DF6             FCMD    BSR     QBUSY      ; wait until ready
F224 B7FF10                   STA     COMREG     ; load command
                      
                      ;* Twiddle your thumbs for 100 micro-Secs
F227 170000           PAUSE   LBSR    PAUS1
F22A 170000           PAUS1   LBSR    PAUS2
F22D 170000           PAUS2   LBSR    PAUS3
F230 39               PAUS3   RTS
                      
                      ;* Read a sector from floppy drive 0/1
F231 170090           RDFLP   LBSR    SKFLP      ; seek track/sector
F234 86FF                     LDA     #$FF       ; set DP = $FF
F236 1E8B                     EXG     A,DP
F238 3402                     PSHS    A          ; save old DP
F23A 8684                     LDA     #$84       ; read sector cmd
F23C 8DE4                     BSR     FCMD       ; load command
F23E 5F                       CLRB
F23F 9610             RDFL1   LDA     <COMREG    ; COMREG (status)
F241 8502                     BITA    #$02       ; data reg full ?
F243 260C                     BNE     RDFL3      ; yes,branch
F245 8501                     BITA    #$01       ; cmd executed ?
F247 26F6                     BNE     RDFL1      ; no,wait
F249 200F                     BRA     RDFL4
F24B 9610             RDFL2   LDA     <COMREG    ; status
F24D 8506                     BITA    #$06       ; ready ?
F24F 27FA                     BEQ     RDFL2      ; no,wait
F251 9613             RDFL3   LDA     <DATREG    ; data reg
F253 A780                     STA     ,X+
F255 5A                       DECB               ; last byte done ?
F256 26F3                     BNE     RDFL2      ; no,continue
F258 20E5                     BRA     RDFL1      ; yes,check status
F25A 1F89             RDFL4   TFR     A,B        ; ACCB = status
F25C 3502                     PULS    A          ; restore DP
F25E 1E8B                     EXG     A,DP
F260 C510                     BITB    #$10       ; record found ?
F262 270B                     BEQ     RDFL5      ; yes,exit
F264 B6FF02                   LDA     SYSREG     ; no,toggle DEN
F267 8802                     EORA    #$02
F269 B7FF02                   STA     SYSREG
F26C 73DFF4                   COM     DEN        ; toggle DEN
F26F C41C             RDFL5   ANDB    #$1C       ; Z=1 if no error
F271 39                       RTS
                      
                      ;* Write a sector to floppy drive 0/1
F272 8D50             WRFLP   BSR     SKFLP      ; seek track/sector
F274 86FF                     LDA     #$FF       ; change DP
F276 1E8B                     EXG     A,DP
F278 3402                     PSHS    A          ; save old DP
F27A 86A4                     LDA     #$A4       ; write sector cmd
F27C 8DA4                     BSR     FCMD       ; load cmd
F27E 5F                       CLRB
F27F 9610             WRFL1   LDA     <COMREG    ; get status
F281 8502                     BITA    #$02       ; data reg.empty ?
F283 260C                     BNE     WRFL3      ; yes,branch
F285 8501                     BITA    #$01       ; busy ?
F287 26F6                     BNE     WRFL1      ; yes,wait
F289 200F                     BRA     WRFL4      ; else,branch
F28B 9610             WRFL2   LDA     <COMREG    ; check status
F28D 8506                     BITA    #$06       ; ready ?
F28F 27FA                     BEQ     WRFL2      ; no,wait
F291 A680             WRFL3   LDA     ,X+        ; send byte
F293 9713                     STA     <DATREG
F295 5A                       DECB               ; all done ?
F296 26F3                     BNE     WRFL2      ; no,continue
F298 20E5                     BRA     WRFL1      ; yes,check status
F29A 1F89             WRFL4   TFR     A,B        ; put status in B
F29C 3502                     PULS    A          ; restore DP
F29E 1E8B                     EXG     A,DP
F2A0 C45C                     ANDB    #$5C       ; test status
F2A2 39                       RTS                ; Z=1 if no error
                      
                      ;* Verify a sector on floppy drive 0/1
F2A3 8684             VRFLP   LDA     #$84       ; (read sector cmd)
F2A5 17FF7A                   LBSR    FCMD       ; load cmd
F2A8 17FF6F                   LBSR    QBUSY      ; wait 'till finished
F2AB C418                     ANDB    #$18
F2AD 39                       RTS                ; Z=1 if no error
                      
                      ;* Restore to track 00 floppy drive 0/1
F2AE B6FF02           RSFLP   LDA     SYSREG
F2B1 8A02                     ORA     #$02       ; set single density
F2B3 B7FF02                   STA     SYSREG
F2B6 8600                     LDA     #$00       ; restore cmd
F2B8 BBDFF6                   ADDA    STEP       ; adjust for step rate
F2BB 17FF64                   LBSR    FCMD       ; load cmd
F2BE 17FF59                   LBSR    QBUSY      ; wait 'till finished
F2C1 C458                     ANDB    #$58
F2C3 39                       RTS                ; z=1 if no error
                      
                      ;* Seek to track/sector floppy drive 0/1
F2C4 F7FF12           SKFLP   STB     COMREG+2   ; rqud. sector
F2C7 B7FF13                   STA     DATREG     ; reqd. track
F2CA B6FF02                   LDA     SYSREG
F2CD 7DDFF4                   TST     DEN        ; double density ?
F2D0 270B                     BEQ     SDEN       ; no,set single
F2D2 7DFF13                   TST     DATREG     ; yes,set double except if
F2D5 2706                     BEQ     SDEN       ; track 0 => single density
F2D7 84FD                     ANDA    #$FD
F2D9 C112                     CMPB    #$12       ; sector/track
F2DB 2004                     BRA     DDEN
F2DD 8A02             SDEN    ORA     #$02       ; single density
F2DF C10A                     CMPB    #$0A       ; sector/track
F2E1 2F04             DDEN    BLE     SKFL1
F2E3 84BF                     ANDA    #$BF
F2E5 2002                     BRA     SKFL2
F2E7 8A40             SKFL1   ORA     #$40
F2E9 B7FF02           SKFL2   STA     SYSREG
F2EC 8610                     LDA     #$10       ; seek sector cmd
F2EE BBDFF6                   ADDA    STEP       ; adjusted for step rate
F2F1 17FF2E                   LBSR    FCMD       ; load cmd
F2F4 17FF23                   LBSR    QBUSY      ; wait 'till finished
F2F7 C510                     BITB    #$10       ; check status
F2F9 16FF2B                   LBRA    PAUSE      ; exit via pause
                      
                      ;* Select floppy drive 0
F2FC B6FF02           SELD0   LDA     SYSREG
F2FF 84FE                     ANDA    #$FE       ; set DRV 0
F301 F6DFF7                   LDB     SPEED
F304 2008                     BRA     SETD
                      
                      ;* Select floppy drive 1
F306 B6FF02           SELD1   LDA     SYSREG
F309 8A01                     ORA     #$01
F30B F6DFF8                   LDB     TSTEP
F30E B7FF02           SETD    STA     SYSREG
F311 F7DFF6                   STB     STEP
F314 E603                     LDB     $03,X      ; get drive No
F316 F1DFB6                   CMPB    CURDRV     ; same as current ?
F319 271B                     BEQ     NVC0Z1     ; yes,branch
F31B F7DFB6                   STB     CURDRV     ; else,update current
F31E B6FF11                   LDA     COMREG+1   ; set TRACK & DEN
F321 F6DF8F                   LDB     TRACK
F324 B7DF8F                   STA     TRACK
F327 F7FF11                   STB     COMREG+1
F32A B6DFF4                   LDA     DEN
F32D F6DFF5                   LDB     DEN1
F330 B7DFF5                   STA     DEN1
F333 F7DFF4                   STB     DEN
                      
                      ;* Return with N,V,C clear, Z set
                      ;* No error
F336 5F               NVC0Z1  CLRB                ; clear B - set Z
F337 1CFE                     ANDCC   #$FE        ; clear C   
F339 39                       RTS
                      
                      ;* Return with N,V,Z clear, C set
                      ;* Error
F33A C640             NVZ0C1  LDB     #$40        ; load B - clear Z
F33C 1A01                     ORCC    #$01        ; set C
F33E 39                       RTS
                      
                      ;* Set DP to $FF,speed to fast
F33F 1E8B             FAST    EXG     A,DP       ; save present DP
F341 B7DFFC                   STA     REGDP
F344 86FF                     LDA     #$FF       ; set DP = $FF
F346 1E8B                     EXG     A,DP
F348 B7FFD9                   STA     SET_R1     ; set Fast speed
F34B 39                       RTS
                      
                      ;* Restore DP,speed to slow
F34C B6DFFC           SLOW    LDA     REGDP      ; restore former DP
F34F 1E8B                     EXG     A,DP
F351 7DDFF9                   TST     PSPEED     ; test current speed
F354 260E                     BNE     SLOW2
F356 B7FFD7                   STA     SET_R0     ; set slow speed
F359 B7FFD8                   STA     CLR_R1
F35C 7D0000                   TST     >$0000
F35F 21EB                     BRN     SLOW
F361 B7FFD6                   STA     CLR_R0
F364 39               SLOW2   RTS
                      
                      ;* =====================================================================
                      ;* VARIOUS IDE / 8255 DISK ROUTINES
                      ;* =====================================================================
                      
                      ;*
                      ;* Select master / slave CF
F365 3412             DRVDT2      PSHS    A,X
F367 7DDE7E                       TST     MSTCFOK             ; check if master cf present ?
F36A 271B                         BEQ     DRVERR              ; no exit with error
F36C A603                         LDA     3,X                 ; get FLEX disk number
F36E 8EDF9D                       LDX     #DDSTAB
F371 E686                         LDB     A,X                 ; get physical disk number
F373 86E0                         LDA     #LBA3MST            ; master cf by default
F375 C102                         CMPB    #$02                ; master asked ?
F377 2707                         BEQ     ENDDRVDT2           ; yes exit ok
F379 7DDE7F                       TST     SLVCFOK             ; if not master then its slave - present ?
F37C 2709                         BEQ     DRVERR              ; no exit with error
F37E 86F0                         LDA     #LBA3SLV
                      
F380 B7DE7D           ENDDRVDT2   STA     LBA3                ; update LBA3 in ram
F383 8DB1                         BSR     NVC0Z1              ; no error
F385 3592                         PULS    A,X,PC
                      
F387 8DB1             DRVERR      BSR     NVZ0C1              ; error
F389 3592                         PULS    A,X,PC
                      ;*
                      ;* Compute lba number from FLEX track/sector
                      ;*
                      ;* The cf disk is assumed to be 122 tracks (00$ to $79) of 256 sectors ($00 to $ff)
                      ;* This is a 15990784 bytes disk in 31232 lba of 512 bytes
                      ;*
                      ;* A*256+B IS SAME AS PUT REG A INTO MSB OF A WORD THEN ADD REG B
                      ;* SO REG A CAN BE DIRECTLY USED AS LBA1 AND REG B AS LBA0
                      ;
                      ;* Input : A = FLEX track
                      ;*         B = FLEX sector
                      ;*         X = FLEX fcb address
                      ;*
                      ;* Output : lba0 and lba1 updated in ram storage zone
F38B B7DE7B           SETLBA      STA     LBA1                ; store lba in table
F38E F7DE7A                       STB     LBA0                ; fall into transfer routine
                      ;*
                      ;* Transfer params table from memory to cf
                      ;* and enable data
F391 3436             TFRPARM     PSHS    A,B,X,Y
F393 8EDE7E                       LDX     #LBA3+1             ; load table address + 1
F396 108E000E                     LDY     #IDE_LBA3           ; load 1st cf register to write
                      
F39A 8D18             PARMLOP     BSR     CMDWAIT
F39C 1F20                         TFR     Y,D                 ; get Y lsb into B
F39E A682                         LDA     ,-X                 ; with pre decr load param from table
F3A0 8D26                         BSR     WRT_IDE             ; write param in cf
F3A2 313F                         LEAY    -1,Y                ; change cf register
F3A4 108C0008                     CMPY    #IDE_SET_FEAT-1     ; check if 6 params loaded in cf
F3A8 26F0                         BNE     PARMLOP             ; if 6 params not loaded do again
                      
F3AA 8D08                         BSR     CMDWAIT
F3AC 86EF                         LDA     #IDE_CMD_SET_FEAT   ; now enable features
F3AE C60F                         LDB     #IDE_COMMAND
F3B0 8D16                         BSR     WRT_IDE
F3B2 35B6                         PULS    A,B,X,Y,PC
                      ;*
                      ;* Wait cf card command ready
F3B4 8D09             CMDWAIT     BSR     DATWAIT             ; status register valid only if busy bit clear
F3B6 C60F             CWLOOP      LDB     #IDE_STATUS         ; ask status register
F3B8 8D20                         BSR     READ_IDE
F3BA 8540                         BITA    #RDYBIT             ; read ready bit
F3BC 27F8                         BEQ     CWLOOP              ; wait ready bit set
F3BE 39                           RTS
                      ;*
                      ;* Wait cf card data ready
F3BF C60F             DATWAIT     LDB     #IDE_STATUS         ; ask status register
F3C1 8D17                         BSR     READ_IDE            ; A receive status register
F3C3 8580                         BITA    #BSYBIT             ; read busy bit
F3C5 26F8                         BNE     DATWAIT             ; not clear ? yes do again
F3C7 39                           RTS
                      ;*
                      ;* Do a one byte write cycle to ide
                      ;* B = cf register where to write
                      ;* A = byte to write
                      ;* !!!--- DP REGISTER MUST BE SET TO PIA2 PAGE ---!!!
F3C8 3402             WRT_IDE     PSHS    A
F3CA 8680                         LDA     #WR_IDE_8255        ; set 8255 A/B/C for output
F3CC 971F                         STA     <PORTCTRL
F3CE 3502                         PULS    A
F3D0 971C                         STA     <PORTA              ; prepare lsb on output d0-d7
F3D2 D71E                         STB     <PORTC              ; set cf register address
F3D4 CA20                         ORB     #IDE_WR             ; assert wr line
F3D6 D71E                         STB     <PORTC
F3D8 200C                         BRA     ENDIDERW
                      ;*
                      ;* Do a one byte read cycle from ide
                      ;* B = cf register to read
                      ;* A = byte read
                      ;* !!!--- DP REGISTER MUST BE SET TO PIA2 PAGE ---!!!
F3DA 8692             READ_IDE    LDA     #RD_IDE_8255        ; set 8255 A/B for input C for output
F3DC 971F                         STA     <PORTCTRL
F3DE D71E                         STB     <PORTC              ; set cf register address
F3E0 CA40                         ORB     #IDE_RD             ; assert rd line
F3E2 D71E                         STB     <PORTC
F3E4 961C                         LDA     <PORTA              ; read lsb from d0-d7
                      
F3E6 7FFF1E           ENDIDERW    CLR     PORTC               ; release ide device
F3E9 39                           RTS
                      ;*
                      ;* Read sector from disk typ 8255 / ide
                      ;* (A=track,B=sector,X=addr of a sector buffer)
F3EA 343E             RDDT2       PSHS    DP,Y,X,B,A
                      
F3EC 8D43                         BSR     SETDP               ; set DP register
                      
F3EE 8D9B                         BSR     SETLBA              ; compute lba and set params in cf
                      
F3F0 8DC2                         BSR     CMDWAIT
F3F2 8620                         LDA     #IDE_CMD_READ       ; send read command to the cf card
F3F4 C60F                         LDB     #IDE_COMMAND        ; load command register address
F3F6 8DD0                         BSR     WRT_IDE             ; send command to the cf card
                      
F3F8 8D2E             RDLOOP      BSR     CHKDRQ
F3FA 2727                         BEQ     RWEXIT              ; Z set ? yes end of loop
F3FC 8DC1                         BSR     DATWAIT
F3FE C608                         LDB     #IDE_DATA
F400 8DD8                         BSR     READ_IDE            ; read the data byte from cf
F402 A780                         STA     ,X+                 ; write it to the buffer
F404 20F2                         BRA     RDLOOP
                      ;*
                      ;* Write a sector to disk typ 8255 / ide
                      ;* (A=track,B=sector,X=addr of a sector buffer)
F406 343E             WRDT2       PSHS    DP,Y,X,B,A
                      
F408 8D27                         BSR     SETDP               ; set DP register
                      
F40A BDF38B                       JSR     SETLBA              ; compute lba and set params in cf
                      
F40D 8DA5                         BSR     CMDWAIT
F40F 8630                         LDA     #IDE_CMD_WRITE      ; send write command to the cf card
F411 C60F                         LDB     #IDE_COMMAND        ; load command register address
F413 8DB3                         BSR     WRT_IDE             ; send command to the cf card
                      
F415 8D11             WRLOOP      BSR     CHKDRQ
F417 270A                         BEQ     RWEXIT              ; Z set ? yes end of loop
F419 8DA4                         BSR     DATWAIT
F41B A680                         LDA     ,X+                 ; read the byte from the buffer
F41D C608                         LDB     #IDE_DATA           ; write the data byte to cf
F41F 8DA7                         BSR     WRT_IDE
F421 20F2                         BRA     WRLOOP
                      
F423 BDF336           RWEXIT      JSR     NVC0Z1              ;  set cc with no error & rts
F426 35BE                         PULS    DP,Y,X,B,A,PC
                      ;*
                      ;* Check cf DRQ bit
                      ;* Return Z=0 if DRQ set
                      ;*        Z=1 if DRQ not set
F428 8D95             CHKDRQ      BSR     DATWAIT
F42A C60F                         LDB     #IDE_STATUS
F42C 8DAC                         BSR     READ_IDE
F42E 8508                         BITA    #DRQBIT
F430 39                           RTS
                      
                      ;*
                      ;* Set DP register to PIA2 page
F431 3402             SETDP       PSHS    A
F433 86FF                         LDA     #PIA2PAG
F435 1F8B                         TFR     A,DP
F437 3582                         PULS    A,PC
                      
                      ;*
                      ;* Chkrdy disk typ 2 & 3
                      ;* We just check if CF has been detected by init routine
F439 3412             CHKDT2      PSHS    X,A
F43B 7DDE7E                       TST     MSTCFOK
F43E 2715                         BEQ     NOTRDY              ; no master then also no slave exit not ready
                      
F440 A603                         LDA     3,X                 ; load FLEX disk number
F442 8EDF9D                       LDX     #DDSTAB
F445 E686                         LDB     A,X                 ; load physical disk number
F447 C102                         CMPB    #$02                ; master cf asked ?
F449 2705                         BEQ     RDY                 ; yes all ok
F44B 7DDE7F                       TST     SLVCFOK             ; if master cf not asked then it is slave
F44E 2705                         BEQ     NOTRDY              ; slave present ? no exit not ready
                      
F450 BDF336           RDY         JSR     NVC0Z1              ; no error - clear C - set Z
F453 3592                         PULS    X,A,PC
                      
F455 BDF33A           NOTRDY      JSR     NVZ0C1              ; error - clear Z - set C
F458 3592                         PULS    X,A,PC
                      ;*
                      ;* Detect and init disk typ 2 & 3 CF on 8255 ide port
F45A 3408             INIDT2      PSHS    DP
                      
F45C 8DD3                         BSR     SETDP               ; set DP register
                      
F45E C60E                         LDB     #IDE_LBA3           ; set lba3 for master cf
F460 86E0                         LDA     #LBA3MST
F462 B7DE7D                       STA     LBA3                ; sync ram table
F465 BDF3C8                       JSR     WRT_IDE
                      
F468 CC0000                       LDD     #$0000
F46B FDDE7E                       STD     MSTCFOK             ; clear cf present flags
F46E 108EDE7E                     LDY     #MSTCFOK            ; Y point to master flag
                      
F472 8EFFFE           ILOOP       LDX     #$FFFE              ; prepare for time out
F475 C60F             ILOOP1      LDB     #IDE_STATUS         ; ask status register
F477 BDF3DA                       JSR     READ_IDE
F47A 8580                         BITA    #BSYBIT             ; read busy bit
F47C 2706                         BEQ     MSTOK               ; if clear cf ok
F47E 301F                         LEAX    -1,X                ; countdown
F480 2717                         BEQ     ENDINI              ; time out end cf int (if no master then no slave)
F482 20F1                         BRA     ILOOP1              ; do again
F484 8540             MSTOK       BITA    #RDYBIT             ; must also check ready bit set
F486 2711                         BEQ     ENDINI              ; error set ? yes no cf end init
F488 6CA0                         INC     ,Y+                 ; no set cf flag - Y point to next flag
                      
F48A 108CDE80                     CMPY    #SLVCFOK+1          ; master and slave done ?
F48E 2709                         BEQ     ENDINI              ; yes end of init
                      
F490 C60E                         LDB     #IDE_LBA3           ; set lba3 for slave cf
F492 86F0                         LDA     #LBA3SLV
F494 BDF3C8                       JSR     WRT_IDE
F497 20D9                         BRA     ILOOP               ; do init again for slave cf
                      
F499 C60E             ENDINI      LDB     #IDE_LBA3           ; set lba3 for master cf
F49B 86E0                         LDA     #LBA3MST
F49D BDF3C8                       JSR     WRT_IDE
F4A0 3588                         PULS    DP,PC
                      
                      ;* =====================================================================
                      ;* END OF VARIOUS IDE / 8255 DISK ROUTINES
                      ;* =====================================================================
                      
                      ;*
                      ;*****************************************
                      ;* Disk drivers                          *
                      ;* ------------                          *
                      ;* The system dependant code for the     *
                      ;* disc drivers fits here. Two tables    *
                      ;* must be included. These are DDSTAB a  *
                      ;* four byte table that defines which of *
                      ;* the (up to four) following sets of    *
                      ;* jump tables to use, and TABSRT the    *
                      ;* jump tables themselves. For a full    *
                      ;* description of the floppy drivers see *
                      ;* section 4 (pp9-14) of the general     *
                      ;* FLEX adaptation guide.                *
                      ;*****************************************
                      ;*
                      ;* LIB DISK
                      ;* Read sector routine.
                      ;* Entry: (X) = address where sector is to be placed.
                      ;*        (A) = Track  number.
                      ;*        (B) = Sector number.
                      ;* Exit:  (B) = Error code  (z)=1 if no error.
F4A2 6E9FDFA1         READ    JMP     [REAVEC]
                      ;*
                      ;* Write track routine.
                      ;* Entry: (X) = Address of area of memory from which the data will be taken.
                      ;*        (A) = Track number.
                      ;*        (B) = Sector number.
                      ;* Exit:  (B) = Error condition, (Z)=1 no an error.
F4A6 6E9FDFA3         WRITE   JMP     [WRIVEC]
                      ;*
                      ;* Verify sector routine.
                      ;* Entry: no parameters.
                      ;* Exit:  (B) = Error condition (Z)=1 if no error.
F4AA 6E9FDFA5         VERIFY  JMP     [VERVEC]
                      ;*
                      ;* Restore drive to track 00.
                      ;* Entry: (X) = FCB address (3,X contains drive number).
                      ;* Exit:  (B) = Error condition, (Z)=1 if no error.
F4AE 8D07             RST     BSR     DRV        ; Select drive first.
F4B0 2701                     BEQ     RST1
F4B2 39                       RTS
F4B3 6E9FDFA7         RST1    JMP     [RSTVEC]
                      ;*
                      ;* Select current drive.
                      ;* Entry: (X) = FCB address (3,X contains drive number).
                      ;* Exit:  (B) = Error condition, (Z)=0 and (c)=1 if error.
                      ;*        (B) = $0F if non existant drive.
F4B7 3430             DRV     PSHS    X,Y
F4B9 E603                     LDB     3,X        ; Get driver type.
F4BB 8EDF9D                   LDX     #DDSTAB
F4BE A685                     LDA     B,X
F4C0 81FF                     CMPA    #$FF       ; Is the drive nonexistant?
F4C2 2608                     BNE     DRIVE1
F4C4 3530                     PULS    X,Y
F4C6 C60F                     LDB     #$0F
F4C8 5D                       TSTB
F4C9 1A01                     ORCC    #$01
F4CB 39                       RTS
F4CC C614             DRIVE1  LDB     #20        ; Get correct table start address.
F4CE 3D                       MUL
F4CF 8EF1CA                   LDX     #TABSRT
F4D2 308B                     LEAX    D,X
F4D4 108EDFA1                 LDY     #REAVEC    ; Copy table into ram.
F4D8 C614                     LDB     #20
F4DA A680             DRIVE2  LDA     ,X+
F4DC A7A0                     STA     ,Y+
F4DE 5A                       DECB
F4DF 26F9                     BNE     DRIVE2
F4E1 3530                     PULS    X,Y
F4E3 6E9FDFA9                 JMP     [DRVVEC]
                      ;*
                      ;* Check for drive ready.
                      ;* Entry: (X) = FCB address (3,X contains drive number)>
                      ;* Exit:  (B) = Error condition, (Z)=0 AND (C)=1 if drive is not ready.
F4E7 6E9FDFAB         CHKRDY  JMP     [CHKVEC]
                      ;*
                      ;* Quick drive ready check.
                      ;* Entry: (X) = FCB address (3,X contains drive number).
                      ;* Exit:  (B) = Error condition, (Z)=0 AND (c)=1 if drive not ready.
F4EB 6E9FDFAD         QUICK   JMP     [QUIVEC]
                      ;*
                      ;* Init (cold start).
                      ;* Entry: no parameters.
                      ;* Exit: no change.
F4EF 4F               DINIT   CLRA
F4F0 B7DF8E           DINIT1  STA     DRIVE      ; Init each valid drive in turn.
F4F3 8EDF8B                   LDX     #(DRIVE-3)
F4F6 8DBF                     BSR     DRV
F4F8 2504                     BCS     DINIT2
F4FA AD9FDFAF                 JSR     [INIVEC]
F4FE B6DF8E           DINIT2  LDA     DRIVE
F501 4C                       INCA
F502 8103                     CMPA    #3
F504 26EA                     BNE     DINIT1
F506 39                       RTS
                      ;*
                      ;* Warm start.
                      ;* Entry: no parameters.
                      ;* Exit: no change.
F507 6E9FDFB1         WARM    JMP     [WARVEC]
                      ;*
                      ;* Seek track.
                      ;* Entry: (A) = Track number.
                      ;*        (B) = Sector number.
                      ;* Exit:  (B) = Error condition, (Z)=1 if no error.
F50B 6E9FDFB3         SEEK    JMP     [SEEVEC]
                      ;*
                      ;*******************************
                      ;* Common monitor subroutines. *
                      ;*******************************
                      ;*
                      ;* Print a CR followed by a LF.
                      ;* Entry: no parameters.
                      ;* Exit: (A) destroyed.
F50F 0A0D04           CRLFS   FCB     $0A,$0D,4
F512 3410             PCRLF   PSHS    X
F514 8EF50F                   LDX     #CRLFS     ; Get CR,LF string,
F517 8D05                     BSR     PDATA1     ; and print it.
F519 3590                     PULS    X,PC
                      ;*
                      ;* Print character string .
                      ;* Entry: (X) = Pointer to character string.
                      ;* Exit:  (X) = Pointer to end of string token Hex(04).
                      ;*        (A)   Destroyed.
F51B BDF16E           P       JSR     OUTCH      ; Print char.
F51E A680             PDATA1  LDA     ,X+        ; Get character pointed to by X.
F520 8104                     CMPA    #$04       ; End of string token?
F522 26F7                     BNE     P          ; If not then print char.
F524 39                       RTS
                      ;*
                      ;* Print character string preceded by a CR,LF.
                      ;* Entry: (X) = Pointer to character string.
                      ;* Exit:  (X) = Pointer to end of string token Hex(04).
                      ;*        (A) = Destroyed.
F525 8DEB             PSTRNG  BSR     PCRLF
F527 8DF5                     BSR     PDATA1
F529 39                       RTS
                      ;*
                      ;* Print the A reg.
                      ;* Entry :- (A) = Data to be printed.
F52A 3416             PRINTA  PSHS    D,X
F52C B7DF91                   STA     TEMP
F52F 8EDF91                   LDX     #TEMP
F532 8D7F                     BSR     OUT2HS
F534 3596                     PULS    D,X,PC
                      ;*
                      ;* Print the X reg.
                      ;* Entry :- (X) = Data to be printed.
F536 3416             PRINTX  PSHS    D,X
F538 BFDF92                   STX     XTEMP
F53B 8EDF92                   LDX     #XTEMP
F53E 8D71                     BSR     OUT4HS
F540 3596                     PULS    D,X,PC
                      ;*
                      ;* Delay routine.
                      ;* Entry: (X) = Delay time in milli seconds.
                      ;* Exit:  no change.
F542 3436             DELAY   PSHS    D,X,Y
F544 108E0034         DELAY1  LDY     #52 Delay
F548 7DDFF9                   TST     PSPEED
F54B 2704                     BEQ     DELAY2
F54D 108E0068                 LDY     #104       ; Twice delay for 2Mhz.
F551 3D               DELAY2  MUL
F552 313F                     LEAY    -1,Y
F554 26FB                     BNE     DELAY2
F556 301F                     LEAX    -1,X
F558 26EA                     BNE     DELAY1
F55A 35B6                     PULS    D,X,Y,PC
                      ;*
                      ;* Build a four hex digit address.
                      ;* Entry: no parameters.
                      ;* Exit:  (X) = Address.
                      ;*        (A) = Destroyed.
                      ;*        (B) = Destroyed.
F55C 8D09             BADDR   BSR     BYTE       ; Get 1st char.
F55E 1F89                     TFR     A,B
F560 8D05                     BSR     BYTE       ; and next.
F562 1E89                     EXG     A,B
F564 1F01                     TFR     D,X                    Put in X.
F566 39                       RTS
                      ;*
                      ;* Get a two digit hex byte.
                      ;* Entry: no parameters.
                      ;* Exit:  (A) = Byte.
F567 3404             BYTE    PSHS    B
F569 8D21                     BSR     INHEX      ; Get hex digit.
F56B 48                       ASLA
F56C 48                       ASLA               ; Shift to msb.
F56D 48                       ASLA
F56E 48                       ASLA
F56F 1F89                     TFR     A,B        ; Save in B.
F571 8D19                     BSR     INHEX      ; Get next digit.
F573 3404                     PSHS    B
F575 ABE0                     ADDA    ,S+        ; Add together bytes.
F577 3584              PULS B,PC
                      ;*
                      ;* Print left hex digit.
                      ;* Entry: (A) = Byte containing digit.
                      ;* Exit:  (A) = Byte containing shifted digit.
F579 44               OUTHL   LSRA
F57A 44                       LSRA
F57B 44                       LSRA
F57C 44                       LSRA
                      ;*
                      ;* Output right hex digit.
                      ;* Entry: (A) = Byte containing digit.
                      ;* Exit:  (A) = Ascii coded digit.
F57D 840F             OUTHR   ANDA    #$0F       ; Get four bits only.
F57F 8B30                     ADDA    #$30       ; Add ascii zero.
F581 8139                     CMPA    #$39       ; Numeric overflow?
F583 1023FBE7                 LBLS    OUTCH
F587 8B07                     ADDA    #$07       ; Must be hex.
F589 7EF16E                   JMP    OUTCH
                      ;*
                      ;* Input a valid hex character (If not hex then backspace).
                      ;* Entry: no parameters.
                      ;* Exit:  (A) = Valid hex char.
F58C BDF16C           INHEX   JSR     INCH
F58F 8030                     SUBA    #$30       ; Remove ascii bias.
F591 2B0F                     BMI     NOTHEX
F593 8109                     CMPA    #$09       ; Number?
F595 2F0A                     BLE     INHEX1     ; Yes.
F597 8111                     CMPA    #$11       ; Keep testing.
F599 2B07                     BMI     NOTHEX
F59B 8116                     CMPA    #$16
F59D 2E03                     BGT     NOTHEX
F59F 8007                     SUBA    #$07
F5A1 39               INHEX1  RTS
F5A2 8608             NOTHEX  LDA     #$08       ; If not a number
F5A4 BDF16E                   JSR     OUTCH      ; Print a backspace and try again.
F5A7 20E3                     BRA     INHEX
                      ;*
                      ;* Hex print routines.
                      ;* Entry: (X) = Pointer to a one or two byte hex number.
                      ;* Exit:  (A) = Destroyed.
F5A9 A684             OUT2H   LDA     ,X         ;Output two hex chars.
F5AB 8DCC             OUT2HA  BSR     OUTHL
F5AD A680                     LDA     ,X+
F5AF 20CC                     BRA     OUTHR
F5B1 8DF6             OUT4HS  BSR     OUT2H      ; Output 4 hex chars + space.
F5B3 8DF4             OUT2HS  BSR     OUT2H      ; Output 2 hex chars + space.
                      ;*
                      ;* Output a space.
                      ;* Entry: no parameters.
                      ;* Exit   (A) = Destroyed.
F5B5 8620             OUTS    LDA     #" "       ; Output space.
F5B7 7EF16E                   JMP    OUTCH
                      ;*
                      ;* Random number generator.
                      ;* Entry: no parameters.
                      ;* Exit:  (A) = Random number from 0 to 255.
F5BA 3404             RANDOM  PSHS B
F5BC C608                     LDB #8
F5BE B6DF9B           RPT     LDA RNDM+3
F5C1 48                       ASLA
F5C2 48                       ASLA
F5C3 48                       ASLA
F5C4 B8DF9B                   EORA RNDM+3
F5C7 48                       ASLA
F5C8 48                       ASLA
F5C9 79DF98                   ROL RNDM
F5CC 79DF99                   ROL RNDM+1
F5CF 79DF9A                   ROL RNDM+2
F5D2 79DF9B                   ROL RNDM+3
F5D5 5A                       DECB
F5D6 26E6                     BNE RPT
F5D8 B6DF98                   LDA RNDM
F5DB 3584                     PULS B,PC
                      ;*
                      ;**************************************
                      ;* Extra system subroutines fit here. *
                      ;**************************************
                      ;* LIB SUBS
                      ;*
                      ;* Get Time string from RTC
F5DD 3416             GETTIM  PSHS    X,D
F5DF C60A                     LDB     #$0A
F5E1 8D07             GTIM2   BSR     GETRTC
F5E3 A780                     STA     ,X+
F5E5 5A                       DECB
F5E6 26F9                     BNE     GTIM2
F5E8 3596                     PULS    PC,X,D
                      ;* Get a byte from RTC
F5EA 860A             GETRTC  LDA     #$0A
F5EC B7FF18                   STA     RTC
F5EF B6FF19                   LDA     RTC+1
F5F2 2BF6                     BMI     GETRTC
F5F4 F7FF18                   STB     RTC
F5F7 B6FF19                   LDA     RTC+1
F5FA 39                       RTS
                      ;* Put time string to RTC
F5FB 3416             PUTTIM  PSHS    X,D
F5FD C60A                     LDB     #$0A
F5FF A680             PTIM2   LDA     ,X+
F601 8D05                     BSR     PUTRTC
F603 5A                       DECB
F604 26F9                     BNE     PTIM2
F606 3596                     PULS    PC,X,D
                      ;* Put a byte to RTC
F608 3402             PUTRTC  PSHS    A
F60A 860A             PRTC2   LDA     #$0A
F60C B7FF18                   STA     RTC
F60F B6FF19                   LDA     RTC+1
F612 2BF6                     BMI     PRTC2
F614 F7FF18                   STB     RTC
F617 3502                     PULS    A
F619 B7FF19                   STA     RTC+1
F61C 39                       RTS
                      ;* Sound a tone
F61D 3412             BEEP    PSHS    X,A
F61F B6FF02                   LDA     SYSREG
F622 8A08                     ORA     #$08
F624 B7FF02                   STA     SYSREG
F627 8E0064                   LDX     #$0064
F62A BDF542                   JSR     DELAY
F62D B6FF02                   LDA     SYSREG
F630 84F7                     ANDA    #$F7
F632 B7FF02                   STA     SYSREG
F635 3592                     PULS    PC,X,A
                      ;* Enter from monitor JF cmd. on entry X=CD00 or CD03
F637 B6FF02           MAPOUT  LDA     SYSREG
F63A 84FB                     ANDA    #$FB
F63C B7FF02                   STA     SYSREG
F63F 6E84                     JMP     ,X
                      
                      ;*************************************
                      ;* Graphic functions for the NEC7220A
                      ;*************************************
                      ;*
                      ;* Send a command to GDC
F641 4D               GCOM    TSTA               ; reset ?
F642 270B                     BEQ     GCOM2      ; yes, send at once
F644 3402                     PSHS    A          ; else, savec cmd
F646 B6FF14           GCOM1   LDA     GDC        ; get status
F649 8504                     BITA    #$04       ; FIFO empty ?
F64B 27F9                     BEQ     GCOM1      ; no, wait
F64D 3502                     PULS    A          ; recover command
F64F B7FF15           GCOM2   STA     GDC+1      ; send it
F652 39                       RTS
                      ;*
                      ;* Send a parameter to GDC
                      ;*
F653 3402             GPRM    PSHS    A          ; store parameter
F655 B6FF14           GPRM2   LDA     GDC        ; wait until FIFO empty
F658 8504                     BITA    #$04
F65A 27F9                     BEQ     GPRM2
F65C 3502                     PULS    A
F65E B7FF14                   STA     GDC        ; send parameter
F661 39                       RTS
                      ;*
                      ;* Get a parameter from GDC
                      ;*
F662 B6FF14           GPRMI   LDA     GDC        ; get status
F665 8501                     BITA    #$01       ; data ready ?
F667 27F9                     BEQ     GPRMI      ; no, wait
F669 B6FF15                   LDA     GDC+1      ; read FIFO
F66C 39                       RTS
                      ;*
                      ;* Load the mask register
                      ;*
F66D 3406             MASK    PSHS    D
F66F 864A                     LDA     #$4A       ; send 'mask' command
F671 8DCE                     BSR     GCOM
F673 1F10                     TFR     X,D        ; get mask bytes
F675 1E89                     EXG     A,B        ; reverse for FIFO
F677 8DDA                     BSR     GPRM       ; send 2nd
F679 1E89                     EXG     A,B
F67B 8DD6                     BSR     GPRM       ; send 1st
F67D 3586                     PULS    PC,D
                      ;*
                      ;* Define drawing mode
                      ;*
F67F 3416             SETPEN  PSHS    X,D
F681 8403                     ANDA    #$03       ; setup 'w.data' cmd
F683 8A20                     ORA     #$20
F685 8DBA                     BSR     GCOM       ; send it
F687 1F10                     TFR     X,D        ; get profile word
F689 F7DFC4                   STB     MDFC4      ; save it
F68C B7DFC3                   STA     GPARAM
F68F 8EDFBD                   LDX     #PART1+2
F692 8D02                     BSR     SETPAT
F694 3596                     PULS    PC,X,D
                      ;*
                      ;* Define graphics pattern
                      ;*
F696 3416             SETPAT  PSHS    X,D
F698 8678                     LDA     #$78       ; 'pram' cmd starting
F69A 8DA5                     BSR     GCOM       ; with param.No.8
F69C C608                     LDB     #$08       ; load 8 parameters,
F69E 3008                     LEAX    $08,X      ; taken from ram
F6A0 A682             SETP2   LDA     ,-X        ; pointed to by X,
F6A2 8DAF                     BSR     GPRM       ; in reverse order (FIFO)
F6A4 5A                       DECB
F6A5 26F9                     BNE     SETP2
F6A7 3596                     PULS    PC,X,D
                      ;*
                      ;* Start figure drawing
                      ;*
F6A9 3416             FIGSF   PSHS    X,D
F6AB 864C                     LDA     #$4C       ; 'figs' command
F6AD 8D92                     BSR     GCOM       ; Load [B] drawing parameters
F6AF 8EDFCD                   LDX     #GFIGS     ; from scratch ram to GDCRAM
F6B2 A684                     LDA     ,X         ; NB. All 2-byte parameters are
F6B4 8D9D                     BSR     GPRM       ; loaded low byte first to
F6B6 5A                       DECB               ; maintain Fifo stack.
F6B7 270E                     BEQ     FIGS3
F6B9 A602             FIGS2   LDA     $02,X
F6BB 8D96                     BSR     GPRM
F6BD A601                     LDA     $01,X
F6BF 3002                     LEAX    $02,X
F6C1 8D90                     BSR     GPRM
F6C3 5A                       DECB
F6C4 5A                       DECB
F6C5 26F2                     BNE     FIGS2
                      ; Load the GDCRAM into the drawing processor & draw.
F6C7 866C             FIGS3   LDA     #$6C       ; 'figd' command
F6C9 17FF75                   LBSR    GCOM
F6CC 3596                     PULS    PC,X,D
                      ;*
                      ;* Start graphics drawing
                      ;*
F6CE 3416             FIGSG   PSHS    X,D        ; Load [B] drawing parameters
F6D0 864C                     LDA     #$4C       ; from scratch ram to GDCRAM
F6D2 17FF6C                   LBSR    GCOM       ; NB. All 2-byte parameters are
F6D5 8EDFCD                   LDX     #GFIGS     ; loaded low byte first to
F6D8 A684                     LDA     ,X         ; maintain Fifo stack.
F6DA 17FF76                   LBSR    GPRM
F6DD 5A                       DECB
F6DE 2710                     BEQ     FIGG3
F6E0 A602             FIGG2   LDA     $02,X
F6E2 17FF6E                   LBSR    GPRM
F6E5 A601                     LDA     $01,X
F6E7 3002                     LEAX    $02,X
F6E9 17FF67                   LBSR    GPRM
F6EC 5A                       DECB
F6ED 5A                       DECB
F6EE 26F0                     BNE     FIGG2
F6F0 8668             FIGG3   LDA     #$68       ; 'gchrd' command
F6F2 17FF4C                   LBSR    GCOM       ; Fill area to pattern stored in GDCRAM
F6F5 3596                     PULS    PC,X,D     ; (ie. Draw graphics character)
                      ;*
                      ;* Define display partitions. On entry,
                      ;*     X=Pt.1 start
                      ;*     D=Pt.2 start
                      ;*     Y=Pt.1 length
                      ;*     U=Pt.2 length
                      ;*
F6F7 3476             SETPAR  PSHS    U,Y,X,D
F6F9 1E89                     EXG     A,B
F6FB FDDFBF                   STD     PART2
F6FE 1F10                     TFR     X,D
F700 1E89                     EXG     A,B
F702 FDDFBB                   STD     PART1
F705 1F20                     TFR     Y,D
F707 C40F                     ANDB    #$0F       ; mask off Hi nibble
F709 8610                     LDA     #$10       ; shift into Hi nibble to
F70B 3D                       MUL                ; form Lo field of length
F70C F7DFBD                   STB     PART1+2
F70F 1F20                     TFR     Y,D        ; recover length
F711 44                       LSRA               ; shove the last 4 bits overboard
F712 56                       RORB               ; (we have already dealt with these)
F713 44                       LSRA
F714 56                       RORB
F715 44                       LSRA
F716 56                       RORB
F717 44                       LSRA
F718 56                       RORB               ; use the remaining bits as
F719 F7DFBE                   STB     PART1+3    ; Hi field of length
F71C 1F30                     TFR     U,D        ; get Pt.2 length & treat as above
F71E C40F                     ANDB    #$0F
F720 8610                     LDA     #$10
F722 3D                       MUL
F723 F7DFC1                   STB     PART2+2
F726 1F30                     TFR     U,D
F728 44                       LSRA
F729 56                       RORB
F72A 44                       LSRA
F72B 56                       RORB
F72C 44                       LSRA
F72D 56                       RORB
F72E 44                       LSRA
F72F 56                       RORB
F730 F7DFC2                   STB     PART2+3
F733 8D14                     BSR     VSYNC      ; wait for sync
F735 8670                     LDA     #$70       ; 'pram' cmd.
F737 17FF07                   LBSR    GCOM
F73A 8EDFBB                   LDX     #PART1     ; transfer 8 params
F73D C608                     LDB     #$08       ; from scratch to GDC
F73F A680             SPRM2   LDA     ,X+
F741 17FF0F                   LBSR    GPRM
F744 5A                       DECB
F745 26F8                     BNE     SPRM2
F747 35F6                     PULS    PC,U,Y,X,D
                      ;*
                      ;* Sync to vertical blanking
                      ;*
F749 3402             VSYNC   PSHS    A
F74B B6FF14           VSYN2   LDA     GDC
F74E 8520                     BITA    #$20
F750 26F9                     BNE     VSYN2
F752 B6FF14           VSYN3   LDA     GDC
F755 8520                     BITA    #$20
F757 27F9                     BEQ     VSYN3
F759 3582                     PULS    PC,A
                      ;*
                      ;* Set graphics cursor
                      ;*
F75B 3436             SETCRG  PSHS    Y,X,D
F75D BFDFB7                   STX     XCOORD
F760 10BFDFB9                 STY     YCOORD
F764 8649                     LDA     #$49       ; 'curs' cmd
F766 17FED8                   LBSR    GCOM
F769 1F20                     TFR     Y,D
F76B 58                       ASLB               ; mult Y-coord by 48
F76C 49                       ROLA               ; to yield number of
F76D 58                       ASLB               ; words,(16 bit), in
F76E 49                       ROLA               ; previous lines
F76F 58                       ASLB
F770 49                       ROLA
F771 58                       ASLB
F772 49                       ROLA
F773 1F02                     TFR     D,Y
F775 58                       ASLB
F776 49                       ROLA
F777 31AB                     LEAY    D,Y
F779 1F10                     TFR     X,D
F77B 44                       LSRA               ; divide X-coord by 16
F77C 56                       RORB               ; to yield number of
F77D 44                       LSRA               ; complete words on
F77E 56                       RORB               ; this line.Add addr
F77F 44                       LSRA               ; of 1st word in
F780 56                       RORB               ; Partition,to get
F781 44                       LSRA               ; addr of current word
F782 56                       RORB
F783 31AB                     LEAY    D,Y
F785 31A95E00                 LEAY    $5E00,Y
F789 58                       ASLB               ; recover X-coord but
F78A 49                       ROLA               ; with l.s. nibble
F78B 58                       ASLB               ; set to 0. Subtract
F78C 49                       ROLA               ; to yield number of
F78D 58                       ASLB               ; bits in current word
F78E 49                       ROLA
F78F 58                       ASLB
F790 49                       ROLA
F791 43                       COMA
F792 53                       COMB
F793 C30001                   ADDD    #$0001
F796 308B                     LEAX    D,X
F798 1F20                     TFR     Y,D        ; format to suit GDC
F79A 1E89                     EXG     A,B        ; parameter ram and
F79C 17FEB4                   LBSR    GPRM       ; load parameters
F79F 1E89                     EXG     A,B
F7A1 17FEAF                   LBSR    GPRM
F7A4 1F10                     TFR     X,D
F7A6 8610                     LDA     #$10
F7A8 3D                       MUL
F7A9 C4F0                     ANDB    #$F0
F7AB 1F98                     TFR     B,A
F7AD 17FEA3                   LBSR    GPRM
F7B0 35B6                     PULS    PC,Y,X,D
                      ;*
                      ;* Get graphics cursor
                      ;*
F7B2 3406             GETCRG  PSHS    D
F7B4 86E0                     LDA     #$E0       ; 'curd' cmd
F7B6 17FE88                   LBSR    GCOM
F7B9 17FEA6                   LBSR    GPRMI      ; get cursor word adr
F7BC 1F89                     TFR     A,B
F7BE 17FEA1                   LBSR    GPRMI
F7C1 108E0000                 LDY     #$0000     ; zero line count
F7C5 835E00                   SUBD    #$5E00     ; convert to word #
F7C8 830030           GCRG1   SUBD    #$0030     ; count lines
F7CB 2B04                     BMI     GCRG2
F7CD 3121                     LEAY    $01,Y
F7CF 20F7                     BRA     GCRG1
F7D1 C30030           GCRG2   ADDD    #$0030
F7D4 58                       ASLB               ; convert 'words on
F7D5 49                       ROLA               ; current line' to
F7D6 58                       ASLB               ; 'bits on current line'
F7D7 49                       ROLA
F7D8 58                       ASLB
F7D9 49                       ROLA
F7DA 58                       ASLB
F7DB 49                       ROLA
F7DC 1F01                     TFR     D,X        ; save in X
F7DE 17FE81                   LBSR    GPRMI      ; Hi adr.bits.Discard
F7E1 17FE7E                   LBSR    GPRMI      ; get dot addr
F7E4 1F89                     TFR     A,B        ; (in 1 of 16 form)
F7E6 17FE79                   LBSR    GPRMI
F7E9 1CFE                     ANDCC   #$FE       ; clear carry
F7EB 44               GCRG3   LSRA               ; count buckshee bits and
F7EC 56                       RORB               ; increment X accordingly
F7ED 2504                     BCS     GCRG4
F7EF 3001                     LEAX    $01,X
F7F1 20F8                     BRA     GCRG3
F7F3 BFDFB7           GCRG4   STX     XCOORD     ; store coordinates
F7F6 10BFDFB9                 STY     YCOORD
F7FA 3586                     PULS    PC,D
                      ;*
                      ;* Turn display off
                      ;*
F7FC 3402             OFF     PSHS    A
F7FE BDF749                   JSR     VSYNC
F801 860C                     LDA     #$0C
F803 17FE3B                   LBSR    GCOM
F806 3582                     PULS    PC,A
                      ;*
                      ;* Turn display on
                      ;*
F808 3402             ON      PSHS    A
F80A BDF749                   JSR     VSYNC
F80D 860D                     LDA     #$0D
F80F 17FE2F                   LBSR    GCOM
F812 3582                     PULS    PC,A
                      ;*
                      ;* Set display to graphics
                      ;*
F814 3476             GRAPH   PSHS    U,Y,X,D
F816 5F                       CLRB
F817 8D16                     BSR     MODE
F819 8A09                     ORA     #$09
F81B 5A                       DECB
F81C 8D11                     BSR     MODE       ; set interlaced
F81E 8E5E00                   LDX     #$5E00     ; set Partitions
F821 108E0240                 LDY     #$0240
F825 CC0000                   LDD     #$0000
F828 1F03                     TFR     D,U
F82A BDF6F7                   JSR     SETPAR
F82D 35F6                     PULS    PC,U,Y,X,D
                      ;*
                      ;* Set GDC mode
                      ;*
F82F 5D               MODE    TSTB
F830 2710                     BEQ     MODE1
F832 B7DFCB                   STA     GMODE
F835 3402                     PSHS    A
F837 860F                     LDA     #$0F       ; 'sync' mode
F839 17FE05                   LBSR    GCOM
F83C 3502                     PULS    A
F83E 17FE12                   LBSR    GPRM
F841 39                       RTS
F842 B6DFCB           MODE1   LDA     GMODE
F845 39                       RTS
                      ;*
                      ;* Set zoom factor
                      ;*
F846 5D               ZOOM    TSTB
F847 2710                     BEQ     ZOOM1
F849 B7DFCC                   STA     GZOOM
F84C 3402                     PSHS    A
F84E 8646                     LDA     #$46       ; 'zoom'command
F850 17FDEE                   LBSR    GCOM
F853 3502                     PULS    A
F855 17FDFB                   LBSR    GPRM
F858 39                       RTS
F859 B6DFCC           ZOOM1   LDA     GZOOM
F85C 39                       RTS
                      ;*
                      ;* Area fill (On entry, A holds init dir)
                      ;*
F85D 3436             FILL    PSHS    Y,X,D
F85F 8487                     ANDA    #$87       ; set 'figs' P1 for graphics char
F861 8A10                     ORA     #$10
F863 B7DFCD                   STA     GFIGS
F866 313F                     LEAY    -$01,Y     ; DN=(No.of pixels at
F868 1F20                     TFR     Y,D        ; Rt.Angles to initial
F86A FDDFCE                   STD     DN         ; direction - 1)
F86D 1F10                     TFR     X,D        ; D0 & D2=(No.of pixels
F86F FDDFD0                   STD     D0         ; in initial direction)
F872 FDDFD2                   STD     D2
F875 C607                     LDB     #$07       ; load 7 bytes from
F877 17FE54                   LBSR    FIGSG      ; scratch,then draw
F87A 35B6                     PULS    PC,Y,X,D
                      ;*
                      ;* Clear graphics display
                      ;*
F87C 3436             CLEAR   PSHS    Y,X,D
F87E 8E0000                   LDX     #$0000     ; set cursor 0,0
F881 1F12                     TFR     X,Y
F883 BDF75B                   JSR     SETCRG
F886 8E4000                   LDX     #$4000     ; (DN max=$3FFF)
F889 8602                     LDA     #$02       ; pen type 'reset'
F88B 8D11                     BSR     CLEARX     ; clear this block
F88D 8E2C30                   LDX     #$2C30     ; now do rest
F890 8602                     LDA     #$02
F892 8D0A                     BSR     CLEARX
F894 8E0000                   LDX     #$0000     ; and reset cursor to 0,0
F897 1F12                     TFR     X,Y
F899 BDF75B                   JSR     SETCRG
F89C 35B6                     PULS    PC,Y,X,D
                      ;*
                      ;* Clear (Xreg) words of display memory
                      ;*
F89E 3412             CLEARX  PSHS    X,A
F8A0 3402                     PSHS    A
F8A2 301F                     LEAX    -$01,X     ; (DN=W-1)
F8A4 3410                     PSHS    X
F8A6 8EFFFF                   LDX     #$FFFF     ; enable all bits
F8A9 BDF66D                   JSR     MASK
F8AC 864C                     LDA     #$4C       ; 'figs' command
F8AE 17FD90                   LBSR    GCOM
F8B1 8602                     LDA     #$02       ; P1.wdata mode,dir 2
F8B3 17FD9D                   LBSR    GPRM
F8B6 3506                     PULS    D
F8B8 1E89                     EXG     A,B
F8BA 17FD96                   LBSR    GPRM       ; P2.DN-low
F8BD 1E89                     EXG     A,B
F8BF 17FD91                   LBSR    GPRM       ; P3.DN-hi
F8C2 3502                     PULS    A          ; (pen type 02)
F8C4 8A20                     ORA     #$20       ; 'wdat' command
F8C6 17FD78                   LBSR    GCOM
F8C9 86FF                     LDA     #$FF
F8CB 17FD85                   LBSR    GPRM       ; data word all 1's
F8CE 17FD82                   LBSR    GPRM
F8D1 3592                     PULS    PC,X,A
                      ;*
                      ;* Initialise GDC
                      ;*
F8D3 3416             GDCINI  PSHS    X,D
F8D5 4F                       CLRA
F8D6 17FD68                   LBSR    GCOM       ; 'reset' command
F8D9 C621                     LDB     #$21
F8DB BDF5EA           GDCI2   JSR     GETRTC     ; Load parameter ram from RTC
F8DE BDF653                   JSR     GPRM
F8E1 5C                       INCB
F8E2 C129                     CMPB    #$29
F8E4 26F5                     BNE     GDCI2
F8E6 866F                     LDA     #$6F       ; 'vsync' command
F8E8 17FD56                   LBSR    GCOM
F8EB 8647                     LDA     #$47       ; 'pitch' command
F8ED 17FD51                   LBSR    GCOM
F8F0 8630                     LDA     #$30
F8F2 17FD5E                   LBSR    GPRM
F8F5 864B                     LDA     #$4B       ; 'cchar' command
F8F7 17FD47                   LBSR    GCOM
F8FA 4F                       CLRA
F8FB 17FD55                   LBSR    GPRM
F8FE 86C0                     LDA     #$C0
F900 17FD50                   LBSR    GPRM
F903 4F                       CLRA
F904 17FD4C                   LBSR    GPRM
F907 C601                     LDB     #$01
F909 4F                       CLRA
F90A 17FF39                   LBSR    ZOOM
F90D 861F                     LDA     #$1F
F90F B7DFCB                   STA     GMODE
F912 866B                     LDA     #$6B       ; 'start' command
F914 17FD2A                   LBSR    GCOM
F917 BDFAC2                   JSR     CLEART
F91A BDFAA4                   JSR     TEXT
F91D 3596                     PULS    PC,X,D
                      ;*
                      ;* Plot a point
                      ;*
F91F 3404             POINT   PSHS    B
F921 7FDFCD                   CLR     GFIGS
F924 C601                     LDB     #$01
F926 17FD80                   LBSR    FIGSF
F929 3584                     PULS    PC,B
                      ;*
                      ;* Plot a line
                      ;*
F92B 3456             LINE    PSHS    U,X,D
F92D CEF9A3                   LDU     #P1TBL     ; base adr.of P1 table
F930 1F10                     TFR     X,D        ; calc X' (delta X)
F932 B3DFB7                   SUBD    XCOORD
F935 10830000                 CMPD    #$0000
F939 2E07                     BGT     LINE1      ; branch if X'>0
F93B 3344                     LEAU    $04,U      ; else,reverse dir &
F93D 43                       COMA               ; change sign of X'
F93E 53                       COMB
F93F C30001                   ADDD    #$0001
F942 1F01             LINE1   TFR     D,X        ; X=|X'|
F944 1F20                     TFR     Y,D        ; repeat for Y-axis
F946 B3DFB9                   SUBD    YCOORD
F949 10830000                 CMPD    #$0000
F94D 2E07                     BGT     LINE2
F94F 3342                     LEAU    $02,U
F951 43                       COMA
F952 53                       COMB
F953 C30001                   ADDD    #$0001
F956 FDDF94           LINE2   STD     YTEMP
F959 BFDF92                   STX     XTEMP
F95C BCDF94                   CMPX    YTEMP
F95F 2E08                     BGT     LINE3
F961 3341                     LEAU    $01,U
F963 BFDF94                   STX     YTEMP
F966 FDDF92                   STD     XTEMP
                      ;* At this point,XTEMP=delta large,YTEMP=delta small
F969 A6C4             LINE3   LDA     ,U         ; get P1
F96B B7DFCD                   STA     GFIGS      ; put it in scratch
F96E FCDF94                   LDD     YTEMP      ; calc ---
F971 B3DF92                   SUBD    XTEMP      ; 2(delta min - delta max)
F974 58                       ASLB
F975 49                       ROLA
F976 843F                     ANDA    #$3F       ; NOT > 63
F978 FDDFD2                   STD     D2         ; store it
F97B FCDF94                   LDD     YTEMP
F97E 58                       ASLB
F97F 49                       ROLA
F980 FDDFD4                   STD     D4         ; = 2(delta min)
F983 B3DF92                   SUBD    XTEMP      ; 2xdelta min-delta max
F986 843F                     ANDA    #$3F       ; NOT > 63
F988 FDDFD0                   STD     D0         ; store it
F98B FCDF92                   LDD     XTEMP
F98E FDDFCE                   STD     DN         ; = delta max
F991 C609                     LDB     #$09       ; load 9 params & draw line
F993 17FD13                   LBSR    FIGSF
F996 3556                     PULS    U,X,D
F998 BFDFB7                   STX     XCOORD     ; recover new coordinates
F99B 10BFDFB9                 STY     YCOORD     ; and update cursor
F99F 17FDB9                   LBSR    SETCRG
F9A2 39                       RTS
                      ;*
                      ;* 'figs' P1 table. (Select initial direction)
                      ;*                1   0   2   3   6   7   5   4
F9A3 09080A0B0E0F0D0C P1TBL   FCB     $09,$08,$0A,$0B,$0E,$0F,$0D,$0C
                      ;*
                      ;* Plot a rectangle
                      ;*
F9AB 3436             RECT    PSHS    Y,X,D
F9AD 8407                     ANDA    #$07       ; init.dir. (7 max)
F9AF 8A40                     ORA     #$40       ; set 'rectangle' bit
F9B1 B7DFCD                   STA     GFIGS      ; store as P1 for 'figs'
F9B4 CC0003                   LDD     #$0003     ; sides - 1
F9B7 FDDFCE                   STD     DN
F9BA 301F                     LEAX    -$01,X
F9BC 313F                     LEAY    -$01,Y
F9BE 1F10                     TFR     X,D        ; pix.in init dir. -1
F9C0 FDDFD0                   STD     D0
F9C3 FDDFD6                   STD     DM
F9C6 1F20                     TFR     Y,D        ; pix at Rt.A -1
F9C8 FDDFD2                   STD     D2
F9CB CCFFFF                   LDD     #$FFFF     ; (-1)
F9CE FDDFD4                   STD     D4
F9D1 C60B                     LDB     #$0B       ; load 11 params & draw rectangle
F9D3 17FCD3                   LBSR    FIGSF
F9D6 35B6                     PULS    PC,Y,X,D
                      ;*
                      ;* Plot a circle
                      ;*
F9D8 3436             CIRCLE  PSHS    Y,X,D
F9DA BEDFB7                   LDX     XCOORD     ; get coordinates of
F9DD 10BEDFB9                 LDY     YCOORD     ; centre point
F9E1 BFDF92                   STX     XTEMP      ; save them
F9E4 10BFDF94                 STY     YTEMP
F9E8 3086                     LEAX    A,X        ; add rad to X-coord
F9EA C604                     LDB     #$04       ; dir = 4
F9EC 8D3B                     BSR     ARC        ; 0-45 degrees
F9EE C607                     LDB     #$07       ; dir = 7
F9F0 8D37                     BSR     ARC        ; 0-315 degrees
F9F2 BEDF92                   LDX     XTEMP      ; set X-coord to centre
F9F5 31A6                     LEAY    A,Y        ; add rad to Y-coord
F9F7 C602                     LDB     #$02       ; dir = 2
F9F9 8D2E                     BSR     ARC        ; 270-315 degrees
F9FB C605                     LDB     #$05       ; dir = 5
F9FD 8D2A                     BSR     ARC        ; 270-225 degrees
F9FF 10BEDF94                 LDY     YTEMP      ; set Y-coord to centre
FA03 40                       NEGA
FA04 3086                     LEAX    A,X        ; sub rad from X-coord
FA06 40                       NEGA
FA07 5F                       CLRB
FA08 8D1F                     BSR     ARC        ; 180-225 degrees
FA0A C603                     LDB     #$03       ; dir = 3
FA0C 8D1B                     BSR     ARC        ; 180-135 degrees
FA0E BEDF92                   LDX     XTEMP      ; set X-coord to centre
FA11 40                       NEGA
FA12 31A6                     LEAY    A,Y        ; sub rad from Y-coord
FA14 40                       NEGA
FA15 C601                     LDB     #$01       ; dir = 1
FA17 8D10                     BSR     ARC        ; 90-45 degrees
FA19 C606                     LDB     #$06       ; dir = 6
FA1B 8D0C                     BSR     ARC        ; 90-135 degrees
FA1D BEDF92                   LDX     XTEMP      ; recover coordinates
FA20 10BEDF94                 LDY     YTEMP      ; of centre point &
FA24 17FD34                   LBSR    SETCRG     ; set cursor
FA27 35B6                     PULS    PC,Y,X,D
                      ;*
                      ;* Plot an arc (on entry, A = radius, B = initial direction)
                      ;*
FA29 3406             ARC     PSHS    D
FA2B 17FD2D                   LBSR    SETCRG
FA2E 3406                     PSHS    D
FA30 C6B5                     LDB     #$B5       ; (0.707 X 256)
FA32 3D                       MUL
FA33 B7DFD8                   STA     CONST      ; 256(R X 0.707).[Hi byte]
FA36 3506                     PULS    D
FA38 C407                     ANDB    #$07       ; dir not > 7
FA3A CA20                     ORB     #$20       ; set 'arc' mode
FA3C F7DFCD                   STB     GFIGS
FA3F 4A                       DECA               ; radius - 1
FA40 5F                       CLRB
FA41 B7DFD1                   STA     D1         ; Lo-byte of D = rad-1
FA44 F7DFD0                   STB     D0         ; Hi-byte of D = 0
FA47 1E89                     EXG     A,B
FA49 58                       ASLB
FA4A 49                       ROLA
FA4B FDDFD2                   STD     D2         ; = 2(radius - 1)
FA4E F6DFD8                   LDB     CONST
FA51 4F                       CLRA
FA52 FDDFCE                   STD     DN         ; = R x 0.707
FA55 CCFFFF                   LDD     #$FFFF
FA58 FDDFD4                   STD     D4         ; = -1
FA5B CC0000                   LDD     #$0000
FA5E FDDFD6                   STD     DM
FA61 C60B                     LDB     #$0B       ; load 11 params & draw arc
FA63 17FC43                   LBSR    FIGSF
FA66 3586                     PULS    PC,D
                      ;*
                      ;* Set text cursor
                      ;*
FA68 3416             SETCRT  PSHS    X,D
FA6A BFDFE5                   STX     CURSOR
FA6D 8649                     LDA     #$49       ; 'curs' command
FA6F 17FBCF                   LBSR    GCOM
FA72 1F10                     TFR     X,D
FA74 1E89                     EXG     A,B
FA76 17FBDA                   LBSR    GPRM       ; P1/2=cursor word
FA79 1E89                     EXG     A,B        ; adr. Lo/Hi
FA7B 17FBD5                   LBSR    GPRM
FA7E 8608                     LDA     #$08
FA80 17FBD0                   LBSR    GPRM
FA83 3596                     PULS    PC,X,D
                      ;*
                      ;* Get text cursor
                      ;*
FA85 3406             GETCRT  PSHS    D
FA87 86E0                     LDA     #$E0       ; 'curd' command
FA89 17FBB5                   LBSR    GCOM
FA8C 17FBD3                   LBSR    GPRMI      ; P1=word adr. Lo
FA8F 1F89                     TFR     A,B
FA91 17FBCE                   LBSR    GPRMI      ; P2=word adr. Hi
FA94 1F01                     TFR     D,X
FA96 BFDFE5                   STX     CURSOR     ; curs.word adr
FA99 17FBC6                   LBSR    GPRMI      ; P3=adr.Hi(not used)
FA9C 17FBC3                   LBSR    GPRMI      ; P4/5=dot adr.Lo/Hi not
FA9F 17FBC0                   LBSR    GPRMI      ; used in text mode,discard
FAA2 3586                     PULS    PC,D
                      ;*
                      ;* Set display to text
                      ;*
FAA4 3476             TEXT    PSHS    U,Y,X,D
FAA6 5F                       CLRB
FAA7 17FD85                   LBSR    MODE       ; get mode
FAAA 84F6                     ANDA    #$F6
FAAC 5C                       INCB
FAAD 17FD7F                   LBSR    MODE       ; set noninterlaced
FAB0 BEDFEC                   LDX     TS1        ; get text
FAB3 FCDFEE                   LDD     TS2        ; Partition params
FAB6 10BEDFF0                 LDY     TL1
FABA FEDFF2                   LDU     TL2
FABD BDF6F7                   JSR     SETPAR     ; load them
FAC0 35F6                     PULS    PC,U,Y,X,D
                      ;*
                      ;* Clear text display (Partition data in scratch ram)
                      ;*
FAC2 3416             CLEART  PSHS    X,D
FAC4 8ECA00                   LDX     #TXTRAM    ; point to text ram
FAC7 8D9F                     BSR     SETCRT
FAC9 8E3600                   LDX     #$3600     ; 288 lines X 48 words
FACC 8602                     LDA     #$02
FACE BDF89E                   JSR     CLEARX     ; clear text
FAD1 8D1F                     BSR     INITXT     ; setup initial text
FAD3 7FDFDA                   CLR     COL        ; home cursor
FAD6 7FDFD9                   CLR     ROW
FAD9 7FDFEB                   CLR     ESCFLG
FADC 8601                     LDA     #$01
FADE B7DFEA                   STA     CTYPE      ; solid cursor
FAE1 8604                     LDA     #$04
FAE3 B7DFE1                   STA     ATTRI
FAE6 8DBC                     BSR     TEXT       ; set text mode
FAE8 7DDFFF                   TST     BLANKD     ; cursor blanked ?
FAEB 2702                     BEQ     CLTXT      ; no,skip
FAED 8D5B                     BSR     FLCUR      ; yes,toggle it
FAEF 3596             CLTXT   PULS    PC,X,D
FAF1 39               CLINK   RTS                ; link text parameters
                      ;*
                      ;* Init text mode Partitions
                      ;*
FAF2 8ECA00           INITXT  LDX     #TXTRAM    ; initialise text mode
FAF5 1F10                     TFR     X,D        ; Partition parameters
FAF7 108E0120                 LDY     #$0120
FAFB CE0000                   LDU     #$0000
FAFE BFDFEC           UPDPA   STX     TS1        ; update Partitions
FB01 FDDFEE                   STD     TS2
FB04 10BFDFF0                 STY     TL1
FB08 FFDFF2                   STU     TL2
FB0B 3402                     PSHS    A
FB0D B6DFCB                   LDA     GMODE
FB10 8509                     BITA    #$09       ; if text mode set
FB12 2702                     BEQ     ITRET      ; load these params
FB14 3582                     PULS    PC,A       ; else,return
FB16 3502             ITRET   PULS    A
FB18 BDF6F7                   JSR     SETPAR
FB1B 39                       RTS
                      ;*
                      ;* Send a char to video
                      ;*
FB1C 3476             VIDCH   PSHS    U,Y,X,D
FB1E BDF33F                   JSR     FAST
FB21 7DDFFF                   TST     BLANKD     ; cursor blanked ?
FB24 2702                     BEQ     VIDC1      ; if so,
FB26 8D22                     BSR     FLCUR      ; toggle it
FB28 7DDFEB           VIDC1   TST     ESCFLG     ; set ?
FB2B 2705                     BEQ     VIDC2      ; no, continue
FB2D BDFC6A                   JSR     CMOVE      ; else, deal with it
FB30 2013                     BRA     VIDC3      ; and exit
FB32 8120             VIDC2   CMPA    #$20       ; is it a control chr ?
FB34 257F                     BCS     VIDCC      ; yes,go do it
FB36 847F                     ANDA    #$7F       ; else,make sure its
FB38 8D29                     BSR     GPCHR      ; ascii & do it
FB3A B6DFDA                   LDA     COL
FB3D 4C                       INCA
FB3E 816C                     CMPA    #$6C       ; end of line ?
FB40 2703                     BEQ     VIDC3      ; yes,exit
FB42 B7DFDA                   STA     COL        ; no,update col
FB45 BDF34C           VIDC3   JSR     SLOW
FB48 35F6                     PULS    PC,U,Y,X,D
                      ;*
                      ;* Flashing cursor
                      ;*
FB4A 3476             FLCUR   PSHS    U,Y,X,D
FB4C 7DDFEA                   TST     CTYPE
FB4F 2B10                     BMI     FLC2       ; cursor off,skip
FB51 8601                     LDA     #$01       ; (complement mode)
FB53 BDF67F                   JSR     SETPEN
FB56 B6DFEA                   LDA     CTYPE
FB59 8A80                     ORA     #$80       ; adjust for use as index
FB5B 4A                       DECA               ; to char table
FB5C 8D0D                     BSR     GPCH2      ; toggle cursor
FB5E 73DFFF                   COM     BLANKD     ; toggle 'blanked' flag
FB61 35F6             FLC2    PULS    PC,U,Y,X,D
                      ;*
                      ;* Deal with printable character. (7 bit ascii in ACCA)
                      ;*
FB63 3406             GPCHR   PSHS    D
FB65 4F                       CLRA               ; (replace mode)
FB66 BDF67F                   JSR     SETPEN
FB69 3506                     PULS    D          ; peek & put back
FB6B 3406             GPCH2   PSHS    D
FB6D 8D1C                     BSR     CCT2G      ; adjust coordinates
FB6F 8020                     SUBA    #$20       ; use as index
FB71 8EFD01                   LDX     #CSETB     ; (char set,Normal)
FB74 C605                     LDB     #$05       ; find character
FB76 3D                       MUL
FB77 308B                     LEAX    D,X
FB79 BDF696                   JSR     SETPAT     ; set it up
FB7C B6DFE1                   LDA     ATTRI
FB7F 108E0005                 LDY     #$0005     ; pixels in init dir
FB83 8E0008                   LDX     #$0008     ; pixels at Rt.Angles
FB86 BDF85D                   JSR     FILL       ; and print it
FB89 3586                     PULS    PC,D
                      ;*
                      ;* Convert coordinates,text to graphic
                      ;*
FB8B 3436             CCT2G   PSHS    Y,X,D
FB8D B6DFD9                   LDA     ROW        ; row No
FB90 C60C                     LDB     #$0C       ; lines per row
FB92 3D                       MUL
FB93 F3DFF2                   ADDD    TL2        ; + overwritten lines
FB96 1F02                     TFR     D,Y
FB98 108C0120                 CMPY    #$0120     ; 2nd time round ?
FB9C 2D04                     BLT     CCT2       ; no,skip
FB9E 31A9FEE0                 LEAY    $FEE0,Y    ; yes,-len of T ram
FBA2 31A90248         CCT2    LEAY    $0248,Y    ; +len of G ram
FBA6 B6DFDA                   LDA     COL
FBA9 C607                     LDB     #$07       ; (width of box col)
FBAB 3D                       MUL
FBAC 1F01                     TFR     D,X
FBAE 300C                     LEAX    $0C,X      ; +initial offset
FBB0 BDF75B                   JSR     SETCRG
FBB3 35B6                     PULS    PC,Y,X,D
                      ;*
                      ;* Deal with control character (entered from send chr to video)
                      ;*
FBB5 3416             VIDCC   PSHS    X,D
FBB7 8EFBC1                   LDX     #TCCACT
FBBA 48                       ASLA               ; char X 2 is used
FBBB AD96                     JSR     [A,X]      ; as index to table
FBBD 3516                     PULS    X,D
FBBF 2084                     BRA     VIDC3      ; return to sender
                      ;*
                      ;* Table of control code action routines
                      ;*
FBC1 FC27             TCCACT  FDB     IGNORE
FBC3 FC27                     FDB     IGNORE
FBC5 FC27                     FDB     IGNORE
FBC7 FC27                     FDB     IGNORE
FBC9 FC27                     FDB     IGNORE
FBCB FC27                     FDB     IGNORE
FBCD FC27                     FDB     IGNORE
FBCF F61D                     FDB     BEEP       ; bell
FBD1 FC01                     FDB     CLEFT      ; cursor left
FBD3 FC0B                     FDB     CRIGHT     ; cursor right
FBD5 FC17                     FDB     CDOWN      ; cursor down
FBD7 FC28                     FDB     CUP        ; cursor up
FBD9 FAC2                     FDB     CLEART     ; clear screen
FBDB FC36                     FDB     CCR        ; CR
FBDD FC6A                     FDB     CMOVE      ; cursor move
FBDF FC33                     FDB     CHOME      ; cursor home
FBE1 F808                     FDB     ON         ; screen on
FBE3 F7FC                     FDB     OFF        ; screen off
FBE5 FC43                     FDB     CURON      ; cursor on
FBE7 FC3A                     FDB     CUROFF     ; cursor off
FBE9 FC4C                     FDB     CURSOL     ; cursor solid
FBEB FC52                     FDB     CURBOX     ; cursor box
FBED FC58                     FDB     ATTON      ; attributes on
FBEF FC61                     FDB     ATTOFF     ; attributes off
FBF1 FC27                     FDB     IGNORE     ; (clear to end of line)
FBF3 FC27                     FDB     IGNORE     ; (clear to end of screen)
FBF5 FCD6                     FDB     CLINE      ; clear line
FBF7 FC27                     FDB     IGNORE
FBF9 FC27                     FDB     IGNORE
FBFB FC27                     FDB     IGNORE
FBFD FC27                     FDB     IGNORE
FBFF FC27                     FDB     IGNORE
                      ;*
                      ;* Action routines for control char
                      ;*
                      ;* Cursor left
FC01 B6DFDA           CLEFT   LDA     COL
FC04 4A                       DECA
FC05 2B03                     BMI     CLEF1      ; if fully left, ignore
FC07 B7DFDA                   STA     COL
FC0A 39               CLEF1   RTS
                      ;* Cursor right
FC0B B6DFDA           CRIGHT  LDA     COL
FC0E 4C                       INCA
FC0F 816C                     CMPA    #$6C       ; if fully right, ignore
FC11 2703                     BEQ     CRIG1
FC13 B7DFDA                   STA     COL
FC16 39               CRIG1   RTS
                      ;* Cursor down
FC17 B6DFD9           CDOWN   LDA     ROW
FC1A 4C                       INCA
FC1B 8118                     CMPA    #$18       ; 24? (N.B. rows=0-23)
FC1D 2605                     BNE     CRET
FC1F 8D6B                     BSR     SCRUP      ; scroll up
FC21 7EFCD6                   JMP     CLINE      ; clear line.(Btm)
FC24 B7DFD9           CRET    STA     ROW
                      ;* Control char ignored
FC27 39               IGNORE  RTS                ; no action
                      ;* Cursor up
FC28 B6DFD9           CUP     LDA     ROW
FC2B 4A                       DECA
FC2C 2AF6                     BPL     CRET
FC2E 8D79                     BSR     SCRDWN     ; scroll down
FC30 7EFCD6                   JMP     CLINE      ; clear line.(Top)
                      ;* Cursor home (top-left)
FC33 7FDFD9           CHOME   CLR     ROW
                      ;* CR (cursor begin of line)
FC36 7FDFDA           CCR     CLR     COL
FC39 39                       RTS
                      ;* Cursor off
FC3A B6DFEA           CUROFF  LDA     CTYPE
FC3D 8A80                     ORA     #$80
FC3F B7DFEA                   STA     CTYPE
FC42 39                       RTS
                      ;* Cursor on
FC43 B6DFEA           CURON   LDA     CTYPE
FC46 847F                     ANDA    #$7F
FC48 B7DFEA                   STA     CTYPE
FC4B 39                       RTS
                      ;* Solid cursor
FC4C 8601             CURSOL  LDA     #$01
FC4E B7DFEA                   STA     CTYPE
FC51 39                       RTS
                      ;* Box cursor
FC52 8602             CURBOX  LDA     #$02
FC54 B7DFEA                   STA     CTYPE
FC57 39                       RTS
                      ;* Attributes on
FC58 B6DFE1           ATTON   LDA     ATTRI
FC5B 8A81                     ORA     #$81
FC5D B7DFE1                   STA     ATTRI
FC60 39                       RTS
                      ;* Attributes off
FC61 B6DFE1           ATTOFF  LDA     ATTRI
FC64 847E                     ANDA    #$7E
FC66 B7DFE1                   STA     ATTRI
FC69 39                       RTS
                      ;*
                      ;* Move cursor (3 pass escape sequence)
                      ;*
FC6A F6DFEB           CMOVE   LDB     ESCFLG
FC6D 5D                       TSTB               ; is it set ?
FC6E 2606                     BNE     CMOV1      ; yes,branch
FC70 C602                     LDB     #$02       ; no,set it
FC72 F7DFEB                   STB     ESCFLG
FC75 39                       RTS
FC76 C102             CMOV1   CMPB    #$02       ; is it 2 ?
FC78 2609                     BNE     CMOV2      ; no,branch
FC7A 8020                     SUBA    #$20       ; yes,update row
FC7C B7DFD9                   STA     ROW
FC7F 7ADFEB                   DEC     ESCFLG
FC82 39                       RTS
FC83 8020             CMOV2   SUBA    #$20       ; update col and
FC85 B7DFDA                   STA     COL
FC88 7ADFEB                   DEC     ESCFLG     ; clear flag
FC8B 39                       RTS
                      ;*
                      ;* Scroll up
FC8C 10BEDFF0         SCRUP   LDY     TL1        ; reduce TL1 by one row
FC90 3134                     LEAY    -$0C,Y
FC92 2603                     BNE     SCRUP1
FC94 16FE5B                   LBRA    INITXT     ; init Part.params
FC97 FCDFEE           SCRUP1  LDD     TS2
FC9A BEDFEC                   LDX     TS1
FC9D 30890240                 LEAX    $0240,X    ; 12 lines X 48 words
FCA1 FEDFF2                   LDU     TL2        ; (ie. advance 1 row)
FCA4 334C                     LEAU    $0C,U      ; increment TL2 by one row
FCA6 16FE55                   LBRA    UPDPA      ; update Part.params
                      ;*
                      ;* Scroll down
FCA9 FEDFF2           SCRDWN  LDU     TL2        ; if zero,apply
FCAC 2718                     BEQ     SCRD1      ; cooking factor
FCAE BEDFEC                   LDX     TS1
FCB1 3089FDC0                 LEAX    -$0240,X   ; retreat one row
FCB5 FCDFEE                   LDD     TS2
FCB8 10BEDFF0                 LDY     TL1        ; increase TL1 by one row
FCBC 312C                     LEAY    $0C,Y
FCBE FEDFF2                   LDU     TL2        ; reduce TL2 by one row
FCC1 3354                     LEAU    -$0C,U
FCC3 16FE38                   LBRA    UPDPA      ; update Part.params
FCC6 8EFDC0           SCRD1   LDX     #$FDC0     ; TS1
FCC9 CCCA00                   LDD     #TXTRAM    ; TS2
FCCC 108E000C                 LDY     #$000C     ; TL1 (1 row)
FCD0 CE0114                   LDU     #$0114     ; TL2 (23 rows)
FCD3 16FE28                   LBRA    UPDPA
                      ;*
                      ;* Clear line
FCD6 3436             CLINE   PSHS    Y,X,D
FCD8 FCDFD9                   LDD     ROW
FCDB C60C                     LDB     #$0C       ; convert to lines
FCDD 3D                       MUL
FCDE F3DFF2                   ADDD    TL2        ; +overwritten lines
FCE1 1F02                     TFR     D,Y
FCE3 108C0120                 CMPY    #$0120     ; 2nd time round ?
FCE7 2D04                     BLT     CLIN1      ; skip if not
FCE9 31A9FEE0                 LEAY    $FEE0,Y    ; -len of text ram
FCED 31A90240         CLIN1   LEAY    $0240,Y    ; +len of graphics ram
FCF1 8E0000                   LDX     #$0000
FCF4 BDF75B                   JSR     SETCRG     ; (to start of row)
FCF7 8E0240                   LDX     #$0240     ; clear one row
FCFA 8602                     LDA     #$02
FCFC BDF89E                   JSR     CLEARX
FCFF 35B6                     PULS    PC,Y,X,D
                      ;*
                      ;* Normal charset bitmap (graphic char as ASCII
                      ;* 7 bits stored as 5 columns x 8 bits images
                      ;*
FD01 0000000000       CSETB   FCB     $00,$00,$00,$00,$00 ; space
FD06 0000FA0000               FCB     $00,$00,$FA,$00,$00 ; !
FD0B 00E000E000               FCB     $00,$E0,$00,$E0,$00 ; "
FD10 50F850F850               FCB     $50,$F8,$50,$F8,$50 ; #
FD15 4854FE5424               FCB     $48,$54,$FE,$54,$24 ; $
FD1A 4626106864               FCB     $46,$26,$10,$68,$64 ; %
FD1F 0A44AA926C               FCB     $0A,$44,$AA,$92,$6C ; &
FD24 00E0D00000               FCB     $00,$E0,$D0,$00,$00 ; '
FD29 0082443800               FCB     $00,$82,$44,$38,$00 ; (
FD2E 0038448200               FCB     $00,$38,$44,$82,$00 ; )
FD33 5438FE3854               FCB     $54,$38,$FE,$38,$54 ; *
FD38 10107C1010               FCB     $10,$10,$7C,$10,$10 ; +
FD3D 000E0D0000               FCB     $00,$0E,$0D,$00,$00 ; ,
FD42 1010101010               FCB     $10,$10,$10,$10,$10 ; -
FD47 0000060600               FCB     $00,$00,$06,$06,$00 ; .
FD4C 4020100804               FCB     $40,$20,$10,$08,$04 ; /
FD51 007C82827C               FCB     $00,$7C,$82,$82,$7C ; 0
FD56 0000FE4000               FCB     $00,$00,$FE,$40,$00 ; 1
FD5B 6292928A46               FCB     $62,$92,$92,$8A,$46 ; 2
FD60 CCB2928282               FCB     $CC,$B2,$92,$82,$82 ; 3
FD65 10FE1010F0               FCB     $10,$FE,$10,$10,$F0 ; 4
FD6A 9CA2A2A2E2               FCB     $9C,$A2,$A2,$A2,$E2 ; 5
FD6F 0C9292523C               FCB     $0C,$92,$92,$52,$3C ; 6
FD74 C0A0908886               FCB     $C0,$A0,$90,$88,$86 ; 7
FD79 6C9292926C               FCB     $6C,$92,$92,$92,$6C ; 8
FD7E 7894929260               FCB     $78,$94,$92,$92,$60 ; 9
FD83 00006C6C00               FCB     $00,$00,$6C,$6C,$00 ; :
FD88 00006E6D00               FCB     $00,$00,$6E,$6D,$00 ; ;
FD8D 0082442810               FCB     $00,$82,$44,$28,$10 ; <
FD92 2828282828               FCB     $28,$28,$28,$28,$28 ; =
FD97 1028448200               FCB     $10,$28,$44,$82,$00 ; >
FD9C 60908A8040               FCB     $60,$90,$8A,$80,$40 ; ?
FDA1 7AAABA827C               FCB     $7A,$AA,$BA,$82,$7C ; @
FDA6 7E9090907E               FCB     $7E,$90,$90,$90,$7E ; A
FDAB 6C929292FE               FCB     $6C,$92,$92,$92,$FE ; B
FDB0 448282827C               FCB     $44,$82,$82,$82,$7C ; C
FDB5 7C828282FE               FCB     $7C,$82,$82,$82,$FE ; D
FDBA 82929292FE               FCB     $82,$92,$92,$92,$FE ; E
FDBF 80909090FE               FCB     $80,$90,$90,$90,$FE ; F
FDC4 5E9292827C               FCB     $5E,$92,$92,$82,$7C ; G
FDC9 FE101010FE               FCB     $FE,$10,$10,$10,$FE ; H
FDCE 0082FE8200               FCB     $00,$82,$FE,$82,$00 ; I
FDD3 FC02020204               FCB     $FC,$02,$02,$02,$04 ; J
FDD8 82442810FE               FCB     $82,$44,$28,$10,$FE ; K
FDDD 02020202FE               FCB     $02,$02,$02,$02,$FE ; L
FDE2 FE402040FE               FCB     $FE,$40,$20,$40,$FE ; M
FDE7 FE102040FE               FCB     $FE,$10,$20,$40,$FE ; N
FDEC 7C8282827C               FCB     $7C,$82,$82,$82,$7C ; O
FDF1 60909090FE               FCB     $60,$90,$90,$90,$FE ; P
FDF6 7A848A827C               FCB     $7A,$84,$8A,$82,$7C ; Q
FDFB 62949890FE               FCB     $62,$94,$98,$90,$FE ; R
FE00 4C92929264               FCB     $4C,$92,$92,$92,$64 ; S
FE05 8080FE8080               FCB     $80,$80,$FE,$80,$80 ; T
FE0A FC020202FC               FCB     $FC,$02,$02,$02,$FC ; U
FE0F F8040204F8               FCB     $F8,$04,$02,$04,$F8 ; V
FE14 FE041804FE               FCB     $FE,$04,$18,$04,$FE ; W
FE19 C6281028C6               FCB     $C6,$28,$10,$28,$C6 ; X
FE1E E0100E10E0               FCB     $E0,$10,$0E,$10,$E0 ; Y
FE23 C2A2928A86               FCB     $C2,$A2,$92,$8A,$86 ; Z
FE28 008282FE00               FCB     $00,$82,$82,$FE,$00 ; [
FE2D 0408102040               FCB     $04,$08,$10,$20,$40 ; \
FE32 00FE828200               FCB     $00,$FE,$82,$82,$00 ; ]
FE37 2040FE4020               FCB     $20,$40,$FE,$40,$20 ; ^
FE3C 0101010101               FCB     $01,$01,$01,$01,$01 ; _
FE41 0000D0E000               FCB     $00,$00,$D0,$E0,$00 ; `
FE46 021E2A2A0E               FCB     $02,$1E,$2A,$2A,$0E ; a
FE4B 3C2222FE02               FCB     $3C,$22,$22,$FE,$02 ; b
FE50 1222221C00               FCB     $12,$22,$22,$1C,$00 ; c
FE55 02FE22221C               FCB     $02,$FE,$22,$22,$1C ; d
FE5A 122A2A1C00               FCB     $12,$2A,$2A,$1C,$00 ; e
FE5F 40503E1000               FCB     $40,$50,$3E,$10,$00 ; f
FE64 3E25251900               FCB     $3E,$25,$25,$19,$00 ; g
FE69 1E2020FE00               FCB     $1E,$20,$20,$FE,$00 ; h
FE6E 00005E0000               FCB     $00,$00,$5E,$00,$00 ; i
FE73 002E010200               FCB     $00,$2E,$01,$02,$00 ; j
FE78 2214087E00               FCB     $22,$14,$08,$7E,$00 ; k
FE7D 00027E4000               FCB     $00,$02,$7E,$40,$00 ; l
FE82 1E203E203E               FCB     $1E,$20,$3E,$20,$3E ; m
FE87 1E20203E00               FCB     $1E,$20,$20,$3E,$00 ; n
FE8C 1C22221C00               FCB     $1C,$22,$22,$1C,$00 ; o
FE91 1824243F00               FCB     $18,$24,$24,$3F,$00 ; p
FE96 013F242418               FCB     $01,$3F,$24,$24,$18 ; q
FE9B 2020103E00               FCB     $20,$20,$10,$3E,$00 ; r
FEA0 242A2A1200               FCB     $24,$2A,$2A,$12,$00 ; s
FEA5 04227C2000               FCB     $04,$22,$7C,$20,$00 ; t
FEAA 023E02023C               FCB     $02,$3E,$02,$02,$3C ; u
FEAF 300C020C30               FCB     $30,$0C,$02,$0C,$30 ; v
FEB4 3C020C023C               FCB     $3C,$02,$0C,$02,$3C ; w
FEB9 22121C2422               FCB     $22,$12,$1C,$24,$22 ; x
FEBE 3F05043800               FCB     $3F,$05,$04,$38,$00 ; y
FEC3 20322A2602               FCB     $20,$32,$2A,$26,$02 ; z
FEC8 82826C1000               FCB     $82,$82,$6C,$10,$00 ; {
FECD 0000EE0000               FCB     $00,$00,$EE,$00,$00 ; |
FED2 106C828200               FCB     $10,$6C,$82,$82,$00 ; }
FED7 1C10101010               FCB     $1C,$10,$10,$10,$10 ; ~
FEDC AA55AA55AA               FCB     $AA,$55,$AA,$55,$AA ; chess pattern
FEE1 FFFFFFFFFF               FCB     $FF,$FF,$FF,$FF,$FF ; bloc pattern
FEE6 C3810081C3               FCB     $C3,$81,$00,$81,$C3 ; angle pattern
FEEB F8FF29                   FCB     $F8,$FF,$29         ; void...
                      ;*
                      ;* SAM space : not used, except $FFF0-$FFFF (vectors)
                      ;* $FF60-$FFBF is readable too (boot ROM) but seems not used
                      ;*
                      
FF00                          ORG     $FF00
                      
FF00 FFBB                     FDB     $FFBB                    ;FF00: FF BB
FF02 0216                     FDB     $0216                    ;FF02: 02 16
FF04 FFB9                     FDB     $FFB9                    ;FF04: FF B9
FF06 0216                     FDB     $0216                    ;FF06: 02 16
FF08 FFB3                     FDB     $FFB3                    ;FF08: FF B3
FF0A 0216                     FDB     $0216                    ;FF0A: 02 16
FF0C FFBB                     FDB     $FFBB                    ;FF0C: FF BB
FF0E 0216                     FDB     $0216                    ;FF0E: 02 16
FF10 FFBB                     FDB     $FFBB                    ;FF10: FF BB
FF12 0014                     FDB     $0014                    ;FF12: 00 14
FF14 FFBB                     FDB     $FFBB                    ;FF14: FF BB
FF16 0214                     FDB     $0214                    ;FF16: 02 14
FF18 FFBB                     FDB     $FFBB                    ;FF18: FF BB
FF1A 0216FFBB                 FDB     $0216,$FFBB              ;FF1A: 02 16 FF BB
FF1E 0014                     FDB     $0014                    ;FF1E: 00 14
FF20 FFB90216FFBB0016         FDB     $FFB9,$0216,$FFBB,$0016  ;FF20: FF B9 02 16 FF BB 00 16
FF28 FFB30212FFB30216         FDB     $FFB3,$0212,$FFB3,$0216  ;FF28: FF B3 02 12 FF B3 02 16
FF30 FFF30016FFBB0014         FDB     $FFF3,$0016,$FFBB,$0014  ;FF30: FF F3 00 16 FF BB 00 14
FF38 FFB30014FFB3001C         FDB     $FFB3,$0014,$FFB3,$001C  ;FF38: FF B3 00 14 FF B3 00 1C
FF40 1000BFFF1000BFFF         FDB     $1000,$BFFF,$1000,$BFFF  ;FF40: 10 00 BF FF 10 00 BF FF
FF48 1000BFFF1000BFFF         FDB     $1000,$BFFF,$1000,$BFFF  ;FF48: 10 00 BF FF 10 00 BF FF
FF50 1000BFFF1000FFFF         FDB     $1000,$BFFF,$1000,$FFFF  ;FF50: 10 00 BF FF 10 00 FF FF
FF58 1000BFFF1000FFFF         FDB     $1000,$BFFF,$1000,$FFFF  ;FF58: 10 00 BF FF 10 00 FF FF
FF60 1000BFFF1000BFFF         FDB     $1000,$BFFF,$1000,$BFFF  ;FF60: 10 00 BF FF 10 00 BF FF
FF68 1000FFFF1000BFFF         FDB     $1000,$FFFF,$1000,$BFFF  ;FF68: 10 00 FF FF 10 00 BF FF
FF70 1000FFFF1000BFFF         FDB     $1000,$FFFF,$1000,$BFFF  ;FF70: 10 00 FF FF 10 00 BF FF
FF78 1000BFFF1000FFFF         FDB     $1000,$BFFF,$1000,$FFFF  ;FF78: 10 00 BF FF 10 00 FF FF
FF80 B9FF1400B8FF1600         FDB     $B9FF,$1400,$B8FF,$1600  ;FF80: B9 FF 14 00 B8 FF 16 00
FF88 BBFF1600B9FD1402         FDB     $BBFF,$1600,$B9FD,$1402  ;FF88: BB FF 16 00 B9 FD 14 02
FF90 B9FF1600B1FD1602         FDB     $B9FF,$1600,$B1FD,$1602  ;FF90: B9 FF 16 00 B1 FD 16 02
FF98 B9FF1600B9FD1402         FDB     $B9FF,$1600,$B9FD,$1402  ;FF98: B9 FF 16 00 B9 FD 14 02
FFA0 B1FF1600B9FD1602         FDB     $B1FF,$1600,$B9FD,$1602  ;FFA0: B1 FF 16 00 B9 FD 16 02
FFA8 BBFF1600B8FF1602         FDB     $BBFF,$1600,$B8FF,$1602  ;FFA8: BB FF 16 00 B8 FF 16 02
FFB0 B9FF1600B9FD1602         FDB     $B9FF,$1600,$B9FD,$1602  ;FFB0: B9 FF 16 00 B9 FD 16 02
FFB8 B9FF1600B9FD1602         FDB     $B9FF,$1600,$B9FD,$1602  ;FFB8: B9 FF 16 00 B9 FD 16 02
FFC0 0010FFBF0010FFBF         FDB     $0010,$FFBF,$0010,$FFBF  ;FFC0: 00 10 FF BF 00 10 FF BF
FFC8 0010FFBF0010FFBF         FDB     $0010,$FFBF,$0010,$FFBF  ;FFC8: 00 10 FF BF 00 10 FF BF
FFD0 0010FFBF0010             FDB     $0010,$FFBF,$0010        ;FFD0: 00 10 FF BF 00 10
FFD6 FFBF                     FDB     $FFBF                    ;FFD6: FF BF
FFD8 0010                     FDB     $0010                    ;FFD8: 00 10
FFDA FFBF                     FDB     $FFBF                    ;FFDA: FF BF
FFDC 0010                     FDB     $0010                    ;FFDC: 00 10
FFDE FFFF                     FDB     $FFFF                    ;FFDE: FF FF
FFE0 0010FFBF0010FFBF         FDB     $0010,$FFBF,$0010,$FFBF  ;FFE0: 00 10 FF BF 00 10 FF BF
FFE8 0010FFBF0010FFBF         FDB     $0010,$FFBF,$0010,$FFBF  ;FFE8: 00 10 FF BF 00 10 FF BF
                      ;*
                      ;* Restart control vectors.
                      ;*
FFF0                            ORG (PROM+$1FF0)
                      
FFF0 F08E                       FDB      RESET                 ; Not implemented in 6809.
FFF2 F12C                       FDB      SWI3                  ; Software interupt three.
FFF4 F128                       FDB      SWI2                  ; Software interupt two.
FFF6 F124                       FDB      FIRQ                  ; Fast interupt request.
FFF8 F120                       FDB      IRQ                   ; Interupt request.
FFFA E575                       FDB      SWI                   ; Software interupt.
FFFC F11C                       FDB      NMI                   ; Non-maskable interupt.
FFFE F08E             VCRST     FDB      RESET                 ; Cold start.
                      ;*
                      ;*
0000                            END
