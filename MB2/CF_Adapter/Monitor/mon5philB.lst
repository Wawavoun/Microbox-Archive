                       NAM Mon09
                       STTL Ver 5.0B    Ph. Roehr   27/04/2025
                      ;******************************************
                      ;******************************************
                      ;** MON09  Ver 5.0B                      **
                      ;** Original design Micro Concepts 1985  **
                      ;**                                      **
                      ;** Compact Flash adaptation 2025        **
                      ;** by Ph. Roehr                         **
                      ;**                                      **
                      ;******************************************
                      ;******************************************
                      ;*
                      ;******************************************
                      ;* This program is the core section of a  *
                      ;* general 6809(E) system monitor. It can *
                      ;* be configured to a particular system   *
                      ;* at assembly time by including on the   *
                      ;* source disk libary files containing    *
                      ;* the system specific code for the disk  *
                      ;* and console drivers and extra commands *
                      ;* and subroutines. These files are:-     *
                      ;*  SCRATCH.....Contains RMB's for extra  *
                      ;*              temp storage.             *
                      ;*  FDB.........Contains the jump table   *
                      ;*              entries for extra subs.   *
                      ;*  COMTABLE....Contains the extra jump   *
                      ;*              table entries for commands*
                      ;*  MINIT.......Contains the power on     *
                      ;*              and reset code.           *
                      ;*  CONSOLE.....Contains the console      *
                      ;*              driver code.              *
                      ;*  DISK........Contains the disk driver  *
                      ;*              code.                     *
                      ;*  SUBS........Contains the code for any *
                      ;*              extra system subroutines. *
                      ;*  BOOT........Contains the boot routine.*
                      ;*  COMMANDS....Contains the code for any *
                      ;*              extra commands.           *
                      ;******************************************
                      ;*
                      ;*
                      ;*
                      ;**************************
                      ;* Common System Equates  *
                      ;**************************
                      ;*
                      ;* LIB STARTADD
                      ;*
                      ;* FLEX variables ?
                      ;*
 CC00                 TTYBS   EQU   $CC00
 D3E5                 CINCHN  EQU   $D3E5        ; FLEX ?
                      ;*
                      ;* Other addresses
                      ;*
 E000                 PROM    EQU   $E000        ; Start of PROM
 CD00                 COLDS   EQU   $CD00        ; FLEX Cold Start
 CA00                 TXTRAM  EQU   $CA00        ; TEXT RAM
 CA02                 MCA02   EQU   $CA02        ; ?
                      ;*
 DE00                 RAM     EQU   $DE00        ; Scratch ram + stack space.
 FF00                 IO      EQU   $FF00        ; base address.
 DE6F                 SSTACK  EQU   (RAM+127-16) ; Top of system stack.
 DF80                 SCRAT   EQU   (RAM+384)    ; Start of scratch space.
                      ;*
                      ;* I/O
                      ;*
 FF00                 PIA1    EQU   IO           ; $FF00
 FF02                 SYSREG  EQU   PIA1+2       ; $FF02
 FF04                 ACIA2   EQU   IO+4         ; $FF04
 FF08                 ACIA1   EQU   IO+8         ; $FF08
 FF0C                 BAUD    EQU   IO+12        ; $FF0C
 FF10                 COMREG  EQU   IO+16        ; $FF10 : FDC Control register
 FF13                 DATREG  EQU   COMREG+3     ; $FF13 : FDC Data register
 FF14                 GDC     EQU   IO+20        ; $FF14
 FF18                 RTC     EQU   IO+24        ; $FF18
 FF1C                 PIA2    EQU   IO+28        ; $FF1C
                      ;*
                      ;* SAM Registers
                      ;*
 FFD6                 CLR_R0  EQU   $FFD6
 FFD7                 SET_R0  EQU   $FFD7
 FFD8                 CLR_R1  EQU   $FFD8
 FFD9                 SET_R1  EQU   $FFD9

                      ;*********************************
                      ;* Compact Flash System Equates  *
                      ;*********************************

                      ;* ABSOLUTE PIA PORT ADDRESSES

 FF1C                 PORTA               EQU     PIA2
 FF1D                 PORTB               EQU     PIA2+1
 FF1E                 PORTC               EQU     PIA2+2
 FF1F                 PORTCTRL            EQU     PIA2+3

                      ;* PIA CONTROL BYTES FOR READ AND WRITE TO IDE DRIVE

 0092                 RD_IDE_8255         EQU     $92     ; %10010010 PORT C CTRL OUT, PORT A/B DATA INPUT
 0080                 WR_IDE_8255         EQU     $80     ; %10000000 ALL 3 PORTS OUTPUT

                      ;* PIA CTRL PORT BIT FUNCTIONS

 0001                 IDE_A0              EQU     $01
 0002                 IDE_A1              EQU     $02
 0004                 IDE_A2              EQU     $04
 0008                 IDE_CS0             EQU     $08     ; INVERTED ON BOARD - SO SET FOR SELECT
 0010                 IDE_CS1             EQU     $10     ; INVERTED - SO SET FOR SELECT
 0020                 IDE_WR              EQU     $20     ; INVERTED - SO SET FOR WRITE
 0040                 IDE_RD              EQU     $40     ; INVERTED - SO SET FOR READ
 0080                 IDE_RST             EQU     $80     ; INVERTED - SO SET FOR RESET

                      ; COMPACT FLASH REGISTER CONSTANTS FOR A BETTER READING OF THE CODE

 0008                 IDE_DATA            EQU     IDE_CS0                      ; DATA R/W
 0009                 IDE_ERR             EQU     IDE_CS0+IDE_A0               ; READ ERROR CODE
 0009                 IDE_SET_FEAT        EQU     IDE_CS0+IDE_A0               ; WRITE FEATURE
 000A                 IDE_SEC_CNT         EQU     IDE_CS0+IDE_A1               ; NUMBER OF SECTORS TO TRANSFER
 000B                 IDE_LBA0            EQU     IDE_CS0+IDE_A1+IDE_A0        ; SECTOR ADDRESS LBA 0 [BITS 0:7]
 000C                 IDE_LBA1            EQU     IDE_CS0+IDE_A2               ; SECTOR ADDRESS LBA 1 [BITS 8:15]
 000D                 IDE_LBA2            EQU     IDE_CS0+IDE_A2+IDE_A0        ; SECTOR ADDRESS LBA 2 [BITS 16:23]
 000E                 IDE_LBA3            EQU     IDE_CS0+IDE_A2+IDE_A1        ; SECTOR ADDRESS LBA 3 [BITS 24:27 (LSB)]
 000F                 IDE_COMMAND         EQU     IDE_CS0+IDE_A2+IDE_A1+IDE_A0 ; WRITE COMMAND
 000F                 IDE_STATUS          EQU     IDE_CS0+IDE_A2+IDE_A1+IDE_A0 ; READ CF STATUS

                      ;* IDE COMMAND CONSTANTS. THESE SHOULD NEVER CHANGE.

 0020                 IDE_CMD_READ        EQU     $20                 ; READ A LBA
 0030                 IDE_CMD_WRITE       EQU     $30                 ; WRITE A LBA
 00EF                 IDE_CMD_SET_FEAT    EQU     $EF                 ; SET FEATURES

                      ;* FEATURE REQUESTS

 0081                 IDE_FEA_16BIT       EQU     $81
 00E0                 LBA3MST             EQU     $E0                 ; LBA3 FOR IDE MASTER
 00F0                 LBA3SLV             EQU     $F0                 ; LBA3 FOR IDE SLAVE

                      ; CF CONTROL BITS

 0008                 DRQBIT              EQU     %00001000           ; DATA REQUEST BIT = CF STATUS BIT 3
 0040                 RDYBIT              EQU     %01000000           ; READY BIT = BIT 6
 0080                 BSYBIT              EQU     %10000000           ; BUSY BIT = BIT 7
 0001                 ERRBIT              EQU     %00000001           ; ERROR BIT = BIT 0

                      ;**************************
                      ;* scratch storage space  *
                      ;**************************

                      ;* PARAMS TABLE FOR CF

                              ORG   (RAM+128-8)

 DE78                 SETFEA  RMB   1          ; SET FEATURE 16 BITS MODE
 DE79                 SCTCNT  RMB   1          ; SECTOR COUNT FOR R/W (ALWAYS 1)
 DE7A                 LBA0    RMB   1          ; LBA7 TO LBA0
 DE7B                 LBA1    RMB   1          ; LBA15 TO LBA8
 DE7C                 LBA2    RMB   1          ; LBA23 TO LBA 16
 DE7D                 LBA3    RMB   1          ; B7=1 / B6=1 FOR LBA / B5=1 / B4=0 MASTER B4=1 SLAVE / B3->B0 LBA27 TO LBA24
 DE7E                 MSTCFOK RMB   1          ; CF PRESENT FLAGS BY DEFAULT NOT
 DE7F                 SLVCFOK RMB   1          ; BOTH SET BY INITCF ROUTINE

                              ORG   (RAM+128)

 DE80                 BUFFER  RMB   256          ; Floppy interface sector buffer.

                              ORG   SCRAT

 DF80                 STACK   RMB   2            ; User system stack.
 DF82                 NMIV    RMB   2            ; NMI interrupt vector.
 DF84                 IRQV    RMB   2            ; IRQ interrupt vector.
 DF86                 FIRQV   RMB   2            ; FIRQ interrupt vector.
 DF88                 SWI2V   RMB   2            ; SWI2 interrupt vector.
 DF8A                 SWI3V   RMB   2            ; SWI3 interrupt vector.
 DF8C                 IPORT   RMB   1            ; Active input port.
 DF8D                 OPORT   RMB   1            ; Active output port.
 DF8E                 DRIVE   RMB   1            ; Format drive value.
 DF8F                 TRACK   RMB   1            ; Format track value.
 DF90                 SECTOR  RMB   1            ; Format sector value.
 DF91                 TEMP    RMB   1
 DF92                 XTEMP   RMB   2
 DF94                 YTEMP   RMB   2
 DF96                 TTO     RMB   2
 DF98                 RNDM    RMB   4            ; Random number storage.
 DF9C                 WARMS   RMB   1            ; Warm start flag.
 DF9D                 DDSTAB  RMB   4            ; Disc driver type table.
 DFA1                 REAVEC  RMB   2            ; Disc driver jump tables.
 DFA3                 WRIVEC  RMB   2
 DFA5                 VERVEC  RMB   2
 DFA7                 RSTVEC  RMB   2
 DFA9                 DRVVEC  RMB   2
 DFAB                 CHKVEC  RMB   2
 DFAD                 QUIVEC  RMB   2
 DFAF                 INIVEC  RMB   2
 DFB1                 WARVEC  RMB   2
 DFB3                 SEEVEC  RMB   2

                      ;*********************************************
                      ;* Extra scratch space for system dependant  *
                      ;* routines fits here.                       *
                      ;*********************************************
                      ;* LIB SCRATCH
                      ;*
 DFB5                 RTCFAIL EQU   $DFB5        ; ?
 DFB6                 CURDRV  EQU   $DFB6        ; ?
 DFB7                 XCOORD  EQU   $DFB7        ; ?
 DFB9                 YCOORD  EQU   $DFB9        ; ?
 DFBB                 PART1   EQU   $DFBB        ; ?
 DFBF                 PART2   EQU   $DFBF        ; ?
 DFC3                 GPARAM  EQU   $DFC3        ; ?
 DFC4                 MDFC4   EQU   $DFC4        ; ?
 DFCB                 GMODE   EQU   $DFCB        ; ?
 DFCC                 GZOOM   EQU   $DFCC        ; ?
 DFCD                 GFIGS   EQU   $DFCD        ; ?
 DFCE                 DN      EQU   $DFCE        ; ?
 DFD0                 D0      EQU   $DFD0        ; ?
 DFD1                 D1      EQU   $DFD1        ; ?
 DFD2                 D2      EQU   $DFD2        ; ?
 DFD4                 D4      EQU   $DFD4        ; ?
 DFD6                 DM      EQU   $DFD6        ; ?
 DFD8                 CONST   EQU   $DFD8        ; ?
 DFD9                 ROW     EQU   $DFD9        ; ?
 DFDA                 COL     EQU   $DFDA        ; ?
 DFE1                 ATTRI   EQU   $DFE1        ; ?
 DFE5                 CURSOR  EQU   $DFE5        ; ?
 DFEA                 CTYPE   EQU   $DFEA        ; ?
 DFEB                 ESCFLG  EQU   $DFEB        ; ?
 DFEC                 TS1     EQU   $DFEC        ; ?
 DFEE                 TS2     EQU   $DFEE        ; ?
 DFF0                 TL1     EQU   $DFF0        ; ?
 DFF2                 TL2     EQU   $DFF2        ; ?
 DFF4                 DEN     EQU   $DFF4        ; Density
 DFF5                 DEN1    EQU   $DFF5
 DFF6                 STEP    EQU   $DFF6        ; Floppy stepping speed
 DFF7                 SPEED   EQU   $DFF7        ; SAM speed setting
 DFF8                 TSTEP   EQU   $DFF8        ; ?
 DFF9                 PSPEED  EQU   $DFF9        ; ?
 DFFA                 MDFFA   EQU   $DFFA        ; ?
 DFFB                 DROMSZ  EQU   $DFFB        ; !!! NOT RELEVANT IN THIS VERSION !!!
 DFFC                 REGDP   EQU   $DFFC        ; Current DP Register
 DFFD                 FLASH   EQU   $DFFD        ; ?
 DFFF                 BLANKD  EQU   $DFFF        ; ?
                      ;*
                      ;*********************************
                      ;* Monitor part of PROM, disabled when FLEX is running
                      ;*********************************

                              ORG     PROM

                      ;* LIB MINIT
 E000 0A0D            HDR     FCB     $0A,$0D
 E002 2B2B2B204D6F6E          FCC     '+++ Mon09 v5.0B Ph. Roehr 2025 +++'
 E009 30392076352E30
 E010 422050682E2052
 E017 6F656872203230
 E01E 3235202B2B2B
 E024 04                      FCB     $04
 E025 0A0D            PROMPT  FCB     $0A,$0D
 E027 3D3E                    FCC     '=>'
 E029 04                      FCB     $04
 E02A 07              NOTTHS  FCB     $07
 E02B 20556E6B6E6F77          FCC     ' Unknown command! '
 E032 6E20636F6D6D61
 E039 6E642120
 E03D 04                      FCB     $04
 E03E 070707070707    UNMESS  FCB     $07,$07,$07,$07,$07,$07
 E044 07070707                FCB     $07,$07,$07,$07
 E048 554E4558504543          FCC     'UNEXPECTED INTERUPT!!!!!!!!!!'
 E04F 54454420494E54
 E056 45525550542121
 E05D 21212121212121
 E064 21
 E065 04                      FCB     $04
 E066 070707          PFAIL   FCB     $07,$07,$07
 E069 506F7765722066          FCC     'Power failure in RTC, reloading defaults'
 E070 61696C75726520
 E077 696E205254432C
 E07E 2072656C6F6164
 E085 696E6720646566
 E08C 61756C7473
 E091 04                      FCB     $04
 E092 4D617374657220  CFMST   FCC     'Master CF detected'
 E099 43462064657465
 E0A0 63746564
 E0A4 04                      FCB     $04
 E0A5 536C6176652043  CFSLV   FCC     'Slave CF detected'
 E0AC 46206465746563
 E0B3 746564
 E0B6 04                      FCB     $04
                      ;*
                      ;* default values for RTC RAM
                      ;*
 E0B7 50FF010002      TCONST  FCB     $50,$FF,$01,$00,$02
 E0BC 0308003A00              FCB     $03,$08,$00,$3A,$00
 E0C1 5000000800              FCB     $50,$00,$00,$08,$00
 E0C6 001B00011F              FCB     $00,$1B,$00,$01,$1F
 E0CB 2E65080604              FCB     $2E,$65,$08,$06,$04
 E0D0 2041000000              FCB     $20,$41,$00,$00,$00
 E0D5 0000000000              FCB     $00,$00,$00,$00,$00
 E0DA 0000000000              FCB     $00,$00,$00,$00,$00
 E0DF 0000000000              FCB     $00,$00,$00,$00,$00
 E0E4 0000000000              FCB     $00,$00,$00,$00,$00
                      ;*
                      ;* System dependant init : part 2 of RESET routine
                      ;*
 E0E9 BFDF98          MINIT1  STX     RNDM
 E0EC C60D                    LDB     #$0D
 E0EE BDF5F8                  JSR     GETRTC     ; read D-reg
 E0F1 8480                    ANDA    #$80       ; mask off bit 0-6
 E0F3 B7DFB5                  STA     RTCFAIL    ; =0 if no power
 E0F6 B6FF02                  LDA     SYSREG
 E0F9 43                      COMA
 E0FA 44                      LSRA
 E0FB 44                      LSRA
 E0FC 44                      LSRA
 E0FD 44                      LSRA
 E0FE 1F89                    TFR     A,B
 E100 C401                    ANDB    #$01
 E102 F7DF8C                  STB     IPORT
 E105 1F89                    TFR     A,B
 E107 54                      LSRB
 E108 C401                    ANDB    #$01
 E10A F7DF8D                  STB     OPORT
 E10D 7DDFB5                  TST     RTCFAIL
 E110 260F                    BNE     INIT2      ; RTC data valid ?
 E112 8EE0B7                  LDX     #TCONST    ; no, so get default values
 E115 C60E                    LDB     #$0E
 E117 A680            IRTC    LDA     ,X+
 E119 BDF616                  JSR     PUTRTC
 E11C 5C                      INCB
 E11D C140                    CMPB    #$40
 E11F 26F6                    BNE     IRTC
 E121 C60E            INIT2   LDB     #$0E       ; get RTC saved data
 E123 BDF5F8                  JSR     GETRTC
 E126 1F89                    TFR     A,B
 E128 8480                    ANDA    #$80
 E12A B7DFF9                  STA     PSPEED     ; init cpu speed (?)
 E12D 1F98                    TFR     B,A
 E12F 8440                    ANDA    #$40
 E131 B7DFFA                  STA     MDFFA      ; init ?
 E134 1F98                    TFR     B,A
 E136 8430                    ANDA    #$30
 E138 48                      ASLA
 E139 48                      ASLA
 E13A 84C0                    ANDA    #$C0
 E13C B7DFFB                  STA     DROMSZ     ; !!! NOT RELEVANT IN THIS VERSION !!!
 E13F 1F98                    TFR     B,A
 E141 840C                    ANDA    #$0C
 E143 44                      LSRA
 E144 44                      LSRA
 E145 B7DFF7                  STA     SPEED      ; init cpu speed
 E148 1F98                    TFR     B,A
 E14A 8403                    ANDA    #$03
 E14C B7DFF8                  STA     TSTEP      ; init disc step speed
 E14F 4F                      CLRA
 E150 BBDFF7                  ADDA    SPEED
 E153 B7FF10                  STA     COMREG
 E156 7DDFF9                  TST     PSPEED
 E159 2703                    BEQ     INIT3
 E15B B7FFD9                  STA     SET_R1     ; init SAM values for FAST/SLOW
 E15E 86CE            INIT3   LDA     #$CE
 E160 B7FF09                  STA     ACIA1+1    ; init acia 1 and 2
 E163 B7FF05                  STA     ACIA2+1    ; 2 stop bits,no parity,8 bits,baud rate factor=X16
 E166 8627                    LDA     #$27
 E168 B7FF09                  STA     ACIA1+1    ; enable reciever & transmitter
 E16B B7FF05                  STA     ACIA2+1
 E16E C60F                    LDB     #$0F
 E170 BDF5F8                  JSR     GETRTC
 E173 B7FF0C                  STA     BAUD       ; 9600 baud
 E176 44                      LSRA
 E177 44                      LSRA
 E178 44                      LSRA
 E179 44                      LSRA
 E17A B7FF0D                  STA     BAUD+1
 E17D BDF8E1                  JSR     GDCINI     ; init graphic controler
 E180 869B                    LDA     #$9B
 E182 B7FF1F                  STA     PIA2+3
 E185 C610                    LDB     #$10
 E187 8EDF9D                  LDX     #DDSTAB    ; load disc drive table
 E18A BDF5F8          INIT4   JSR     GETRTC
 E18D A780                    STA     ,X+
 E18F 5C                      INCB
 E190 C114                    CMPB    #$14
 E192 26F6                    BNE     INIT4
 E194 7DDFB5                  TST     RTCFAIL    ; message if RTC data not valid
 E197 2606                    BNE     RTCOK
 E199 8EE066                  LDX     #PFAIL
 E19C BDF533                  JSR     PSTRNG

                      ;* IDE/CF detection and init
 E19F 8619            RTCOK   LDA     #25
 E1A1 BDEFD0                  JSR     WAIT1MS    ; wait 25 ms after power on
 E1A4 8692                    LDA     #RD_IDE_8255
 E1A6 B7FF1F                  STA     PORTCTRL   ; set port C as output
 E1A9 8680                    LDA     #IDE_RST   ; do a ide bus reset
 E1AB B7FF1E                  STA     PORTC
 E1AE 860A                    LDA     #10        ; keep reset low > 25 µs
 E1B0 4A              LOOPRST DECA
 E1B1 26FD                    BNE     LOOPRST
 E1B3 7FFF1E                  CLR     PORTC
 E1B6 8605                    LDA     #5
 E1B8 BDEFD0                  JSR     WAIT1MS    ; wait 5 ms for cf to complete init
 E1BB CC0000                  LDD     #$0000     ; init ram cf table
 E1BE FDDE7E                  STD     MSTCFOK    ; clear both cf present flags
 E1C1 8681                    LDA     #IDE_FEA_16BIT      ; prepare for 16 bits mode
 E1C3 B7DE78                  STA     SETFEA
 E1C6 8601                    LDA     #$01       ; prepare for rw 1 sector at a time
 E1C8 B7DE79                  STA     SCTCNT
 E1CB 86E0                    LDA     #LBA3MST   ; prepare for master cf
 E1CD B7DE7D                  STA     LBA3
 E1D0 7FDE7C                  CLR     LBA2       ; set all lba's to 0
 E1D3 7FDE7B                  CLR     LBA1
 E1D6 7FDE7A                  CLR     LBA0
 E1D9 BDF45F                  JSR     INIDT2     ; init typ 2/3 disk
 E1DC 7DDE7E                  TST     MSTCFOK    ; master cf ok ?
 E1DF 2711                    BEQ     CONTINI    ; no continue init
 E1E1 8EE092                  LDX     #CFMST     ; display master cf message
 E1E4 BDF533                  JSR     PSTRNG
 E1E7 7DDE7F                  TST     SLVCFOK    ; slave cf ok ?
 E1EA 2706                    BEQ     CONTINI    ; no continue init
 E1EC 8EE0A5                  LDX     #CFSLV     ; display slave cf message
 E1EF BDF533                  JSR     PSTRNG
                      ;* End of IDE/CF init

 E1F2 B6FF02          CONTINI LDA     SYSREG
 E1F5 43                      COMA               ; autoboot ?
 E1F6 102B012C                LBMI    BO         ; yes, boot FLEX
 E1FA 7EF0D9                  JMP     MINITR     ; no, go to monitor
                      ;*
                      ;***************************
                      ;* Jump table for commands *
                      ;***************************
 E1FD 4844            COMTAB  FCC     'HD' ; Hex dump .
 E1FF E5D0                    FDB     HD
 E201 4452                    FCC     'DR' ; Display cpu registers.
 E203 E758                    FDB     DR
                      *
 E205 5342                    FCC     'SB' ; Set baud rate for acia's.
 E207 EDF2                    FDB     SB
 E209 5349                    FCC     'SI' ; Set input port.
 E20B E2C1                    FDB     SI
 E20D 534F                    FCC     'SO' ; Set output port.
 E20F E2E7                    FDB     SO
 E211 4344                    FCC     'CD' ; Calculate two's complement branch length.
 E213 E49E                    FDB     CD
                      *
 E215 5250                    FCC     'RP' ; Run program .
 E217 E55E                    FDB     RP
 E219 4A55                    FCC     'JU' ; Jump to program .
 E21B E27B                    FDB     JU
 E21D 4A46                    FCC     'JF' ; Jump to flex warm start ($CD03).
 E21F E2A1                    FDB     JF
 E221 4350                    FCC     'CP' ; Continue program after SWI.
 E223 E4F4                    FDB     CP
                      *
 E225 4D45                    FCC     'ME' ; Memory examine and alter .
 E227 E6DE                    FDB     ME
 E229 504D                    FCC     'PM' ; Poke memory with value (no verify of data).
 E22B E643                    FDB     PM
 E22D 4C4B                    FCC     'LK' ; Load ascii text from keyboard .
 E22F E685                    FDB     LK
 E231 534D                    FCC     'SM' ; Shift a block of memory .
 E233 E7AD                    FDB     SM
 E235 464D                    FCC     'FM' ; Fill memory with a constant value.
 E237 E520                    FDB     FM
 E239 4649                    FCC     'FI' ; Find ascii string.
 E23B ED1C                    FDB     FI
                      *
 E23D 544D                    FCC     'TM' ; Quick memory test.
 E23F E823                    FDB     TM
 E241 5453                    FCC     'TS' ; Drive stepping and select test.
 E243 EBF4                    FDB     TS
 E245 5444                    FCC     'TD' ; Test random read on drive.
 E247 EB73                    FDB     TD
                      *
 E249 424F                    FCC     'BO' ; Boot FLEX.COR or FLEX.SYS from logical drive 0
 E24B E326                    FDB     BO
 E24D 5253                    FCC     'RS' ; Read sector from floppy.
 E24F E8E0                    FDB     RS
 E251 5753                    FCC     'WS' ; Write sector to floppy.
 E253 E954                    FDB     WS
 E255 4446                    FCC     'DF' ; Format disc to FLEX format.
 E257 E9E7                    FDB     DF
                      ;*
                      ;*************************************
                      ;* Extra system dependant command    *
                      ;* entries fit here.                 *
                      ;*************************************
                      ;* LIB COMTABLE
                      ;*
 E259 4246                    FCC     'BF' ; Boot Flex from floppy 0 regardless of allocation
 E25B EC19                    FDB     BF
 E25D 4443                    FCC     'DC' ; Display RTC contents
 E25F EC39                    FDB     DC
 E261 4D43                    FCC     'MC' ; RTC examine and alter
 E263 ECA9                    FDB     MC
                      ;*
 E265 FF                      FCB     $FF  ; End of table flag.
                      ;*
                      ;***************************
                      ;* Common system commands. *
                      ;***************************
                      ;*
                      ;* Jump to program.
 E266 0D4A756D702074  JUMES   FCB     $0D,"Jump to program at ",4
 E26D 6F2070726F6772
 E274 616D2061742004

 E27B 8EE266          JU      LDX     #JUMES
 E27E BDF52C                  JSR     PDATA1
 E281 BDF56A                  JSR     BADDR
 E284 7EF645                  JMP     MAPOUT
                      ;*
                      ;* Jump to flex warm start.
 E287 0D4A756D702074  JFMES   FCB     $0D,"Jump to flex warm start.",4
 E28E 6F20666C657820
 E295 7761726D207374
 E29C 6172742E04

 E2A1 8EE287          JF      LDX     #JFMES
 E2A4 BDF52C                  JSR     PDATA1
 E2A7 8ECD03                  LDX     #$CD03
 E2AA 7EF645                  JMP     MAPOUT
                      ;*
                      ;* Set input port.
 E2AD 0D53657420696E  SIMES   FCB     $0D,"Set input port to ",4
 E2B4 70757420706F72
 E2BB 7420746F2004

 E2C1 8EE2AD          SI      LDX     #SIMES
 E2C4 BDF52C                  JSR     PDATA1
 E2C7 BDF59A                  JSR     INHEX
 E2CA 8403                    ANDA    #$03
 E2CC B7DF8C                  STA     IPORT
 E2CF 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Set output port.
 E2D2 0D536574206F75  SOMES   FCB     $0D,"Set output port to ",4
 E2D9 7470757420706F
 E2E0 727420746F2004

 E2E7 8EE2D2          SO      LDX     #SOMES
 E2EA BDF52C                  JSR     PDATA1
 E2ED BDF59A                  JSR     INHEX
 E2F0 8403                    ANDA    #$03
 E2F2 B7DF8D                  STA     OPORT
 E2F5 7EF0DF                  JMP     CONTRL
                      ;*
                      ;********************************
                      ;*    System specific Boot      *
                      ;*    command goes here.        *
                      ;********************************
                      ;* LIB BOOT
 E2F8 0D              BOMES   FCB     $0D
 E2F9 426F6F74696E67          FCC     "Booting FLEX...."
 E300 20464C45582E2E
 E307 2E2E
 E309 04                      FCB     $04
 E30A 0A0D07          NOFLX   FCB     $0A,$0D,$07
 E30D 43616E27742066          FCC     "Can't find FLEX!" ; Can't find FLex
 E314 696E6420464C45
 E31B 5821
 E31D 04                      FCB     $04
 E31E 464C4558        BODIS   FCC     "FLEX"
 E322 00000000                FCB     $00,$00,$00,$00

                      ;* Action BO (BOot flex from logical drive 0)
 E326 8EE2F8          BO      LDX     #BOMES     ; send message
 E329 BDF52C                  JSR     PDATA1
 E32C 7FDF8E                  CLR     DRIVE      ; select drive 0
 E32F 8EDF8B                  LDX     #DRIVE-3
 E332 BDF4BC                  JSR     RST        ; drive select and track 0
 E335 C605                    LDB     #$05       ; sector 5
 E337 F7DF90                  STB     SECTOR
 E33A 4F                      CLRA
 E33B B7DF8F                  STA     TRACK      ; (start of directory)
 E33E F6DF90          BO1     LDB     SECTOR
 E341 B6DF8F                  LDA     TRACK
 E344 8EDE80                  LDX     #BUFFER    ; point to buffer
 E347 BDF4B0                  JSR     READ       ; read sector
 E34A 8EDE90                  LDX     #BUFFER+16 ; point to 1st name
 E34D C60A                    LDB     #$0A       ; names per sector
 E34F 108EE31E        BO2     LDY     #BODIS     ; (compare template)
 E353 3410                    PSHS    X          ; save addr of name
 E355 A680            BO3     LDA     ,X+        ; compare characters
 E357 A1A0                    CMPA    ,Y+
 E359 260D                    BNE     BO4        ; match ?
 E35B 108CE326                CMPY    #BO        ; yes,all done ?
 E35F 26F4                    BNE     BO3        ; no,compare next
 E361 EC05                    LDD     $05,X      ; yes,get start addr
 E363 FDDF94                  STD     YTEMP      ; of file & store it
 E366 201D                    BRA     RDSEC      ; go and load it
 E368 5A              BO4     DECB               ; no match.next name
 E369 2707                    BEQ     BO5        ; end of sector ?
 E36B 3510                    PULS    X          ; no,recover name addr
 E36D 308818                  LEAX    $18,X      ; point to next name
 E370 20DD                    BRA     BO2        ; and try again
 E372 FCDE80          BO5     LDD     BUFFER     ; next dir sector
 E375 2705                    BEQ     BOFAIL     ; end of directory ?
 E377 FDDF8F                  STD     TRACK      ; no,update T/S addr
 E37A 20C2                    BRA     BO1        ; and try again
 E37C 8EE30A          BOFAIL  LDX     #NOFLX     ; yes,failed !
 E37F BDF533                  JSR     PSTRNG     ; send error message
 E382 7EF0DF                  JMP     CONTRL     ; and back to Mono9
                      * Load Flex.sys
 E385 FCDF94          RDSEC   LDD     YTEMP      ; (T/S adr. of file)
 E388 FDDE80                  STD     BUFFER     ; put in buffer
 E38B 108EDF80                LDY     #BUFFER+256
 E38F 8D34            BOFL1   BSR     NEXTB
 E391 8102                    CMPA    #$02       ; binary record ?
 E393 270A                    BEQ     BOFL2      ; yes,go set TTO
 E395 8116                    CMPA    #$16       ; transfer addr ?
 E397 26F6                    BNE     BOFL1      ; cont.until 02 or 16
 E399 8D2A                    BSR     NEXTB      ; it was a transfer addr
 E39B 8D28                    BSR     NEXTB      ; Discard it and
 E39D 20F0                    BRA     BOFL1      ; find next record
 E39F 8D24            BOFL2   BSR     NEXTB      ; get load adr.Hi
 E3A1 B7DF96                  STA     TTO
 E3A4 8D1F                    BSR     NEXTB      ; get load adr.Lo
 E3A6 B7DF97                  STA     TTO+1
 E3A9 8D1A                    BSR     NEXTB      ; get byte count
 E3AB 1F89                    TFR     A,B        ; put it in ACC B
 E3AD 5D                      TSTB               ; if 0, end of record
 E3AE 27DF                    BEQ     BOFL1      ; go find next rec
 E3B0 BEDF96                  LDX     TTO        ; else,copy to [TTO]
 E3B3 3414            BOFL3   PSHS    X,B        ; save count & adr
 E3B5 8D0E                    BSR     NEXTB      ; get a byte
 E3B7 3514                    PULS    X,B        ; recall cnt.& adr skip
 E3B9 8CDE00                  CMPX    #RAM       ; Microbox loads
 E3BC 2202                    BHI     BOFL4      ; this area from tables
 E3BE A780                    STA     ,X+
 E3C0 5A              BOFL4   DECB               ; end of record ?
 E3C1 26F0                    BNE     BOFL3      ; no,continue
 E3C3 20CA                    BRA     BOFL1      ; yes,find next rec

                      ;* This subroutine gets the next byte from the buffer
                      ;* into ACC A. If the buffer is empty,the next sector
                      ;* is first read into the buffer. If all sectors have
                      ;* been read,a branch to 'Read tables & Exit' occures.
                      ;*
 E3C5 108CDF80        NEXTB   CMPY    #BUFFER+256
 E3C9 2610                    BNE     NEXT2      ; buffer empty ?
 E3CB 8EDE80                  LDX     #BUFFER    ; yes,read next sector
 E3CE EC84                    LDD     ,X         ; look at link adr
 E3D0 270C                    BEQ     LDTBL      ; no more, do tables
 E3D2 BDF4B0                  JSR     READ
                      ;* If read error,density setting is toggled so try again
 E3D5 26AE                    BNE     RDSEC      ; error if not 0
 E3D7 108EDE84                LDY     #BUFFER+4  ; point to name
 E3DB A6A0            NEXT2   LDA     ,Y+
 E3DD 39                      RTS
                      ;*
                      ;* Read Tables & Exit
                      ;*
 E3DE 8ED3E5          LDTBL   LDX     #CINCHN    ; load table 1
 E3E1 108EE41D                LDY     #TABLE1
 E3E5 ECA1            LDTB1   LDD     ,Y++
 E3E7 ED81                    STD     ,X++
 E3E9 8CD3FD                  CMPX    #$D3FD
 E3EC 26F7                    BNE     LDTB1
 E3EE 8EDE00                  LDX     #RAM
 E3F1 108EE435                LDY     #TABLE2    ; load table 2
 E3F5 ECA1            LDTB2   LDD     ,Y++
 E3F7 ED81                    STD     ,X++
 E3F9 8CDE1E                  CMPX    #$DE1E
 E3FC 26F7                    BNE     LDTB2
 E3FE 8639                    LDA     #$39
 E400 B7CA02                  STA     MCA02
 E403 7DDFB5                  TST     RTCFAIL    ; valid data ?
 E406 270F                    BEQ     GOFLX      ; no,ignore
 E408 8ECC00                  LDX     #TTYBS     ; else,copy in
 E40B C614                    LDB     #$14       ; TTYSET & ASN options
 E40D BDF5F8          CPRTC   JSR     GETRTC
 E410 A780                    STA     ,X+
 E412 5C                      INCB
 E413 C121                    CMPB    #$21
 E415 26F6                    BNE     CPRTC
 E417 8ECD00          GOFLX   LDX     #COLDS     ; select Cold Start
 E41A 7EF645                  JMP     MAPOUT     ; and jump to it
                      ;*
                      ;* Table 1 : console I/O
                      ;*
 E41D F153            TABLE1  FDB     INCH1
 E41F F130                    FDB     DUMMY
 E421 FFFE                    FDB     VCRST
 E423 FFFE                    FDB     VCRST
 E425 F130                    FDB     DUMMY
 E427 F130                    FDB     DUMMY
 E429 F130                    FDB     DUMMY
 E42B F0DF                    FDB     CONTRL
 E42D F130                    FDB     DUMMY
 E42F F131                    FDB     STATUS
 E431 F16E                    FDB     OUTCH
 E433 F16C                    FDB     INCH
                      ;*
                      ;* Table 2 : disk I/O
 E435 7EF4B0          TABLE2  JMP     READ
 E438 7EF4B4                  JMP     WRITE
 E43B 7EF4B8                  JMP     VERIFY
 E43E 7EF4BC                  JMP     RST
 E441 7EF4C5                  JMP     DRV
 E444 7EF4F5                  JMP     CHKRDY
 E447 7EF4F9                  JMP     QUICK
 E44A 7EF4FD                  JMP     DINIT
 E44D 7EF515                  JMP     WARM
 E450 7EF519                  JMP     SEEK
                      ;*
                      ;*         Calculate displacement.
 E453 0D43616C63756C  CALDIS  FCB     $0D,"Calculate displacement from ",4
 E45A 61746520646973
 E461 706C6163656D65
 E468 6E742066726F6D
 E46F 2004
 E471 20746F2004      TOS     FCB     " to ",4
 E476 0D0A204C6F6E67  CALD1   FCB     $0D,$0A," Long or short branch (L/S)? ",4
 E47D 206F722073686F
 E484 7274206272616E
 E48B 636820284C2F53
 E492 293F2004
 E496 2076616C756520  VALUES  FCB     " value ",4
 E49D 04

 E49E 8EE453          CD      LDX     #CALDIS
 E4A1 BDF52C                  JSR     PDATA1
 E4A4 BDF56A                  JSR     BADDR      ; get 'from'
 E4A7 3002                    LEAX    2,X        ; add 2
 E4A9 3410                    PSHS    X          ; save it
 E4AB 8EE471                  LDX     #TOS
 E4AE BDF52C                  JSR     PDATA1
 E4B1 BDF56A                  JSR     BADDR      ; get 'to'
 E4B4 1F12                    TFR     X,Y        ; save in Y
 E4B6 8EE476                  LDX     #CALD1
 E4B9 BDF52C                  JSR     PDATA1
 E4BC BDF16C                  JSR     INCH       ; get 'L/S'
 E4BF 814C                    CMPA    #'L'       ; was it L ?
 E4C1 2606                    BNE     CD1        ; no,branch
 E4C3 3510                    PULS    X          ; recall 'from'
 E4C5 3002                    LEAX    2,X        ; add 2
 E4C7 3410                    PSHS    X          ; save again
 E4C9 1F20            CD1     TFR     Y,D        ; D = 'to'
 E4CB A3E4                    SUBD    ,S         ; subtract 'from'
 E4CD EDE4                    STD     ,S         ; 'offset' now TO S
 E4CF 8EE496                  LDX     #VALUES
 E4D2 BDF52C                  JSR     PDATA1
 E4D5 3510                    PULS    X
 E4D7 BDF544                  JSR     PRINTX     ; 'offset'
 E4DA 7EF0DF                  JMP     CONTRL
                      ;*(its not format, the program just send a reset command and configure the cf, no relation with the datas stored)
                      ;* Continue program. [There is a BUG in this routine]
 E4DD 0D436F6E74696E  CONPRS  FCB     $0D,"Continue from SWI....",4
 E4E4 75652066726F6D
 E4EB 205357492E2E2E
 E4F2 2E04

 E4F4 8EE4DD          CP      LDX     #CONPRS
 E4F7 BDF52C                  JSR     PDATA1
 E4FA 6C6B                    INC     11,S       ; (PC-low)
 E4FC 7EE56D                  JMP     RP1        ; recover SP & RTI.
                      ;* BUG here? What if PC-low = $FF ???
                      ;* why not  LDX   10,S
                      ;* LEAX   1,X
                      ;* STX   10,S   ie. Increment PC.
                      ;*
                      ;* Fill memory with constant.
 E4FF 0D46696C6C206D  FILMES  FCB     $0D,"Fill memory with constant from ",4
 E506 656D6F72792077
 E50D 69746820636F6E
 E514 7374616E742066
 E51B 726F6D2004

 E520 8EE4FF          FM      LDX     #FILMES
 E523 BDF52C                  JSR     PDATA1
 E526 BDF56A                  JSR     BADDR      ; get 'from'
 E529 1F12                    TFR     X,Y        ; save in Y
 E52B 8EE471                  LDX     #TOS
 E52E BDF52C                  JSR     PDATA1
 E531 BDF56A                  JSR     BADDR      ; get 'to'
 E534 3410                    PSHS    X          ; save in X
 E536 8EE496                  LDX     #VALUES
 E539 BDF52C                  JSR     PDATA1
 E53C BDF575                  JSR     BYTE       ; get 'value'
 E53F A7A0            FM1     STA     ,Y+        ; fill until
 E541 10ACE4                  CMPY    ,S         ; from = to
 E544 26F9                    BNE     FM1        ; then
 E546 3510                    PULS    X          ; tidy stack
 E548 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Go to user routine at XXXX.
 E54B 0D52756E207072  RUNPRS  FCB     $0D,"Run program from ",4
 E552 6F6772616D2066
 E559 726F6D2004

 E55E 8EE54B          RP      LDX     #RUNPRS
 E561 BDF52C                  JSR     PDATA1
 E564 BDF56A                  JSR     BADDR      ; input start addr
 E567 AF6A                    STX     10,S       ; stack it as PC
 E569 86FF                    LDA     #$FF
 E56B A7E4                    STA     ,S         ; stack as CC
 E56D 10FEDF80        RP1     LDS     STACK      ; recover SP
 E571 3B                      RTI                ; load all registers
                      ;*
                      ;* SWI return from user program.
 E572 10FFDF80        SWI     STS     STACK      ; save SP
 E576 AE6A                    LDX     10,S       ; get PC
 E578 301F                    LEAX    -1,X       ; decrement it
 E57A AF6A                    STX     10,S       ; and put it back
 E57C 7EE75E                  JMP     DR1        ; display registers
                      ;*
                      ;* Hexdump of memory starting at XXXX.
                      ;* @@ Modified 04/2025 PhR to get also ascii display on each line
 E57F 0D486578206475  HEXDUS  FCB     $0D,"Hex dump of memory from ",4
 E586 6D70206F66206D
 E58D 656D6F72792066
 E594 726F6D2004
 E599 20202020203020  HDMES1  FCB     "     0  1  2  3  4  5  6  7   8  9  A  B  C  D  E  F  ",4
 E5A0 20312020322020
 E5A7 33202034202035
 E5AE 20203620203720
 E5B5 20203820203920
 E5BC 20412020422020
 E5C3 43202044202045
 E5CA 202046202004

 E5D0 8EE57F          HD      LDX     #HEXDUS
 E5D3 BDF52C                  JSR     PDATA1
 E5D6 BDF56A                  JSR     BADDR      ; get start addr
 E5D9 BDF520                  JSR     PCRLF
 E5DC 108E0010        HD4     LDY     #16
 E5E0 BDF520                  JSR     PCRLF
 E5E3 3410                    PSHS    X
 E5E5 8EE599                  LDX     #HDMES1
 E5E8 BDF533                  JSR     PSTRNG     ; print header
 E5EB 3510                    PULS    X
 E5ED BDF520          HD1     JSR     PCRLF
 E5F0 BDF544                  JSR     PRINTX     ; print address
 E5F3 C610                    LDB     #16        ; byte counter
 E5F5 BDF5C1          HD2     JSR     OUT2HS     ; print a byte
 E5F8 5A                      DECB
 E5F9 2709                    BEQ     HD3        ; end of line ?
 E5FB C108                    CMPB    #8         ; half way ?
 E5FD 26F6                    BNE     HD2
 E5FF BDF5C3                  JSR     OUTS       ; yes,print a space
 E602 20F1                    BRA     HD2
                      ; @@ BEGIN ASCII DUMP ADD
 E604 BDF5C3          HD3     JSR     OUTS       ; @@ print space
 E607 C6F0                    LDB     #-16       ; @@ prepare for 16 loops
 E609 A685            ASCLOOP LDA     B,X        ; @@ load byte
 E60B 8120                    CMPA    #$20       ; @@ printable ?
 E60D 2D04                    BLT     NOTPRT     ; @@ no
 E60F 817F                    CMPA    #$7F       ; @@ printable ?
 E611 2D02                    BLT     HDCONT     ; @@ yes
 E613 862E            NOTPRT  LDA     #'.'       ; @@ if not printable print a dot
 E615 BDF16E          HDCONT  JSR     OUTCH      ; @@ now print
 E618 5C                      INCB               ; @@ next byte
 E619 26EE                    BNE     ASCLOOP    ; @@ 16 bytes printed ? no do again
                      ; @@ END ASCII DUMP ADD
 E61B 313F                    LEAY    -1,Y       ; end of page ?
 E61D 26CE                    BNE     HD1        ; no,do another line
 E61F BDF16C                  JSR     INCH       ; yes,input a char
 E622 810D                    CMPA    #$0D       ; if char == CR
 E624 27B6                    BEQ     HD4        ; do another page
 E626 812D                    CMPA    #'-'       ; if char == '-'
 E628 10260AB3                LBNE    CONTRL
 E62C 3089FE00                LEAX    -512,X     ; do previous page
 E630 20AA                    BRA     HD4
                      ;*
                      ;* Poke memory.
 E632 0D506F6B65206D  POKMES  FCB     $0D,"Poke memory at ",4
 E639 656D6F72792061
 E640 742004

 E643 8EE632          PM      LDX     #POKMES
 E646 BDF52C                  JSR     PDATA1
 E649 BDF56A                  JSR     BADDR      ; input addr
 E64C 1F12                    TFR     X,Y
 E64E 8EE496                  LDX     #VALUES
 E651 BDF52C                  JSR     PDATA1
 E654 BDF575                  JSR     BYTE       ; input 'value'
 E657 A7A4                    STA     ,Y         ; store at addr
 E659 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Keyboard to memory.
 E65C 0D4C6F6164206D  LOAKES  FCB     $0D,"Load memory with text from keyboard to ",4
 E663 656D6F72792077
 E66A 69746820746578
 E671 742066726F6D20
 E678 6B6579626F6172
 E67F 6420746F2004

 E685 8EE65C          LK      LDX     #LOAKES
 E688 BDF52C                  JSR     PDATA1
 E68B BDF56A                  JSR     BADDR      ; input addr
 E68E 1F12                    TFR     X,Y
 E690 8EE496                  LDX     #VALUES
 E693 BDF52C                  JSR     PDATA1
 E696 BDF16C          LK1     JSR     INCH       ; input a character
 E699 A7A0                    STA     ,Y+        ; store it
 E69B 8104                    CMPA    #$04       ; was it EOT ?
 E69D 26F7                    BNE     LK1        ; no,input another
 E69F 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Memory load and examine.
 E6A2 0D4D656D6F7279  MEMEXS   FCB    $0D,"Memory examine and modify from ",4
 E6A9 206578616D696E
 E6B0 6520616E64206D
 E6B7 6F646966792066
 E6BE 726F6D2004
 E6C3 0720204E6F2072  NORAM    FCB    7,"  No ram at that address!",4
 E6CA 616D2061742074
 E6D1 68617420616464
 E6D8 726573732104

 E6DE 8EE6A2          ME      LDX     #MEMEXS
 E6E1 BDF52C                  JSR     PDATA1
 E6E4 BDF56A                  JSR     BADDR      ; input addr
 E6E7 BDF520          ME1     JSR     PCRLF
 E6EA BDF544                  JSR     PRINTX     ; display addr
 E6ED BDF5C1                  JSR     OUT2HS     ; and content
 E6F0 BDF16C                  JSR     INCH       ; input a char
 E6F3 812D                    CMPA    #'-'       ; was it a '-' ?
 E6F5 2604                    BNE     ME2
 E6F7 301E                    LEAX    -2,X       ; yes,back 2 locations
 E6F9 20EC                    BRA     ME1
 E6FB 810D            ME2     CMPA    #$0D       ; was it CR ?
 E6FD 27E8                    BEQ     ME1        ; yes,display next
 E6FF 8120                    CMPA    #$20       ; was it a space ?
 E701 102609DA        MED     LBNE    CONTRL     ; no,abort
 E705 BDF575                  JSR     BYTE       ; yes,input byte
 E708 A71F                    STA     -1,X       ; overwrite old byte
 E70A A11F                    CMPA    -1,X       ; read it back
 E70C 27D9                    BEQ     ME1        ; OK,display it
 E70E 8EE6C3                  LDX     #NORAM     ; cant read,send
 E711 BDF52C                  JSR     PDATA1     ; error message
 E714 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Print registers.
 E717 0D446973706C61  DISRES  FCB     $0D,"Display CPU registers.",4
 E71E 79204350552072
 E725 65676973746572
 E72C 732E04
 E72F 0A0D4343202041  RSTRNG  FCB     $0A,$0D,"CC  A  B DP    X    Y    U   PC    S",$0A,$0D,4
 E736 20204220445020
 E73D 20202058202020
 E744 20592020202055
 E74B 20202050432020
 E752 2020530A0D04

 E758 8EE717          DR      LDX     #DISRES
 E75B BDF52C                  JSR     PDATA1
 E75E 8EE72F          DR1     LDX     #RSTRNG
 E761 BDF52C                  JSR     PDATA1     ; print header
 E764 1F41                    TFR     S,X
 E766 BDF5C1                  JSR     OUT2HS     ; print registers
 E769 BDF5C1                  JSR     OUT2HS
 E76C BDF5C1                  JSR     OUT2HS
 E76F BDF5C1                  JSR     OUT2HS
 E772 BDF5BF                  JSR     OUT4HS
 E775 BDF5BF                  JSR     OUT4HS
 E778 BDF5BF                  JSR     OUT4HS
 E77B BDF5BF                  JSR     OUT4HS
 E77E 8EDF80                  LDX     #STACK     ; get Stack Pointer
 E781 BDF5BF                  JSR     OUT4HS     ; print it
 E784 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Shift blocks of memory.
 E787 0D536869667420  SHIMES  FCB     $0D,"Shift block of memory from ",4
 E78E 626C6F636B206F
 E795 66206D656D6F72
 E79C 792066726F6D20
 E7A3 04
 E7A4 204C656E677468  LENGHS  FCB     " Length ",4
 E7AB 2004

 E7AD 8EE787          SM      LDX     #SHIMES
 E7B0 BDF52C                  JSR     PDATA1
 E7B3 BDF56A                  JSR     BADDR      ; get 'from' addr
 E7B6 3440                    PSHS    U
 E7B8 1F13                    TFR     X,U        ; store it in U
 E7BA 8EE471                  LDX     #TOS
 E7BD BDF52C                  JSR     PDATA1
 E7C0 BDF56A                  JSR     BADDR      ; get 'to' addr
 E7C3 1F12                    TFR     X,Y        ; store it in Y
 E7C5 8EE7A4                  LDX     #LENGHS
 E7C8 BDF52C                  JSR     PDATA1
 E7CB BDF56A                  JSR     BADDR      ; get length of block
 E7CE A6C0            SM1     LDA     ,U+        ; move a byte
 E7D0 A7A0                    STA     ,Y+
 E7D2 301F                    LEAX    -1,X       ; dec. length
 E7D4 26F8                    BNE     SM1        ; repeat 'till end
 E7D6 3540                    PULS    U
 E7D8 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Test memory.
 E7DB 0D54657374206D  TESMES  FCB     $0D,"Test memory from ",4
 E7E2 656D6F72792066
 E7E9 726F6D2004
 E7EE 070A0D4572726F  TMS1    FCB     7,$0A,$0D,"Error at location ",4
 E7F5 72206174206C6F
 E7FC 636174696F6E20
 E803 04
 E804 6368616E676564  TMS2    FCB     "changed to ",4
 E80B 20746F2004
 E810 2054657374696E  TMS3    FCB     " Testing now with ",4
 E817 67206E6F772077
 E81E 6974682004

 E823 8EE7DB          TM      LDX     #TESMES
 E826 BDF52C                  JSR     PDATA1
 E829 BDF56A                  JSR     BADDR      ; get 'from'
 E82C 1F12                    TFR     X,Y        ; put in Y
 E82E 8EE471                  LDX     #TOS
 E831 BDF52C                  JSR     PDATA1
 E834 BDF56A                  JSR     BADDR      ; get 'to'
 E837 BFDF92                  STX     XTEMP      ; store it
 E83A 5F                      CLRB
 E83B 8EE810                  LDX     #TMS3
 E83E BDF52C                  JSR     PDATA1
 E841 F7DF91          TM5     STB     TEMP       ; store 'with'
 E844 8EDF91                  LDX     #TEMP
 E847 BDF5B7                  JSR     OUT2H      ; display 'with'
 E84A 1F21                    TFR     Y,X
 E84C E7A4            TM1     STB     ,Y         ; write/read test
 E84E E1A4                    CMPB    ,Y
 E850 261A                    BNE     TM2        ; test fails,branch
 E852 3121            TM4     LEAY    1,Y        ; else,next location
 E854 10BCDF92                CMPY    XTEMP      ; all done ?
 E858 26F2                    BNE     TM1
 E85A 5C                      INCB               ; yes,next 'with' byte
 E85B 270C                    BEQ     TM3        ; done 'em all.Exit
 E85D 8608                    LDA     #$08       ; else,update 'with'
 E85F BDF16E                  JSR     OUTCH      ; byte,return to
 E862 BDF16E                  JSR     OUTCH      ; first location
 E865 1F12                    TFR     X,Y        ; and continue
 E867 20D8                    BRA     TM5
 E869 7EF0DF          TM3     JMP     CONTRL
 E86C 8EE7EE          TM2     LDX     #TMS1      ; error message
 E86F BDF52C                  JSR     PDATA1
 E872 10BFDF92                STY     XTEMP
 E876 8EDF92                  LDX     #XTEMP     ; (faulty location)
 E879 BDF5BF                  JSR     OUT4HS
 E87C BDF5C3                  JSR     OUTS
 E87F BDF5C3                  JSR     OUTS
 E882 F7DF91                  STB     TEMP       ; (test byte)
 E885 8EDF91                  LDX     #TEMP
 E888 BDF5C1                  JSR     OUT2HS
 E88B 8EE804                  LDX     #TMS2
 E88E BDF52C                  JSR     PDATA1
 E891 A6A4                    LDA     ,Y         ; (byte read back)
 E893 B7DF91                  STA     TEMP
 E896 8EDF91                  LDX     #TEMP
 E899 BDF5C1                  JSR     OUT2HS
 E89C 20CB                    BRA     TM3        ; exit
                      ;*
                      ;*
                      ;* Read floppy sector.
 E89E 0D526561642066  REASES  FCB     $0D,"Read from sector on drive ",4
 E8A5 726F6D20736563
 E8AC 746F72206F6E20
 E8B3 64726976652004
 E8BA 20747261636B20  TRACS   FCB     " track ",4
 E8C1 04
 E8C2 20736563746F72  SECS    FCB     " sector ",4
 E8C9 2004
 E8CB 0D0A0746444320  ERR1    FCB     $0D,$0A,7,"FDC error code = ",4
 E8D2 6572726F722063
 E8D9 6F6465203D2004

 E8E0 8EE89E          RS      LDX     #REASES
 E8E3 BDF52C                  JSR     PDATA1
 E8E6 BDF59A                  JSR     INHEX      ; get drive No
 E8E9 B7DF8E                  STA     DRIVE
 E8EC 8EDF8B                  LDX     #(DRIVE-3)
 E8EF BDF4C5                  JSR     DRV        ; get drive
 E8F2 8EE8BA                  LDX     #TRACS
 E8F5 BDF52C                  JSR     PDATA1
 E8F8 BDF575                  JSR     BYTE       ; get track
 E8FB B7DF8F                  STA     TRACK
 E8FE 8EE8C2                  LDX     #SECS
 E901 BDF52C                  JSR     PDATA1
 E904 BDF575                  JSR     BYTE       ; get sector
 E907 B7DF90                  STA     SECTOR
 E90A 8EE471                  LDX     #TOS
 E90D BDF52C                  JSR     PDATA1
 E910 BDF56A                  JSR     BADDR      ; get load addr
 E913 B6DF8F                  LDA     TRACK
 E916 F6DF90                  LDB     SECTOR
 E919 BDF4B0                  JSR     READ       ; read it in
 E91C 102707BF                LBEQ    CONTRL     ; if no read error
 E920 8EE8CB                  LDX     #ERR1
 E923 BDF52C                  JSR     PDATA1     ; else,error message
 E926 F7DF91                  STB     TEMP       ; (status,masked)
 E929 8EDF91                  LDX     #TEMP
 E92C BDF5C1                  JSR     OUT2HS     ; error No
 E92F 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Write floppy sector
 E932 0D577269746520  WRIMES  FCB     $0D,"Write to sector on drive ",4
 E939 746F2073656374
 E940 6F72206F6E2064
 E947 726976652004
 E94D 2066726F6D2004  FROMS   FCB     " from ",4

 E954 8EE932          WS      LDX     #WRIMES
 E957 BDF52C                  JSR     PDATA1
 E95A BDF59A                  JSR     INHEX      ; get drive No
 E95D B7DF8E                  STA     DRIVE
 E960 8EDF8B                  LDX     #(DRIVE-3)
 E963 BDF4C5                  JSR     DRV        ; get drive
 E966 8EE8BA                  LDX     #TRACS
 E969 BDF52C                  JSR     PDATA1
 E96C BDF575                  JSR     BYTE       ; get track
 E96F B7DF8F                  STA     TRACK
 E972 8EE8C2                  LDX     #SECS
 E975 BDF52C                  JSR     PDATA1
 E978 BDF575                  JSR     BYTE       ; get sector
 E97B B7DF90                  STA     SECTOR
 E97E 8EE94D                  LDX     #FROMS
 E981 BDF52C                  JSR     PDATA1
 E984 BDF56A                  JSR     BADDR      ; get data addr
 E987 B6DF8F                  LDA     TRACK
 E98A F6DF90                  LDB     SECTOR
 E98D BDF4B4                  JSR     WRITE      ; write sector
 E990 1027074B                LBEQ    CONTRL     ; if no write error
 E994 8EE8CB                  LDX     #ERR1
 E997 BDF52C                  JSR     PDATA1     ; else,error message
 E99A F7DF91                  STB     TEMP
 E99D 8EDF91                  LDX     #TEMP
 E9A0 BDF5C1                  JSR     OUT2HS
 E9A3 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Format disc to FLEX standard.
 E9A6 0D466F726D6174  DISFOS  FCB     $0D,"Format disc to flex standard on drive ",4
 E9AD 20646973632074
 E9B4 6F20666C657820
 E9BB 7374616E646172
 E9C2 64206F6E206472
 E9C9 6976652004
 E9CE 20736372617463  SURES   FCB     " scratch disc in drive? ",4
 E9D5 68206469736320
 E9DC 696E2064726976
 E9E3 653F2004

 E9E7 8EE9A6          DF      LDX     #DISFOS
 E9EA BDF52C                  JSR     PDATA1
 E9ED BDF59A                  JSR     INHEX      ; get drive No
 E9F0 B7DF8E                  STA     DRIVE
 E9F3 8EDF8B                  LDX     #DRIVE-3
 E9F6 BDF4BC                  JSR     RST        ; restore to 00
 E9F9 7FDFF4                  CLR     DEN        ; set single density
 E9FC 8EE9CE                  LDX     #SURES     ; prompt for scratch
 E9FF BDF52C                  JSR     PDATA1     ; disc in drive
 EA02 BDF16C                  JSR     INCH       ; get reply
 EA05 8159                    CMPA    #'Y'       ; if not 'Y'
 EA07 102606D4                LBNE    CONTRL     ; then abort
 EA0B 86FF            FMT     LDA     #$FF       ; else,initialise
 EA0D B7DF8F                  STA     TRACK      ; (01-1)
 EA10 108E0002                LDY     #$0002     ; (track/sector)
 EA14 4F              FMT1    CLRA
 EA15 B7DF90                  STA     SECTOR     ; (01-1)
 EA18 7CDF8F                  INC     TRACK
 EA1B B6DF8F                  LDA     TRACK
 EA1E C601                    LDB     #1
 EA20 BDF519                  JSR     SEEK
                      ;* This is written to all tracks
 EA23 4F                      CLRA
 EA24 8E0190                  LDX     #0400      ; starting this addr
 EA27 C606                    LDB     #6
 EA29 1700FA                  LBSR    WABT       ; 6 bytes---00
 EA2C 86FC                    LDA     #$FC
 EA2E A780                    STA     ,X+        ; 1 bytes---FC
 EA30 CCFF07                  LDD     #$FF07
 EA33 1700F0                  LBSR    WABT       ; 7 bytes---FF
                      ;* This written to all sectors
 EA36 4F              FMT2    CLRA
 EA37 7CDF90                  INC     SECTOR
 EA3A C606                    LDB     #6
 EA3C 1700E7                  LBSR    WABT       ; 6 bytes---00
 EA3F 86FE                    LDA     #$FE
 EA41 A780                    STA     ,X+        ; 1 bytes---FE
 EA43 B6DF8F                  LDA     TRACK
 EA46 A780                    STA     ,X+        ; 1 bytes---[TRACK]
 EA48 4F                      CLRA
 EA49 A780                    STA     ,X+        ; 1 bytes---00
 EA4B B6DF90                  LDA     SECTOR
 EA4E A780                    STA     ,X+        ; 1 bytes---[SECTOR]
 EA50 8601                    LDA     #1
 EA52 A780                    STA     ,X+        ; 1 bytes---01
 EA54 86F7                    LDA     #$F7
 EA56 A780                    STA     ,X+        ; 1 bytes---F7
 EA58 CCFF0B                  LDD     #$FF0B
 EA5B 1700C8                  LBSR    WABT       ; 11 bytes---FF
 EA5E 4F                      CLRA
 EA5F C606                    LDB     #6
 EA61 1700C2                  LBSR    WABT       ; 6 bytes---00
 EA64 86FB                    LDA     #$FB
 EA66 A780                    STA     ,X+        ; 1 bytes---FB
                      ;* Enter track/sector link, clear data bytes,
                      ;* update track/sector link.
 EA68 1F20                    TFR     Y,D        ; get T/S link addr
 EA6A ED81                    STD     ,X++       ; enter it
 EA6C 5C                      INCB
 EA6D C10B                    CMPB    #11        ; all sectors done ?
 EA6F 260A                    BNE     FMT3       ; no,continue
 EA71 4C                      INCA               ; yes,update T/S
 EA72 C601                    LDB     #1         ; link address
 EA74 8128                    CMPA    #40        ; all tracks done ?
 EA76 2603                    BNE     FMT3       ; no,continue
 EA78 CC0000                  LDD     #0         ; yes,clear T/S link
 EA7B 1F02            FMT3    TFR     D,Y        ; save updated link
 EA7D 4F                      CLRA               ; clear data bytes
 EA7E C6FE                    LDB     #254       ; 254 bytes---00
 EA80 1700A3                  LBSR    WABT
 EA83 86F7                    LDA     #$F7
 EA85 A780                    STA     ,X+        ; 1 bytes---F7
 EA87 CCFF0E                  LDD     #$FF0E
 EA8A 170099                  LBSR    WABT       ; 14 bytes---FF
 EA8D B6DF90                  LDA     SECTOR
 EA90 810A                    CMPA    #10        ; last sector ?
 EA92 26A2                    BNE     FMT2       ; no,do next
 EA94 86FF                    LDA     #$FF
 EA96 5F                      CLRB
 EA97 17008C                  LBSR    WABT       ; 256 bytes---FF
                      ;* Write a track to disc
 EA9A 8E0190                  LDX     #0400
 EA9D 86F4                    LDA     #$F4       ; write track cmd.
 EA9F 170780                  LBSR    FCMD
 EAA2 B6FF10          FMT4    LDA     COMREG     ; get status
 EAA5 8502                    BITA    #2         ; D-reg empty ?
 EAA7 2705                    BEQ     FMT5
 EAA9 A680                    LDA     ,X+        ; yes,load it
 EAAB B7FF13                  STA     DATREG
 EAAE B6FF10          FMT5    LDA     COMREG
 EAB1 8501                    BITA    #1         ; busy ?
 EAB3 26ED                    BNE     FMT4       ; yes,wait
 EAB5 B6DF8F                  LDA     TRACK
 EAB8 8127                    CMPA    #39        ; last track ?
 EABA 1026FF56                LBNE    FMT1       ; no,do next
                      ;* Remove link addr.from final directory sector
 EABE 8EDF8B                  LDX     #DRIVE-3
 EAC1 BDF4BC                  JSR     RST
 EAC4 8EDE80                  LDX     #BUFFER    ; read T/S 00/0A
 EAC7 4F                      CLRA               ; into buffer
 EAC8 C60A                    LDB     #10        ; zero the link addr
 EACA BDF4B0                  JSR     READ       ; (no more directory sectors)
 EACD 8EDE80                  LDX     #BUFFER
 EAD0 6F84                    CLR     ,X
 EAD2 6F01                    CLR     1,X
 EAD4 4F                      CLRA
 EAD5 C60A                    LDB     #10        ; and write it
 EAD7 BDF4B4                  JSR     WRITE      ; back to disc
                      ;* Enter data to Sys.Information sector
 EADA 8EDE80                  LDX     #BUFFER
 EADD 4F                      CLRA
 EADE C603                    LDB     #3
 EAE0 BDF4B0                  JSR     READ       ; read T/S 00/03
 EAE3 8EDE80                  LDX     #BUFFER
 EAE6 6F84                    CLR     ,X         ; clear link addr
 EAE8 6F01                    CLR     1,X
 EAEA CC5343                  LDD     #$5343     ; enter name of disc
 EAED ED8810                  STD     16,X
 EAF0 CC5241                  LDD     #$5241     ; (SCRATCH!)
 EAF3 ED8812                  STD     18,X
 EAF6 CC5443                  LDD     #$5443
 EAF9 ED8814                  STD     20,X
 EAFC CC4821                  LDD     #$4821
 EAFF ED8816                  STD     22,X
 EB02 CC0001                  LDD     #1         ; enter Vol. No
 EB05 ED881B                  STD     27,X
 EB08 CC0101                  LDD     #$0101     ; enter start of
 EB0B ED881D                  STD     29,X       ; free chain
 EB0E CC270A                  LDD     #$270A     ; enter end of
 EB11 ED881F                  STD     31,X       ; free chain and
 EB14 ED8826                  STD     38,X       ; highest sector adr
 EB17 CC0186                  LDD     #$0186     ; enter length of
 EB1A ED8821                  STD     33,X       ; free chain. (ie.
 EB1D 4F                      CLRA               ; sectors left)
 EB1E C603                    LDB     #3
 EB20 BDF4B4                  JSR     WRITE      ; write it back
 EB23 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* This subroutine stores ACCA in [B] locations
                      ;* starting at location [X]
 EB26 3404            WABT    PSHS    B
 EB28 A780            WABT1   STA     ,X+
 EB2A 5A                      DECB
 EB2B 26FB                    BNE     WABT1
 EB2D 3584                    PULS    B,PC
                      ;*
                      ;* Random read test on drive.
 EB2F 0D52616E646F6D  TDMES   FCB     $0D,"Random sector read on drive ",4
 EB36 20736563746F72
 EB3D 2072656164206F
 EB44 6E206472697665
 EB4B 2004
 EB4D 48697420616E79  TDMES1  FCB     "Hit any key to stop.",4
 EB54 206B657920746F
 EB5B 2073746F702E04
 EB62 61742074726163  ERR2    FCB     "at track/sector ",4
 EB69 6B2F736563746F
 EB70 722004

 EB73 8EEB2F          TD      LDX     #TDMES
 EB76 BDF52C                  JSR     PDATA1
 EB79 BDF59A                  JSR     INHEX      ; get drive No
 EB7C B7DF8E                  STA     DRIVE
 EB7F 8EEB4D                  LDX     #TDMES1
 EB82 BDF533                  JSR     PSTRNG
 EB85 8EDF8B                  LDX     #(DRIVE-3)
 EB88 BDF4BC                  JSR     RST
 EB8B BDF5C8          TDLOOP  JSR     RANDOM     ; get a random No
 EB8E 840F                    ANDA    #$0F       ; 15 max
 EB90 8B01                    ADDA    #1         ; >0
 EB92 810A                    CMPA    #10        ; >10 ?
 EB94 2EF5                    BGT     TDLOOP     ; yes,get another
 EB96 B7DF90                  STA     SECTOR     ; else,store it
 EB99 BDF5C8          TDLP2   JSR     RANDOM     ; get a random No
 EB9C 843F                    ANDA    #$3F       ; 63 max
 EB9E 8127                    CMPA    #39        ; >39 ?
 EBA0 2EF7                    BGT     TDLP2      ; yes,get another
 EBA2 B7DF8F                  STA     TRACK      ; else,set random
 EBA5 F6DF90                  LDB     SECTOR     ; track and sector
 EBA8 8EDE80                  LDX     #BUFFER
 EBAB BDF4B0                  JSR     READ       ; read into buffer
 EBAE 260E                    BNE     TDLP9      ; read error if <> 0
 EBB0 BDF131                  JSR     STATUS     ; key pressed ?
 EBB3 27D6                    BEQ     TDLOOP     ; no,continue
 EBB5 8EDF8B                  LDX     #(DRIVE-3) ; yes,
 EBB8 BDF4BC                  JSR     RST        ; restore to 00
 EBBB 7EF0DF                  JMP     CONTRL     ; and abort
 EBBE 8EE8CB          TDLP9   LDX     #ERR1      ; report ----
 EBC1 BDF52C                  JSR     PDATA1
 EBC4 F7DF91                  STB     TEMP
 EBC7 8EDF91                  LDX     #TEMP
 EBCA BDF5C1                  JSR     OUT2HS     ; error No.'x', at
 EBCD 8EEB62                  LDX     #ERR2
 EBD0 BDF52C                  JSR     PDATA1
 EBD3 8EDF8F                  LDX     #TRACK
 EBD6 BDF5BF                  JSR     OUT4HS     ; 'track/sector'
 EBD9 20B0                    BRA     TDLOOP     ; continue
                      ;*
                      ;* Test drive stepping.
 EBDB 0D546573742073  TSMESS  FCB     $0D,"Test stepping on drive ",4
 EBE2 74657070696E67
 EBE9 206F6E20647269
 EBF0 76652004

 EBF4 8EEBDB          TS      LDX     #TSMESS
 EBF7 BDF52C                  JSR     PDATA1
 EBFA BDF59A                  JSR     INHEX      ; get drive No
 EBFD B7DF8E                  STA     DRIVE
 EC00 8EDF8B                  LDX     #(DRIVE-3)
 EC03 BDF4C5                  JSR     DRV        ; select drive
 EC06 8628            TSLOOP  LDA     #40        ; track 40,sector 1
 EC08 C601                    LDB     #1
 EC0A BDF519                  JSR     SEEK
 EC0D BDF4BC                  JSR     RST        ; restore to 00
 EC10 BDF131                  JSR     STATUS     ; key pressed ?
 EC13 102604C8                LBNE    CONTRL     ; yes,abort
 EC17 20ED                    BRA     TSLOOP     ; no,do it again
                      ;*
                      ;*
                      ;********************************************
                      ;* Extra system dependant commands go here. *
                      ;********************************************
                      ;* LIB COMMANDS
                      ;* Boot Flex from floppy 0 regardless of allocation
 EC19 7FDF9D          BF      CLR     DDSTAB     ; set Drv.0=floppy 0
 EC1C 16F707                  LBRA    BO         ; jump to loader
 EC1F 7EF0DF                  JMP     CONTRL     ; this appears to be redundant ?
                      ;*
                      ;* Display RTC non volatile data
 EC22 0D              DCMES   FCB     $0D
 EC23 446973706C6179          FCC     "Display RTC contents."
 EC2A 2052544320636F
 EC31 6E74656E74732E
 EC38 04                      FCB     $04

 EC39 8EEC22          DC      LDX     #DCMES     ; print header
 EC3C BDF52C                  JSR     PDATA1
 EC3F BDF520                  JSR     PCRLF
 EC42 5F                      CLRB               ; point to 1st byte
 EC43 8E000E                  LDX     #$000E
 EC46 8D2B                    BSR     PBLIN      ; time, date & regs (14 bytes)
 EC48 8E0001                  LDX     #$0001
 EC4B 8D26                    BSR     PBLIN      ; configuration SW (1byte)
 EC4D 8E0001                  LDX     #$0001
 EC50 8D21                    BSR     PBLIN      ; baudrates (1 byte)
 EC52 8E0004                  LDX     #$0004
 EC55 8D1C                    BSR     PBLIN      ; disc allocations (4 bytes)
 EC57 8E000B                  LDX     #$000B
 EC5A 8D17                    BSR     PBLIN      ; ttyset (11 bytes)
 EC5C 8E0002                  LDX     #$0002
 EC5F 8D12                    BSR     PBLIN      ; asn (2 bytes)
 EC61 8E0008                  LDX     #$0008
 EC64 8D0D                    BSR     PBLIN      ; GDC defaults (8 bytes)
 EC66 8E0007                  LDX     #$0007
 EC69 8D08                    BSR     PBLIN      ; reserved (7 bytes)
 EC6B 8E0010                  LDX     #$0010
 EC6E 8D03                    BSR     PBLIN      ; not used (16 bytes available)
 EC70 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Prints a line of bytes
 EC73 BDF5F8          PBLIN   JSR     GETRTC     ; get byte
 EC76 5C                      INCB               ; point to next
 EC77 B7DF91                  STA     TEMP
 EC7A 3410                    PSHS    X
 EC7C 8EDF91                  LDX     #TEMP      ; output bytes
 EC7F BDF5C1                  JSR     OUT2HS
 EC82 3510                    PULS    X
 EC84 301F                    LEAX    -$01,X
 EC86 26EB                    BNE     PBLIN      ; until line finished
 EC88 BDF520                  JSR     PCRLF
 EC8B 39                      RTS
                      ;*
                      ;* Modify RTC non volatile data
 EC8C 0D              MCMES   FCB     $0D
 EC8D 52544320657861          FCC     "RTC examine and alter"
 EC94 6D696E6520616E
 EC9B 6420616C746572
 ECA2 2066726F6D20            FCC     " from "
 ECA8 04                      FCB     $04

 ECA9 8EEC8C          MC      LDX     #MCMES
 ECAC BDF52C                  JSR     PDATA1     ; print header
 ECAF BDF575                  JSR     BYTE       ; input offset
 ECB2 1F89                    TFR     A,B
 ECB4 C43F            MC1     ANDB    #$3F
 ECB6 BDF520                  JSR     PCRLF
 ECB9 F7DF91                  STB     TEMP
 ECBC 8EDF91                  LDX     #TEMP
 ECBF BDF5C1                  JSR     OUT2HS     ; print offset
 ECC2 BDF5F8                  JSR     GETRTC     ; get that byte
 ECC5 B7DF91                  STA     TEMP
 ECC8 8EDF91                  LDX     #TEMP
 ECCB BDF5B7                  JSR     OUT2H      ; and print it
 ECCE BDF16C                  JSR     INCH       ; input a char
 ECD1 8120                    CMPA    #$20       ; was it a space ?
 ECD3 2609                    BNE     MC2
 ECD5 BDF575                  JSR     BYTE       ; yes,input a byte
 ECD8 BDF616                  JSR     PUTRTC     ; put in RTC
 ECDB 5C                      INCB               ; point to next
 ECDC 20D6                    BRA     MC1        ; and jump to it
 ECDE 810D            MC2     CMPA    #$0D       ; was it <cr> ?
 ECE0 2603                    BNE     MC3
 ECE2 5C                      INCB               ; yes,point to next
 ECE3 20CF                    BRA     MC1
 ECE5 812D            MC3     CMPA    #$2D       ; was it a '-' ?
 ECE7 102603F4                LBNE    CONTRL     ; no,exit
 ECEB 5A                      DECB               ; yes,backpeddle 1
 ECEC 20C6                    BRA     MC1
                      ;*
                      ;* Find byte string [There is a BUG in this routine ?]
                      ;*
 ECEE 0D              FIMES   FCB     $0D
 ECEF 46696E64206279          FCC     "Find byte string from"
 ECF6 74652073747269
 ECFD 6E672066726F6D
 ED04 20                      FCC     " "
 ED05 04                      FCB     $04
 ED06 0D0A            EBSMS   FCB     $0D,$0A
 ED08 656E7465722062          FCC     "enter byte string  "
 ED0F 79746520737472
 ED16 696E672020
 ED1B 04                      FCB     $04
                      ;* Get start & end addresses and load the string templet
 ED1C 8EECEE          FI      LDX     #FIMES
 ED1F BDF52C                  JSR     PDATA1
 ED22 BDF56A                  JSR     BADDR      ; input 'from'
 ED25 BFDF94                  STX     YTEMP      ; store it
 ED28 8EE471                  LDX     #TOS
 ED2B BDF52C                  JSR     PDATA1
 ED2E BDF56A                  JSR     BADDR      ; input 'to'
 ED31 BFDF96                  STX     TTO        ; store it
 ED34 8EED06                  LDX     #EBSMS
 ED37 BDF52C                  JSR     PDATA1
 ED3A 8EDE80                  LDX     #BUFFER
 ED3D 5F                      CLRB               ; clr. count
 ED3E BDF575          FI1     JSR     BYTE       ; input a byte
 ED41 A780                    STA     ,X+        ; put in buffer
 ED43 5C                      INCB               ; inc. count
 ED44 BDF16C                  JSR     INCH       ; input a char
 ED47 8120                    CMPA    #$20       ; was it a space ?
 ED49 27F3                    BEQ     FI1        ; yes,get next byte
                      ;* Search for a match with the templet
 ED4B F7DF91                  STB     TEMP       ; length of templet
 ED4E BEDF94                  LDX     YTEMP      ; point to start adr
 ED51 108EDE80                LDY     #BUFFER    ; & start of templet
 ED55 A680            FI2     LDA     ,X+        ; compare charater
 ED57 A1A0                    CMPA    ,Y+
 ED59 2608                    BNE     FI3        ; no match, branch
 ED5B 5A                      DECB               ; end of string ?
 ED5C 26F7                    BNE     FI2        ; no, try next char
 ED5E BDF520                  JSR     PCRLF      ; yes,do CRLF
 ED61 8D11                    BSR     FI5        ; print out result
 ED63 F6DF91          FI3     LDB     TEMP       ; reset count
 ED66 108EDE80                LDY     #BUFFER    ; point to 1st char
 ED6A BCDF96                  CMPX    TTO        ; end of search block ?
 ED6D 2702                    BEQ     FI4        ; yes,exit
                      ;* BUG here. Should LEAX -1,X first...
 ED6F 20E4                    BRA     FI2        ; no,continue search
 ED71 7EF0DF          FI4     JMP     CONTRL
                      ;* Print results (if any)
 ED74 3436            FI5     PSHS    Y,X,D
 ED76 B6DF91                  LDA     TEMP       ; get length of string
 ED79 40                      NEGA
 ED7A 3086                    LEAX    A,X        ; sub.from current adr
 ED7C 1F12                    TFR     X,Y        ; copy to Y
 ED7E 313A                    LEAY    -$06,Y     ; Y points to string-6
 ED80 BFDF92                  STX     XTEMP
 ED83 8EDF92                  LDX     #XTEMP     ; get addr.of string
 ED86 BDF5BF                  JSR     OUT4HS     ; print it
 ED89 1F21                    TFR     Y,X        ; point to string-6
 ED8B C610                    LDB     #$10       ; print out 16 bytes
 ED8D A6A0            FI6     LDA     ,Y+
 ED8F B7DF92                  STA     XTEMP
 ED92 8EDF92                  LDX     #XTEMP
 ED95 BDF5C1                  JSR     OUT2HS
 ED98 5A                      DECB
 ED99 26F2                    BNE     FI6
 ED9B BDF5C3                  JSR     OUTS       ; followed by 2 spaces
 ED9E BDF5C3                  JSR     OUTS
 EDA1 3130                    LEAY    -$10,Y     ; back to string-6
 EDA3 C610                    LDB     #$10       ; now print ascii
 EDA5 A6A0            FI7     LDA     ,Y+
 EDA7 8120                    CMPA    #$20       ; is it printable ?
 EDA9 2C02                    BGE     FI8        ; yes,print it
 EDAB 862E                    LDA     #$2E       ; no,substitute dot
 EDAD BDF16E          FI8     JSR     OUTCH
 EDB0 5A                      DECB
 EDB1 26F2                    BNE     FI7
 EDB3 35B6                    PULS    PC,Y,X,D
                      ;*
                      ;* Set baud Rate
                      ;*
 EDB5 0D              SBMES   FCB     $0D
 EDB6 53657420626175          FCC     "Set baud rate for acia "
 EDBD 64207261746520
 EDC4 666F7220616369
 EDCB 6120
 EDCD 04                      FCB     $04
 EDCE 20626175642072  SBRMS   FCC     " baud rate = "
 EDD5 617465203D20
 EDDB 04                      FCB     $04
 EDDC 20426175642072  EBRNK   FCC     " Baud rate not known."
 EDE3 617465206E6F74
 EDEA 206B6E6F776E2E
 EDF1 04                      FCB     $04

 EDF2 8EEDB5          SB      LDX     #SBMES
 EDF5 BDF52C                  JSR     PDATA1
 EDF8 BDF59A                  JSR     INHEX      ; get acia No
 EDFB 8401                    ANDA    #$01       ; NB.if acia2,A=0
 EDFD B7DF91                  STA     TEMP       ; store it
 EE00 8EEDCE                  LDX     #SBRMS     ; ask for baud rate
 EE03 BDF52C                  JSR     PDATA1
 EE06 BDF16C                  JSR     INCH       ; input first 2 digits
 EE09 1F89                    TFR     A,B        ; (ascii/decimal),of
 EE0B BDF16C                  JSR     INCH       ; reqd.baud rate
 EE0E 1E89                    EXG     A,B        ; put them in order
 EE10 1E02                    EXG     D,Y        ; and store in Y
 EE12 8EEE74                  LDX     #TBAUD     ; use look-up table
 EE15 10AC84          SB1     CMPY    ,X         ; found it ?
 EE18 2710                    BEQ     SB2
 EE1A 3006                    LEAX    $06,X      ; no,try next
 EE1C 8CEECE                  CMPX    #EBAUD
 EE1F 26F4                    BNE     SB1        ; all tried ?
 EE21 8EEDDC                  LDX     #EBRNK     ; yes,error exit
 EE24 BDF52C                  JSR     PDATA1
 EE27 7EF0DF                  JMP     CONTRL
 EE2A A602            SB2     LDA     $02,X      ; print out last 3 digits
 EE2C BDF16E                  JSR     OUTCH      ; of baud rate
 EE2F A603                    LDA     $03,X
 EE31 BDF16E                  JSR     OUTCH
 EE34 A604                    LDA     $04,X
 EE36 BDF16E                  JSR     OUTCH
 EE39 A605                    LDA     $05,X      ; pick-up RTC code and set baud rate
 EE3B 8EFF0C                  LDX     #BAUD      ; select register for
 EE3E F6DF91                  LDB     TEMP       ; nominated acia
 EE41 F7DF92                  STB     XTEMP
 EE44 3A                      ABX
 EE45 A784                    STA     ,X         ; load code
 EE47 B7DF91                  STA     TEMP       ; save code
 EE4A C60F                    LDB     #$0F       ; get existing RTC
 EE4C BDF5F8                  JSR     GETRTC
 EE4F 7DDF92                  TST     XTEMP      ; which acia ?
 EE52 2607                    BNE     SB3        ; acia1,branch
 EE54 84F0                    ANDA    #$F0       ; erase acia2 code
 EE56 BBDF91                  ADDA    TEMP       ; subs. new code
 EE59 2011                    BRA     SB4        ; go put in clock
 EE5B F6DF91          SB3     LDB     TEMP       ; was acia1. get code
 EE5E 58                      ASLB               ; shift into high nibble
 EE5F 58                      ASLB
 EE60 58                      ASLB
 EE61 58                      ASLB
 EE62 C4F0                    ANDB    #$F0
 EE64 840F                    ANDA    #$0F       ; erase acia1 code
 EE66 F7DF91                  STB     TEMP
 EE69 BBDF91                  ADDA    TEMP       ; subs. new code
 EE6C C60F            SB4     LDB     #$0F       ; store in RTC
 EE6E BDF616                  JSR     PUTRTC
 EE71 7EF0DF                  JMP     CONTRL
                      * Look-up table
 EE74 3530202020      TBAUD   FCC     "50   "
 EE79 00                      FCB     $00
 EE7A 3735202020              FCC     "75   "
 EE7F 01                      FCB     $01
 EE80 3131302020              FCC     "110  "
 EE85 02                      FCB     $02
 EE86 3133352020              FCC     "135  "
 EE8B 03                      FCB     $03
 EE8C 3135302020              FCC     "150  "
 EE91 04                      FCB     $04
 EE92 3330302020              FCC     "300  "
 EE97 06                      FCB     $06
 EE98 3630302020              FCC     "600  "
 EE9D 07                      FCB     $07
 EE9E 3132303020              FCC     "1200 "
 EEA3 08                      FCB     $08
 EEA4 3138303020              FCC     "1800 "
 EEA9 09                      FCB     $09
 EEAA 3234303020              FCC     "2400 "
 EEAF 0A                      FCB     $0A
 EEB0 3336303020              FCC     "3600 "
 EEB5 0B                      FCB     $0B
 EEB6 3438303020              FCC     "4800 "
 EEBB 0C                      FCB     $0C
 EEBC 3732303020              FCC     "7200 "
 EEC1 0D                      FCB     $0D
 EEC2 3936303020              FCC     "9600 "
 EEC7 0E                      FCB     $0E
 EEC8 3139323030              FCC     "19200"
 EECD 0F                      FCB     $0F
                      ;*
                      ;* Seems to be not used...
                      ;*
 EECE FF29FFAB0052    EBAUD   FCB     $FF,$29,$FF,$AB,$00,$52  ;EEFE: FF 29 FF AB 00 52 '.)...R'
 EED4 FFA90250FFAB            FCB     $FF,$A9,$02,$50,$FF,$AB  ;EF04: FF A9 02 50 FF AB '...P..'
 EEDA 0012FFAB0210            FCB     $00,$12,$FF,$AB,$02,$10  ;EF0A: 00 12 FF AB 02 10 '......'
 EEE0 FFAB0010FFAB            FCB     $FF,$AB,$00,$10,$FF,$AB  ;EF10: FF AB 00 10 FF AB '......'
 EEE6 0250FFAB0212            FCB     $02,$50,$FF,$AB,$02,$12  ;EF16: 02 50 FF AB 02 12 '.P....'
 EEEC FFAB0050FFA9            FCB     $FF,$AB,$00,$50,$FF,$A9  ;EF1C: FF AB 00 50 FF A9 '...P..'
 EEF2 0252FFAB0050            FCB     $02,$52,$FF,$AB,$00,$50  ;EF22: 02 52 FF AB 00 50 '.R...P'
 EEF8 FFA90212FFAB            FCB     $FF,$A9,$02,$12,$FF,$AB  ;EF28: FF A9 02 12 FF AB '......'
 EEFE 0250FFEB0010            FCB     $02,$50,$FF,$EB,$00,$10  ;EF2E: 02 50 FF EB 00 10 '.P....'
 EF04 FFAB0010FFAB            FCB     $FF,$AB,$00,$10,$FF,$AB  ;EF34: FF AB 00 10 FF AB '......'
 EF0A 0050FF0B0010            FCB     $00,$50,$FF,$0B,$00,$10  ;EF3A: 00 50 FF 0B 00 10 '.P....'
 EF10 0000FBFF0000            FCB     $00,$00,$FB,$FF,$00,$00  ;EF40: 00 00 FB FF 00 00 '......'
 EF16 FBFF0000FBFF            FCB     $FB,$FF,$00,$00,$FB,$FF  ;EF46: FB FF 00 00 FB FF '......'
 EF1C 0000FBFF0000            FCB     $00,$00,$FB,$FF,$00,$00  ;EF4C: 00 00 FB FF 00 00 '......'
 EF22 FBFF0000FFFF            FCB     $FB,$FF,$00,$00,$FF,$FF  ;EF52: FB FF 00 00 FF FF '......'
 EF28 0000FBFF0000            FCB     $00,$00,$FB,$FF,$00,$00  ;EF58: 00 00 FB FF 00 00 '......'
 EF2E FFFF0000FBFF            FCB     $FF,$FF,$00,$00,$FB,$FF  ;EF5E: FF FF 00 00 FB FF '......'
 EF34 0000FFFF0000            FCB     $00,$00,$FF,$FF,$00,$00  ;EF64: 00 00 FF FF 00 00 '......'
 EF3A FBFF0000FBFF            FCB     $FB,$FF,$00,$00,$FB,$FF  ;EF6A: FB FF 00 00 FB FF '......'
 EF40 0000FFFF0000            FCB     $00,$00,$FF,$FF,$00,$00  ;EF70: 00 00 FF FF 00 00 '......'
 EF46 FBFF0000FFFF            FCB     $FB,$FF,$00,$00,$FF,$FF  ;EF76: FB FF 00 00 FF FF '......'
 EF4C 0800FFFFA9FF            FCB     $08,$00,$FF,$FF,$A9,$FF  ;EF7C: 08 00 FF FF A9 FF '......'
 EF52 1000A9FF5000            FCB     $10,$00,$A9,$FF,$50,$00  ;EF82: 10 00 A9 FF 50 00 '....P.'
 EF58 ABFF1000A9FD            FCB     $AB,$FF,$10,$00,$A9,$FD  ;EF88: AB FF 10 00 A9 FD '......'
 EF5E 5000A9FF5000            FCB     $50,$00,$A9,$FF,$50,$00  ;EF8E: 50 00 A9 FF 50 00 'P...P.'
 EF64 A9FF5200A9FF            FCB     $A9,$FF,$52,$00,$A9,$FF  ;EF94: A9 FF 52 00 A9 FF '..R...'
 EF6A 5200A9FD5002            FCB     $52,$00,$A9,$FD,$50,$02  ;EF9A: 52 00 A9 FD 50 02 'R...P.'
 EF70 A9FF1200A9FD            FCB     $A9,$FF,$12,$00,$A9,$FD  ;EFA0: A9 FF 12 00 A9 FD '......'
 EF76 1002A9FF5000            FCB     $10,$02,$A9,$FF,$50,$00  ;EFA6: 10 02 A9 FF 50 00 '....P.'
 EF7C A9FD5002A1FF            FCB     $A9,$FD,$50,$02,$A1,$FF  ;EFAC: A9 FD 50 02 A1 FF '..P...'
 EF82 5200A9FD1202            FCB     $52,$00,$A9,$FD,$12,$02  ;EFB2: 52 00 A9 FD 12 02 'R.....'
 EF88 A9FF5200A9FD            FCB     $A9,$FF,$52,$00,$A9,$FD  ;EFB8: A9 FF 52 00 A9 FD '..R...'
 EF8E 52020000FFFF            FCB     $52,$02,$00,$00,$FF,$FF  ;EFBE: 52 02 00 00 FF FF 'R.....'
 EF94 0000FFFB0000            FCB     $00,$00,$FF,$FB,$00,$00  ;EFC4: 00 00 FF FB 00 00 '......'
 EF9A FFFB0000FFFB            FCB     $FF,$FB,$00,$00,$FF,$FB  ;EFCA: FF FB 00 00 FF FB '......'
 EFA0 0000FFFB0000            FCB     $00,$00,$FF,$FB,$00,$00  ;EFD0: 00 00 FF FB 00 00 '......'
 EFA6 FFFB0000FFFB            FCB     $FF,$FB,$00,$00,$FF,$FB  ;EFD6: FF FB 00 00 FF FB '......'
 EFAC 0000FFFB0000            FCB     $00,$00,$FF,$FB,$00,$00  ;EFDC: 00 00 FF FB 00 00 '......'
 EFB2 FFFF0000FFFB            FCB     $FF,$FF,$00,$00,$FF,$FB  ;EFE2: FF FF 00 00 FF FB '......'
 EFB8 0000FFFB0000            FCB     $00,$00,$FF,$FB,$00,$00  ;EFE8: 00 00 FF FB 00 00 '......'
 EFBE FFFB0000FFFB            FCB     $FF,$FB,$00,$00,$FF,$FB  ;EFEE: FF FB 00 00 FF FB '......'
 EFC4 0008FFFB0000            FCB     $00,$08,$FF,$FB,$00,$00  ;EFF4: 00 08 FF FB 00 00 '......'
 EFCA FFFF0038FFC9            FCB     $FF,$FF,$00,$38,$FF,$C9  ;EFFA: FF FF 00 38 FF C9 '...8..'
                      ;*
                      ;* Wait 1ms routine
                      ;* Input A = number of ms to wait
 EFD0 C6C8            WAIT1MS LDB     #200
 EFD2 5A              LOOPW   DECB
 EFD3 26FD                    BNE     LOOPW
 EFD5 4A                      DECA
 EFD6 26F8                    BNE     WAIT1MS
 EFD8 39                      RTS
                      ;*
                      ;*
                             ORG   PROM+$1000
                      ;*
                      ;*
                      ;********************************************
                      ;* Table of jump addresses for subroutines. *
                      ;* To use these subroutines use the         *
                      ;* indirect jump to subroutine thus:-       *
                      ;*        DELAY EQU $F014                   *
                      ;*        JSR [DELAY]                       *
                      ;********************************************
 F000 F08E                   FDB   RESET        ; Cold start.
 F002 F0DF                   FDB   CONTRL       ; Warm  start.
 F004 F153                   FDB   INCH1        ; Input char without an echo.
 F006 F16C                   FDB   INCH         ; Input char.
 F008 F131                   FDB   STATUS       ; Check for char.
 F00A F16E                   FDB   OUTCH        ; Output char.
 F00C F52C                   FDB   PDATA1       ; Print string terminated by hex(04).
 F00E F520                   FDB   PCRLF        ; Print a cr followed by a lf.
 F010 F533                   FDB   PSTRNG       ; PCRLF followed by PDATA1.
 F012 F130                   FDB   DUMMY        ; No init code.
 F014 F550                   FDB   DELAY        ; Delay for (XREG) m/S.
 F016 F56A                   FDB   BADDR        ; Get a four digit hex address into X.
 F018 F575                   FDB   BYTE         ; Get a two hex digit number into A.
 F01A F59A                   FDB   INHEX        ; Get a one digit hex char into A.
 F01C F5B7                   FDB   OUT2H        ; Output two hex chars pointed to by X.
 F01E F5C1                   FDB   OUT2HS       ; OUT2H plus a space.
 F020 F5BF                   FDB   OUT4HS       ; Output four hex chars etc.
 F022 F58B                   FDB   OUTHR        ; Output right hex digit in A.
 F024 F587                   FDB   OUTHL        ; Output left hex digit in A.
 F026 F5C3                   FDB   OUTS         ; Output a space.
 F028 F5C8                   FDB   RANDOM       ; Returns a random number in the range 0-255.
 F02A F538                   FDB   PRINTA       ; Output the contents of A.
 F02C F544                   FDB   PRINTX       ; Output the contents of X.
 F02E F4B0                   FDB   READ         ; Read sector routine.
 F030 F4B4                   FDB   WRITE        ; Write sector routine.
 F032 F4B8                   FDB   VERIFY       ; Verify sector routine.
 F034 F4BC                   FDB   RST          ; Restore to track 00.
 F036 F4C5                   FDB   DRV          ; Drive select.
 F038 F4F5                   FDB   CHKRDY       ; Check for drive ready.
 F03A F4F9                   FDB   QUICK        ; Quick check for drive ready.
 F03C F4FD                   FDB   DINIT        ; Drive cold start.
 F03E F515                   FDB   WARM         ; Drive warm start.
 F040 F519                   FDB   SEEK         ; Seek to track.
                      ;*************************************
                      ;* Extra FDB'S for system dependant  *
                      ;* subroutines fit here.             *
                      ;*************************************
                      ;* LIB FDB
 F042 F5EB                   FDB   GETTIM
 F044 F609                   FDB   PUTTIM
 F046 F5F8                   FDB   GETRTC
 F048 F616                   FDB   PUTRTC
 F04A F62B                   FDB   BEEP
 F04C F64F                   FDB   GCOM
 F04E F661                   FDB   GPRM
 F050 F670                   FDB   GPRMI
 F052 F67B                   FDB   MASK
 F054 F68D                   FDB   SETPEN
 F056 F6A4                   FDB   SETPAT
 F058 F6B7                   FDB   FIGSF
 F05A F6DC                   FDB   FIGSG
 F05C F705                   FDB   SETPAR
 F05E F769                   FDB   SETCRG
 F060 F7C0                   FDB   GETCRG
 F062 FA76                   FDB   SETCRT
 F064 FA93                   FDB   GETCRT
 F066 F80A                   FDB   OFF
 F068 F816                   FDB   ON
 F06A F822                   FDB   GRAPH
 F06C FAB2                   FDB   TEXT
 F06E F83D                   FDB   MODE
 F070 F854                   FDB   ZOOM
 F072 F86B                   FDB   FILL
 F074 F8AC                   FDB   CLEARX
 F076 F88A                   FDB   CLEAR
 F078 FAD0                   FDB   CLEART
 F07A F8E1                   FDB   GDCINI
 F07C FB2A                   FDB   VIDCH
 F07E F18D                   FDB   INKEY
 F080 F92D                   FDB   POINT
 F082 F939                   FDB   LINE
 F084 F9B9                   FDB   RECT
 F086 F9E6                   FDB   CIRCLE
 F088 FA37                   FDB   ARC
 F08A FAFF                   FDB   CLINK
 F08C F757                   FDB   VSYNC
                      ;*
                      ;**************************************
                      ;* Start of monitor  Entered on reset *
                      ;**************************************
                      ;*
 F08E B7FFDD          RESET  STA   $FFDD         ; Set up SAM for 64k dynamic ram.
 F091 B7FFDF                 STA   $FFDF         ; Set up SAM for map type 1.
                      ;*
 F094 B6DF9C                 LDA   WARMS
 F097 81AA                   CMPA  #$AA          ; Test for power down.
 F099 2718                   BEQ   U1
                      ;*
 F09B 4F                     CLRA
 F09C 8EDF80                 LDX   #SCRAT
 F09F A780            L1     STA   ,X+           ; Clear out scratch storage.
 F0A1 8CE000                 CMPX   #(RAM+512)
 F0A4 26F9                   BNE   L1
 F0A6 86AA                   LDA   #$AA
 F0A8 B7DF9C                 STA   WARMS
                      ;*
 F0AB 10CEDE6F               LDS   #SSTACK       ; Set initial stack pointer.
 F0AF 10FFDF80               STS   STACK         ; Same for user stack location.
                      ;*
 F0B3 108EF111        U1     LDY   #UNEXP
 F0B7 8EDF82                 LDX   #NMIV
 F0BA 10AF81          U1L    STY   ,X++
 F0BD 8CDF8C                 CMPX  #NMIV+10
 F0C0 26F8                   BNE   U1L
                      ;*
                      ;***********************************
                      ;* System dependant init code goes *
                      ;* here. It should set the initial *
                      ;* input and output ports then     *
                      ;* check for auto boot.            *
                      ;***********************************
                      ;* LIB MINIT1
                      ;*
 F0C2 864F                   LDA   #$4F
 F0C4 B7FF02                 STA   SYSREG        ; set DDRA
 F0C7 863C                   LDA   #$3C          ; Hi-nib=in
 F0C9 B7FF03                 STA   SYSREG+1      ; Lo-nib=out
 F0CC 8634                   LDA   #$34
 F0CE B7FF01                 STA   PIA1+1        ; setup keyboard port
 F0D1 8606                   LDA   #$06          ; set Drv 0,SD,and
 F0D3 B7FF02                 STA   SYSREG        ; Rom at $E000
 F0D6 7EE0E9                 JMP   MINIT1        ; do rest of setup
                      ;* (jump back here)
 F0D9 8EE000          MINITR LDX   #HDR          ; Print header after reset.
 F0DC BDF52C                 JSR   PDATA1
                      ;* Action control (Warm start entry)
 F0DF B6FF02          CONTRL LDA   SYSREG
 F0E2 8A04                   ORA   #4            ; Map in bottom 4k of eprom.
 F0E4 B7FF02                 STA   SYSREG
 F0E7 8EE025                 LDX   #PROMPT
 F0EA BDF52C                 JSR   PDATA1
 F0ED 8D7D                   BSR   INCH          ; Get two byte command into Y.
 F0EF 1F89                   TFR   A,B
 F0F1 8D79                   BSR   INCH
 F0F3 1E89                   EXG   A,B
 F0F5 1F02                   TFR   D,Y
 F0F7 8EE1FD          PARSE  LDX   #COMTAB       ; Point to start of command table.
 F0FA 10AC81          NEXT   CMPY  ,X++          ; Look for match.
 F0FD 2602                   BNE   NOPE          ; No match.
 F0FF 6E94                   JMP   [,X]          ; Found it, so jump to routine.
 F101 3002            NOPE   LEAX  2,X           ; If no match then jump over address.
 F103 A684                   LDA   ,X            ; Check for end of table.
 F105 81FF                   CMPA  #$FF
 F107 26F1                   BNE   NEXT          ; If not the end then try next entry.
 F109 8EE02A          WHAT   LDX   #NOTTHS       ; No match so print message.
 F10C BDF52C                 JSR   PDATA1
 F10F 20CE                   BRA   CONTRL
                      *
 F111 8EE03E          UNEXP  LDX   #UNMESS       ; Unexpected interrupt ... Don't Panic!
 F114 BDF533                 JSR   PSTRNG
 F117 1A50                   ORCC  #%01010000    ; Set interupt masks.
 F119 7EF08E                 JMP   RESET
                      ;*
                      ;* Interrupt vector routines.
                      ;*
 F11C 6E9FDF82        NMI    JMP   [NMIV]
 F120 6E9FDF84        IRQ    JMP   [IRQV]
 F124 6E9FDF86        FIRQ   JMP   [FIRQV]
 F128 6E9FDF88        SWI2   JMP   [SWI2V]
 F12C 6E9FDF8A        SWI3   JMP   [SWI3V]
                      ;* No action goes here
 F130 39              DUMMY  RTS
                      ;*
                      ;*****************************************************
                      ;* Console drivers                                   *
                      ;* ---------------                                   *
                      ;* The system dependant code for the console drivers *
                      ;* fits here. The entries in the jump tables INITAB  *
                      ;* INTAB,OUTTAB and STATAB should be changed to suit *
                      ;* these routines. For a description of the drivers  *
                      ;* for an 6850 acia see section 3 of the general     *
                      ;* Flex adaptation guide (pp6-8).                    *
                      ;*****************************************************
                      ;*
                      ;* LIB CONSOLE
                      ;*
                      ;* Check for character
 F131 3416            STATUS  PSHS    X,D
 F133 7DDF8D                  TST     OPORT      ; video monitor ?
 F136 2610                    BNE     STAT2      ; no,skip flash routine
 F138 BEDFFD                  LDX     FLASH      ; used here as counter
 F13B 2606                    BNE     STAT1      ; if <> 0,go decrement
 F13D BDFB58                  JSR     FLCUR      ; else toggle cursor
 F140 8E0FA0                  LDX     #$0FA0     ; & reset counter
 F143 301F            STAT1   LEAX    -$01,X
 F145 BFDFFD                  STX     FLASH
 F148 8EF187          STAT2   LDX     #TQINT
 F14B F6DF8C                  LDB     IPORT
 F14E 58                      ASLB
 F14F AD95                    JSR     [B,X]      ; check for interrupt
 F151 3596                    PULS    PC,X,D     ; Z=1 if no interrupt
                      ;* Input char without echo
 F153 3414            INCH1   PSHS    X,B
 F155 8DDA            INC1    BSR     STATUS     ; wait for interrupt
 F157 27FC                    BEQ     INC1
 F159 7DDFFF                  TST     BLANKD     ; cursor blanked ?
 F15C 2703                    BEQ     INC2       ; no,skip
 F15E BDFB58                  JSR     FLCUR      ; yes,toggle again
 F161 8EF17B          INC2    LDX     #TABIN
 F164 F6DF8C                  LDB     IPORT
 F167 58                      ASLB
 F168 AD95                    JSR     [B,X]      ; get char.into ACCA
 F16A 3594                    PULS    PC,X,B
                      ;* Input character
 F16C 8DE5            INCH    BSR     INCH1
                      ;* Output character
 F16E 3414            OUTCH   PSHS    X,B
 F170 8EF181                  LDX     #TABOUT
 F173 F6DF8D                  LDB     OPORT
 F176 58                      ASLB
 F177 AD95                    JSR     [B,X]
 F179 3594                    PULS    PC,X,B
                      ;* Console I/O function table
 F17B F18D            TABIN   FDB     INKEY
 F17D F193                    FDB     GETA1
 F17F F199                    FDB     GETA2
 F181 F19F            TABOUT  FDB     PUTVID
 F183 F1A2                    FDB     PUTA1
 F185 F1AD                    FDB     PUTA2
 F187 F1B8            TQINT   FDB     QINT0
 F189 F1BE                    FDB     QINT1
 F18B F1C4                    FDB     QINT2
                      ;* Get char from keyboard
 F18D B6FF00          INKEY   LDA     PIA1
 F190 847F                    ANDA    #$7F
 F192 39                      RTS
                      ;* Get char from acia port 1
 F193 B6FF08          GETA1   LDA     ACIA1
 F196 847F                    ANDA    #$7F
 F198 39                      RTS
                      ;* Get char from acia port 2
 F199 B6FF04          GETA2   LDA     ACIA2
 F19C 847F                    ANDA    #$7F
 F19E 39                      RTS
                      ;* Send char to video
 F19F 7EFB2A          PUTVID  JMP     VIDCH
                      ;* Send char to acia port 1
 F1A2 F6FF09          PUTA1   LDB     ACIA1+1    ; check status
 F1A5 C501                    BITB    #$01       ; TX ready ?
 F1A7 27F9                    BEQ     PUTA1      ; no,wait
 F1A9 B7FF08                  STA     ACIA1      ; yes,send char
 F1AC 39                      RTS
                      ;* Send char to acia port 2
 F1AD F6FF05          PUTA2   LDB     ACIA2+1
 F1B0 C501                    BITB    #$01
 F1B2 27F9                    BEQ     PUTA2
 F1B4 B7FF04                  STA     ACIA2
 F1B7 39                      RTS
                      ;* Check for interrupt, port 0 (keyboard)
 F1B8 B6FF01          QINT0   LDA     PIA1+1
 F1BB 8580                    BITA    #$80       ; test flag
 F1BD 39                      RTS                ; if not,Z=1
                      ;* Check for interrupt, port 1 (acia 1)
 F1BE B6FF09          QINT1   LDA     ACIA1+1
 F1C1 8402                    ANDA    #$02
 F1C3 39                      RTS
                      ;* Check for interrupt, port 2 (acia 2)
 F1C4 B6FF05          QINT2   LDA     ACIA2+1
 F1C7 8402                    ANDA    #$02
 F1C9 39                      RTS
                      ;*
                      ;* Disc drive vector table (1 read, 2 write, 3 verify,
                      ;* 4 reset, 5 select, 6 check, 7 quick, 8 init, 9 warm, 10 seek)
                      ;*
 F1CA F231            TABSRT  FDB     RDFLP      ; floppy drive 0
 F1CC F272                    FDB     WRFLP
 F1CE F2A3                    FDB     VRFLP
 F1D0 F2AE                    FDB     RSFLP
 F1D2 F2FC                    FDB     SELD0
 F1D4 F336                    FDB     NVC0Z1
 F1D6 F336                    FDB     NVC0Z1
 F1D8 F336                    FDB     NVC0Z1
 F1DA F336                    FDB     NVC0Z1
 F1DC F2C4                    FDB     SKFLP

 F1DE F231                    FDB     RDFLP      ; floppy drive 1
 F1E0 F272                    FDB     WRFLP
 F1E2 F2A3                    FDB     VRFLP
 F1E4 F2AE                    FDB     RSFLP
 F1E6 F306                    FDB     SELD1
 F1E8 F336                    FDB     NVC0Z1
 F1EA F336                    FDB     NVC0Z1
 F1EC F336                    FDB     NVC0Z1
 F1EE F336                    FDB     NVC0Z1
 F1F0 F2C4                    FDB     SKFLP

 F1F2 F3FB                    FDB     RDDT2      ; Disk typ 2
 F1F4 F415                    FDB     WRDT2      ; 2 is master CF
 F1F6 F336                    FDB     NVC0Z1     ; 3 is slave CF
 F1F8 F367                    FDB     DRVDT2
 F1FA F367                    FDB     DRVDT2
 F1FC F43E                    FDB     CHKDT2
 F1FE F336                    FDB     NVC0Z1
 F200 F45F                    FDB     INIDT2
 F202 F336                    FDB     NVC0Z1
 F204 F336                    FDB     NVC0Z1

 F206 F3FB                    FDB     RDDT2      ; Disk typ 3
 F208 F415                    FDB     WRDT2      ; 2 is master CF
 F20A F336                    FDB     NVC0Z1     ; 3 is slave CF
 F20C F367                    FDB     DRVDT2
 F20E F367                    FDB     DRVDT2
 F210 F43E                    FDB     CHKDT2
 F212 F336                    FDB     NVC0Z1
 F214 F45F                    FDB     INIDT2
 F216 F336                    FDB     NVC0Z1
 F218 F336                    FDB     NVC0Z1

                      ;*
                      ;* DISC I/O
                      ;*
                      ;* Query FDC busy status
 F21A F6FF10          QBUSY   LDB     COMREG     ; get status register
 F21D C501                    BITB    #$01       ; inspect bit 0
 F21F 26F9                    BNE     QBUSY      ; if busy, wait
 F221 39                      RTS

                      * Load FDC command
 F222 8DF6            FCMD    BSR     QBUSY      ; wait until ready
 F224 B7FF10                  STA     COMREG     ; load command

                      ;* Twiddle your thumbs for 100 micro-Secs
 F227 170000          PAUSE   LBSR    PAUS1
 F22A 170000          PAUS1   LBSR    PAUS2
 F22D 170000          PAUS2   LBSR    PAUS3
 F230 39              PAUS3   RTS

                      ;* Read a sector from floppy drive 0/1
 F231 170090          RDFLP   LBSR    SKFLP      ; seek track/sector
 F234 86FF                    LDA     #$FF       ; set DP = $FF
 F236 1E8B                    EXG     A,DP
 F238 3402                    PSHS    A          ; save old DP
 F23A 8684                    LDA     #$84       ; read sector cmd
 F23C 8DE4                    BSR     FCMD       ; load command
 F23E 5F                      CLRB
 F23F 9610            RDFL1   LDA     <COMREG    ; COMREG (status)
 F241 8502                    BITA    #$02       ; data reg full ?
 F243 260C                    BNE     RDFL3      ; yes,branch
 F245 8501                    BITA    #$01       ; cmd executed ?
 F247 26F6                    BNE     RDFL1      ; no,wait
 F249 200F                    BRA     RDFL4
 F24B 9610            RDFL2   LDA     <COMREG    ; status
 F24D 8506                    BITA    #$06       ; ready ?
 F24F 27FA                    BEQ     RDFL2      ; no,wait
 F251 9613            RDFL3   LDA     <DATREG    ; data reg
 F253 A780                    STA     ,X+
 F255 5A                      DECB               ; last byte done ?
 F256 26F3                    BNE     RDFL2      ; no,continue
 F258 20E5                    BRA     RDFL1      ; yes,check status
 F25A 1F89            RDFL4   TFR     A,B        ; ACCB = status
 F25C 3502                    PULS    A          ; restore DP
 F25E 1E8B                    EXG     A,DP
 F260 C510                    BITB    #$10       ; record found ?
 F262 270B                    BEQ     RDFL5      ; yes,exit
 F264 B6FF02                  LDA     SYSREG     ; no,toggle DEN
 F267 8802                    EORA    #$02
 F269 B7FF02                  STA     SYSREG
 F26C 73DFF4                  COM     DEN        ; toggle DEN
 F26F C41C            RDFL5   ANDB    #$1C       ; Z=1 if no error
 F271 39                      RTS

                      ;* Write a sector to floppy drive 0/1
 F272 8D50            WRFLP   BSR     SKFLP      ; seek track/sector
 F274 86FF                    LDA     #$FF       ; change DP
 F276 1E8B                    EXG     A,DP
 F278 3402                    PSHS    A          ; save old DP
 F27A 86A4                    LDA     #$A4       ; write sector cmd
 F27C 8DA4                    BSR     FCMD       ; load cmd
 F27E 5F                      CLRB
 F27F 9610            WRFL1   LDA     <COMREG    ; get status
 F281 8502                    BITA    #$02       ; data reg.empty ?
 F283 260C                    BNE     WRFL3      ; yes,branch
 F285 8501                    BITA    #$01       ; busy ?
 F287 26F6                    BNE     WRFL1      ; yes,wait
 F289 200F                    BRA     WRFL4      ; else,branch
 F28B 9610            WRFL2   LDA     <COMREG    ; check status
 F28D 8506                    BITA    #$06       ; ready ?
 F28F 27FA                    BEQ     WRFL2      ; no,wait
 F291 A680            WRFL3   LDA     ,X+        ; send byte
 F293 9713                    STA     <DATREG
 F295 5A                      DECB               ; all done ?
 F296 26F3                    BNE     WRFL2      ; no,continue
 F298 20E5                    BRA     WRFL1      ; yes,check status
 F29A 1F89            WRFL4   TFR     A,B        ; put status in B
 F29C 3502                    PULS    A          ; restore DP
 F29E 1E8B                    EXG     A,DP
 F2A0 C45C                    ANDB    #$5C       ; test status
 F2A2 39                      RTS                ; Z=1 if no error

                      ;* Verify a sector on floppy drive 0/1
 F2A3 8684            VRFLP   LDA     #$84       ; (read sector cmd)
 F2A5 17FF7A                  LBSR    FCMD       ; load cmd
 F2A8 17FF6F                  LBSR    QBUSY      ; wait 'till finished
 F2AB C418                    ANDB    #$18
 F2AD 39                      RTS                ; Z=1 if no error

                      ;* Restore to track 00 floppy drive 0/1
 F2AE B6FF02          RSFLP   LDA     SYSREG
 F2B1 8A02                    ORA     #$02       ; set single density
 F2B3 B7FF02                  STA     SYSREG
 F2B6 8600                    LDA     #$00       ; restore cmd
 F2B8 BBDFF6                  ADDA    STEP       ; adjust for step rate
 F2BB 17FF64                  LBSR    FCMD       ; load cmd
 F2BE 17FF59                  LBSR    QBUSY      ; wait 'till finished
 F2C1 C458                    ANDB    #$58
 F2C3 39                      RTS                ; z=1 if no error

                      ;* Seek to track/sector floppy drive 0/1
 F2C4 F7FF12          SKFLP   STB     COMREG+2   ; rqud. sector
 F2C7 B7FF13                  STA     DATREG     ; reqd. track
 F2CA B6FF02                  LDA     SYSREG
 F2CD 7DDFF4                  TST     DEN        ; double density ?
 F2D0 270B                    BEQ     SDEN       ; no,set single
 F2D2 7DFF13                  TST     DATREG     ; yes,set double except if
 F2D5 2706                    BEQ     SDEN       ; track 0 => single density
 F2D7 84FD                    ANDA    #$FD
 F2D9 C112                    CMPB    #$12       ; sector/track
 F2DB 2004                    BRA     DDEN
 F2DD 8A02            SDEN    ORA     #$02       ; single density
 F2DF C10A                    CMPB    #$0A       ; sector/track
 F2E1 2F04            DDEN    BLE     SKFL1
 F2E3 84BF                    ANDA    #$BF
 F2E5 2002                    BRA     SKFL2
 F2E7 8A40            SKFL1   ORA     #$40
 F2E9 B7FF02          SKFL2   STA     SYSREG
 F2EC 8610                    LDA     #$10       ; seek sector cmd
 F2EE BBDFF6                  ADDA    STEP       ; adjusted for step rate
 F2F1 17FF2E                  LBSR    FCMD       ; load cmd
 F2F4 17FF23                  LBSR    QBUSY      ; wait 'till finished
 F2F7 C510                    BITB    #$10       ; check status
 F2F9 16FF2B                  LBRA    PAUSE      ; exit via pause

                      ;* Select floppy drive 0
 F2FC B6FF02          SELD0   LDA     SYSREG
 F2FF 84FE                    ANDA    #$FE       ; set DRV 0
 F301 F6DFF7                  LDB     SPEED
 F304 2008                    BRA     SETD

                      ;* Select floppy drive 1
 F306 B6FF02          SELD1   LDA     SYSREG
 F309 8A01                    ORA     #$01
 F30B F6DFF8                  LDB     TSTEP
 F30E B7FF02          SETD    STA     SYSREG
 F311 F7DFF6                  STB     STEP
 F314 E603                    LDB     $03,X      ; get drive No
 F316 F1DFB6                  CMPB    CURDRV     ; same as current ?
 F319 271B                    BEQ     NVC0Z1     ; yes,branch
 F31B F7DFB6                  STB     CURDRV     ; else,update current
 F31E B6FF11                  LDA     COMREG+1   ; set TRACK & DEN
 F321 F6DF8F                  LDB     TRACK
 F324 B7DF8F                  STA     TRACK
 F327 F7FF11                  STB     COMREG+1
 F32A B6DFF4                  LDA     DEN
 F32D F6DFF5                  LDB     DEN1
 F330 B7DFF5                  STA     DEN1
 F333 F7DFF4                  STB     DEN

                      ;* Return with N,V,C clear, Z set
                      ;* No error
 F336 5F              NVC0Z1  CLRB
 F337 5D                      TSTB
 F338 1CFE                    ANDCC   #$FE
 F33A 39                      RTS

                      ;* Return with N,V,Z clear, C set
                      ;* Error
 F33B C640            NVZ0C1  LDB     #$40
 F33D 5D                      TSTB
 F33E 1A01                    ORCC    #$01
 F340 39                      RTS

                      ;* Set DP to $FF,speed to fast
 F341 1E8B            FAST    EXG     A,DP       ; save present DP
 F343 B7DFFC                  STA     REGDP
 F346 86FF                    LDA     #$FF       ; set DP = $FF
 F348 1E8B                    EXG     A,DP
 F34A B7FFD9                  STA     SET_R1     ; set Fast speed
 F34D 39                      RTS

                      ;* Restore DP,speed to slow
 F34E B6DFFC          SLOW    LDA     REGDP      ; restore former DP
 F351 1E8B                    EXG     A,DP
 F353 7DDFF9                  TST     PSPEED     ; test current speed
 F356 260E                    BNE     SLOW2
 F358 B7FFD7                  STA     SET_R0     ; set slow speed
 F35B B7FFD8                  STA     CLR_R1
 F35E 7D0000                  TST     >$0000
 F361 21EB                    BRN     SLOW
 F363 B7FFD6                  STA     CLR_R0
 F366 39              SLOW2   RTS

                      ;* =====================================================================
                      ;* VARIOUS IDE / 8255 DISK ROUTINES
                      ;* =====================================================================

                      ;*
                      ;* Select master / slave CF
 F367 3412            DRVDT2      PSHS    A,X
 F369 7DDE7E                      TST     MSTCFOK             ; check if master cf present ?
 F36C 271B                        BEQ     DRVERR              ; no exit with error
 F36E A603                        LDA     3,X                 ; get Flex disk number
 F370 8EDF9D                      LDX     #DDSTAB
 F373 E686                        LDB     A,X                 ; get physical disk number
 F375 86E0                        LDA     #LBA3MST            ; master cf by default
 F377 C102                        CMPB    #$02                ; master asked ?
 F379 2707                        BEQ     ENDDRVDT2           ; yes exit ok
 F37B 7DDE7F                      TST     SLVCFOK             ; if not master then its slave - present ?
 F37E 2709                        BEQ     DRVERR              ; no exit with error
 F380 86F0                        LDA     #LBA3SLV

 F382 B7DE7D          ENDDRVDT2   STA     LBA3                ; update LBA3 in ram
 F385 8DAF                        BSR     NVC0Z1              ; no error
 F387 3592                        PULS    A,X,PC

 F389 8DB0            DRVERR      BSR     NVZ0C1              ; error
 F38B 3592                        PULS    A,X,PC
                      ;*
                      ;* Compute lba number from flex track/sector
                      ;* Check if flex disk number stored at 3,x is master ($02) or slave ($03) cf
                      ;* and set cf master or slave select bit in lba3 accordingly
                      ;*
                      ;* The cf disk is assumed to be 122 tracks (00$ to $79) of 256 sectors ($00 to $ff)
                      ;* This is a 15990784 bytes disk in 31232 lba of 512 bytes
                      ;*
                      ;* A*256+B IS SAME AS PUT REG A INTO MSB OF A WORD THEN ADD REG B
                      ;* SO REG A CAN BE DIRECTLY USED AS LBA1 AND REG B AS LBA0
                      ;
                      ;* Input : A = flex track
                      ;*         B = flex sector
                      ;*         X = flex fcb address
                      ;*
                      ;* Output : lba0 and lba1 updated in ram storage zone
 F38D B7DE7B          SETLBA      STA     LBA1                ; store lba in table
 F390 F7DE7A                      STB     LBA0                ; fall into transfer routine
                      ;*
                      ;* Transfer params table from memory to cf
                      ;* and enable data
 F393 3436            TFRPARM     PSHS    A,B,X,Y
 F395 8EDE7E                      LDX     #LBA3+1             ; load table address + 1
 F398 108E000E                    LDY     #IDE_LBA3           ; load 1st cf register to write

 F39C 8D18            PARMLOP     BSR     CMDWAIT
 F39E 1F20                        TFR     Y,D                 ; get Y lsb into B
 F3A0 A682                        LDA     ,-X                 ; with pre decr load param from table
 F3A2 8D26                        BSR     WRT_IDE             ; write param in cf
 F3A4 313F                        LEAY    -1,Y                ; change cf register
 F3A6 108C0008                    CMPY    #IDE_SET_FEAT-1     ; check if 6 params loaded in cf
 F3AA 26F0                        BNE     PARMLOP             ; if 6 params not loaded do again

 F3AC 8D08                        BSR     CMDWAIT
 F3AE 86EF                        LDA     #IDE_CMD_SET_FEAT   ; now enable features
 F3B0 C60F                        LDB     #IDE_COMMAND
 F3B2 8D16                        BSR     WRT_IDE
 F3B4 35B6                        PULS    A,B,X,Y,PC
                      ;*
                      ;* Check cf error status
                      ;CFERR       LDB     #IDE_STATUS         ; ask status register
                      ;            BSR     READ_IDE
                      ;            BITA    #ERRBIT             ; read error bit
                      ;            RTS                         ; return with z clear if error
                      ;*
                      ;* Wait cf card command ready
 F3B6 8D09            CMDWAIT     BSR     DATWAIT             ; wait data ready
 F3B8 C60F            CWLOOP      LDB     #IDE_STATUS         ; ask status register
 F3BA 8D26                        BSR     READ_IDE
 F3BC 8540                        BITA    #RDYBIT             ; read ready bit
 F3BE 27F8                        BEQ     CWLOOP              ; wait ready bit set
 F3C0 39                          RTS
                      ;*
                      ;* Wait cf card data ready with time out
 F3C1 C60F            DATWAIT     LDB     #IDE_STATUS         ; ask status register
 F3C3 8D1D                        BSR     READ_IDE            ; A receive status register
 F3C5 8580                        BITA    #BSYBIT             ; read busy bit
 F3C7 26F8                        BNE     DATWAIT             ; not clear ? yes do again
 F3C9 39                          RTS
                      ;*
                      ;* Do a one byte write cycle to ide
                      ;* B = cf register where to write
                      ;* A = byte to write
 F3CA 3402            WRT_IDE     PSHS    A
 F3CC 8680                        LDA     #WR_IDE_8255        ; set 8255 A/B/C for output
 F3CE B7FF1F                      STA     PORTCTRL
 F3D1 3502                        PULS    A
 F3D3 B7FF1C                      STA     PORTA               ; prepare lsb on output d0-d7
 F3D6 F7FF1E                      STB     PORTC               ; set cf register address
 F3D9 CA20                        ORB     #IDE_WR             ; assert wr line
 F3DB F7FF1E                      STB     PORTC
 F3DE C820                        EORB    #IDE_WR             ; prepare for release wr line
 F3E0 2012                        BRA     ENDIDERW
                      ;*
                      ;* Do a one byte read cycle from ide
                      ;* B = cf register to read
                      ;* A = byte read
 F3E2 8692            READ_IDE    LDA     #RD_IDE_8255        ; set 8255 A/B for input C for output
 F3E4 B7FF1F                      STA     PORTCTRL
 F3E7 F7FF1E                      STB     PORTC               ; set cf register address
 F3EA CA40                        ORB     #IDE_RD             ; assert rd line
 F3EC F7FF1E                      STB     PORTC
 F3EF B6FF1C                      LDA     PORTA               ; read lsb from d0-d7
 F3F2 C840                        EORB    #IDE_RD             ; prepare for rd line release

 F3F4 F7FF1E          ENDIDERW    STB     PORTC               ; release line
 F3F7 7FFF1E                      CLR     PORTC               ; release ide device
 F3FA 39                          RTS
                      ;*
                      ;* Read sector from disk typ 8255 / ide
                      ;* (A=track,B=sector,X=addr of a sector buffer)
 F3FB 3436            RDDT2       PSHS    Y,X,B,A

 F3FD 8D8E                        BSR     SETLBA              ; compute lba and set params in cf

 F3FF 8DB5                        BSR     CMDWAIT
 F401 8620                        LDA     #IDE_CMD_READ       ; send read command to the cf card
 F403 C60F                        LDB     #IDE_COMMAND        ; load command register address
 F405 8DC3                        BSR     WRT_IDE             ; send command to the cf card

 F407 8D2C            RDLOOP      BSR     CHKDRQ
 F409 2725                        BEQ     RWEXIT              ; Z set ? yes end of loop
 F40B 8DB4                        BSR     DATWAIT
 F40D C608                        LDB     #IDE_DATA
 F40F 8DD1                        BSR     READ_IDE            ; read the data byte from cf
 F411 A780                        STA     ,X+                 ; write it to the buffer
 F413 20F2                        BRA     RDLOOP
                      ;*
                      ;* Write a sector to disk typ 8255 / ide
                      ;* (A=track,B=sector,X=addr of a sector buffer)
 F415 3436            WRDT2       PSHS    Y,X,B,A

 F417 BDF38D                      JSR     SETLBA              ; compute lba and set params in cf

 F41A 8D9A                        BSR     CMDWAIT
 F41C 8630                        LDA     #IDE_CMD_WRITE      ; send write command to the cf card
 F41E C60F                        LDB     #IDE_COMMAND        ; load command register address
 F420 8DA8                        BSR     WRT_IDE             ; send command to the cf card

 F422 8D11            WRLOOP      BSR     CHKDRQ
 F424 270A                        BEQ     RWEXIT              ; Z set ? yes end of loop
 F426 8D99                        BSR     DATWAIT
 F428 A680                        LDA     ,X+                 ; read the byte from the buffer
 F42A C608                        LDB     #IDE_DATA           ; write the data byte to cf
 F42C 8D9C                        BSR     WRT_IDE
 F42E 20F2                        BRA     WRLOOP

 F430 BDF336          RWEXIT      JSR     NVC0Z1              ;  set cc with no error & rts
 F433 35B6                        PULS    Y,X,B,A,PC
                      ;*
                      ;* Check cf DRQ bit
                      ;* Return Z=0 if DRQ set
                      ;*        Z=1 if DRQ not set
 F435 8D8A            CHKDRQ      BSR     DATWAIT
 F437 C60F                        LDB     #IDE_STATUS
 F439 8DA7                        BSR     READ_IDE
 F43B 8508                        BITA    #DRQBIT
 F43D 39                          RTS
                      ;*
                      ;* Chkrdy disk typ 2 & 3
                      ;* We just check if CF has been detected by init routine
 F43E 3412            CHKDT2      PSHS    X,A
 F440 7DDE7E                      TST     MSTCFOK
 F443 2715                        BEQ     NOTRDY              ; no master then also no slave exit not ready

 F445 A603                        LDA     3,X                 ; load flex disk number
 F447 8EDF9D                      LDX     #DDSTAB
 F44A E686                        LDB     A,X                 ; load physical disk number
 F44C C102                        CMPB    #$02                ; master cf asked ?
 F44E 2705                        BEQ     RDY                 ; yes all ok
 F450 7DDE7F                      TST     SLVCFOK             ; if master cf not asked then it is slave
 F453 2705                        BEQ     NOTRDY              ; slave present ? no exit not ready

 F455 BDF336          RDY         JSR     NVC0Z1              ; no error - clear C - set Z
 F458 3592                        PULS    X,A,PC

 F45A BDF33B          NOTRDY      JSR     NVZ0C1              ; error - clear Z - set C
 F45D 3592                        PULS    X,A,PC
                      ;*
                      ;* Detect and init disk typ 2 & 3 CF on 8255 ide port
 F45F C60E            INIDT2      LDB     #IDE_LBA3           ; set lba3 for master cf
 F461 86E0                        LDA     #LBA3MST
 F463 B7DE7D                      STA     LBA3                ; keep ram table sync
 F466 BDF3CA                      JSR     WRT_IDE

 F469 CC0000                      LDD     #$0000
 F46C FDDE7E                      STD     MSTCFOK             ; clear cf present flags

 F46F 8EFFFE                      LDX     #$FFFE              ; prepare for time out
 F472 C60F            ILOOP1      LDB     #IDE_STATUS         ; ask status register
 F474 BDF3E2                      JSR     READ_IDE
 F477 8580                        BITA    #BSYBIT             ; read busy bit
 F479 2706                        BEQ     MSTOK               ; if clear master cf ok
 F47B 301F                        LEAX    -1,X                ; countdown
 F47D 2729                        BEQ     ENDINI              ; time out end cf int (no master no slave)
 F47F 20F1                        BRA     ILOOP1              ; do again
 F481 8540            MSTOK       BITA    #RDYBIT             ; must also check ready bit set
 F483 2723                        BEQ     ENDINI              ; error set ? yes end cf init
 F485 7CDE7E                      INC     MSTCFOK             ; set master flag

 F488 C60E                        LDB     #IDE_LBA3           ; set lba3 for slave cf
 F48A 86F0                        LDA     #LBA3SLV
 F48C BDF3CA                      JSR     WRT_IDE

 F48F 8EFFFE                      LDX     #$FFFE              ; prepare for time out
 F492 C60F            ILOOP2      LDB     #IDE_STATUS         ; ask status register
 F494 BDF3E2                      JSR     READ_IDE
 F497 8540                        BITA    #RDYBIT             ; read ready bit
 F499 2606                        BNE     SLVOK               ; wait ready bit set
 F49B 301F                        LEAX    -1,X                ; countdown
 F49D 2709                        BEQ     ENDINI              ; time out no slave cf
 F49F 20F1                        BRA     ILOOP2              ; do again
 F4A1 8501            SLVOK       BITA    #ERRBIT             ; must also check error bit clear
 F4A3 2603                        BNE     ENDINI              ; error ser ? end cf init
 F4A5 7CDE7F                      INC     SLVCFOK             ; set slave flag

 F4A8 C60E            ENDINI      LDB     #IDE_LBA3           ; set lba3 for master cf
 F4AA 86E0                        LDA     #LBA3MST
 F4AC BDF3CA                      JSR     WRT_IDE
 F4AF 39                          RTS

                      ;* =====================================================================
                      ;* END OF VARIOUS IDE / 8255 DISK ROUTINES
                      ;* =====================================================================

                      ;*
                      ;*****************************************
                      ;* Disk drivers                          *
                      ;* ------------                          *
                      ;* The system dependant code for the     *
                      ;* disc drivers fits here. Two tables    *
                      ;* must be included. These are DDSTAB a  *
                      ;* four byte table that defines which of *
                      ;* the (up to four) following sets of    *
                      ;* jump tables to use, and TABSRT the    *
                      ;* jump tables themselves. For a full    *
                      ;* description of the floppy drivers see *
                      ;* section 4 (pp9-14) of the general     *
                      ;* Flex adaptation guide.                *
                      ;*****************************************
                      ;*
                      ;* LIB DISK
                      ;* Read sector routine.
                      ;* Entry: (X) = address where sector is to be placed.
                      ;*        (A) = Track  number.
                      ;*        (B) = Sector number.
                      ;* Exit:  (B) = Error code  (z)=1 if no error.
 F4B0 6E9FDFA1        READ    JMP     [REAVEC]
                      ;*
                      ;* Write track routine.
                      ;* Entry: (X) = Address of area of memory from which the data will be taken.
                      ;*        (A) = Track number.
                      ;*        (B) = Sector number.
                      ;* Exit:  (B) = Error condition, (Z)=1 no an error.
 F4B4 6E9FDFA3        WRITE   JMP     [WRIVEC]
                      ;*
                      ;* Verify sector routine.
                      ;* Entry: no parameters.
                      ;* Exit:  (B) = Error condition (Z)=1 if no error.
 F4B8 6E9FDFA5        VERIFY  JMP     [VERVEC]
                      ;*
                      ;* Restore drive to track 00.
                      ;* Entry: (X) = FCB address (3,X contains drive number).
                      ;* Exit:  (B) = Error condition, (Z)=1 if no error.
 F4BC 8D07            RST     BSR     DRV        ; Select drive first.
 F4BE 2701                    BEQ     RST1
 F4C0 39                      RTS
 F4C1 6E9FDFA7        RST1    JMP     [RSTVEC]
                      ;*
                      ;* Select current drive.
                      ;* Entry: (X) = FCB address (3,X contains drive number).
                      ;* Exit:  (B) = Error condition, (Z)=0 and (c)=1 if error.
                      ;*        (B) = $0F if non existant drive.
 F4C5 3430            DRV     PSHS    X,Y
 F4C7 E603                    LDB     3,X        ; Get driver type.
 F4C9 8EDF9D                  LDX     #DDSTAB
 F4CC A685                    LDA     B,X
 F4CE 81FF                    CMPA    #$FF       ; Is the drive nonexistant?
 F4D0 2608                    BNE     DRIVE1
 F4D2 3530                    PULS    X,Y
 F4D4 C60F                    LDB     #$0F
 F4D6 5D                      TSTB
 F4D7 1A01                    ORCC    #$01
 F4D9 39                      RTS
 F4DA C614            DRIVE1  LDB     #20        ; Get correct table start address.
 F4DC 3D                      MUL
 F4DD 8EF1CA                  LDX     #TABSRT
 F4E0 308B                    LEAX    D,X
 F4E2 108EDFA1                LDY     #REAVEC    ; Copy table into ram.
 F4E6 C614                    LDB     #20
 F4E8 A680            DRIVE2  LDA     ,X+
 F4EA A7A0                    STA     ,Y+
 F4EC 5A                      DECB
 F4ED 26F9                    BNE     DRIVE2
 F4EF 3530                    PULS    X,Y
 F4F1 6E9FDFA9                JMP     [DRVVEC]
                      ;*
                      ;* Check for drive ready.
                      ;* Entry: (X) = FCB address (3,X contains drive number)>
                      ;* Exit:  (B) = Error condition, (Z)=0 AND (C)=1 if drive is not ready.
 F4F5 6E9FDFAB        CHKRDY  JMP     [CHKVEC]
                      ;*
                      ;* Quick drive ready check.
                      ;* Entry: (X) = FCB address (3,X contains drive number).
                      ;* Exit:  (B) = Error condition, (Z)=0 AND (c)=1 if drive not ready.
 F4F9 6E9FDFAD        QUICK   JMP     [QUIVEC]
                      ;*
                      ;* Init (cold start).
                      ;* Entry: no parameters.
                      ;* Exit: no change.
 F4FD 4F              DINIT   CLRA
 F4FE B7DF8E          DINIT1  STA     DRIVE      ; Init each valid drive in turn.
 F501 8EDF8B                  LDX     #(DRIVE-3)
 F504 8DBF                    BSR     DRV
 F506 2504                    BCS     DINIT2
 F508 AD9FDFAF                JSR     [INIVEC]
 F50C B6DF8E          DINIT2  LDA     DRIVE
 F50F 4C                      INCA
 F510 8103                    CMPA    #3
 F512 26EA                    BNE     DINIT1
 F514 39                      RTS
                      ;*
                      ;* Warm start.
                      ;* Entry: no parameters.
                      ;* Exit: no change.
 F515 6E9FDFB1        WARM    JMP     [WARVEC]
                      ;*
                      ;* Seek track.
                      ;* Entry: (A) = Track number.
                      ;*        (B) = Sector number.
                      ;* Exit:  (B) = Error condition, (Z)=1 if no error.
 F519 6E9FDFB3        SEEK    JMP     [SEEVEC]
                      ;*
                      ;*******************************
                      ;* Common monitor subroutines. *
                      ;*******************************
                      ;*
                      ;* Print a CR followed by a LF.
                      ;* Entry: no parameters.
                      ;* Exit: (A) destroyed.
 F51D 0A0D04          CRLFS   FCB     $0A,$0D,4
 F520 3410            PCRLF   PSHS    X
 F522 8EF51D                  LDX     #CRLFS     ; Get CR,LF string,
 F525 8D05                    BSR     PDATA1     ; and print it.
 F527 3590                    PULS    X,PC
                      ;*
                      ;* Print character string .
                      ;* Entry: (X) = Pointer to character string.
                      ;* Exit:  (X) = Pointer to end of string token Hex(04).
                      ;*        (A)   Destroyed.
 F529 BDF16E          P       JSR     OUTCH      ; Print char.
 F52C A680            PDATA1  LDA     ,X+        ; Get character pointed to by X.
 F52E 8104                    CMPA    #$04       ; End of string token?
 F530 26F7                    BNE     P          ; If not then print char.
 F532 39                      RTS
                      ;*
                      ;* Print character string preceded by a CR,LF.
                      ;* Entry: (X) = Pointer to character string.
                      ;* Exit:  (X) = Pointer to end of string token Hex(04).
                      ;*        (A) = Destroyed.
 F533 8DEB            PSTRNG  BSR     PCRLF
 F535 8DF5                    BSR     PDATA1
 F537 39                      RTS
                      ;*
                      ;* Print the A reg.
                      ;* Entry :- (A) = Data to be printed.
 F538 3416            PRINTA  PSHS    D,X
 F53A B7DF91                  STA     TEMP
 F53D 8EDF91                  LDX     #TEMP
 F540 8D7F                    BSR     OUT2HS
 F542 3596                    PULS    D,X,PC
                      ;*
                      ;* Print the X reg.
                      ;* Entry :- (X) = Data to be printed.
 F544 3416            PRINTX  PSHS    D,X
 F546 BFDF92                  STX     XTEMP
 F549 8EDF92                  LDX     #XTEMP
 F54C 8D71                    BSR     OUT4HS
 F54E 3596                    PULS    D,X,PC
                      ;*
                      ;* Delay routine.
                      ;* Entry: (X) = Delay time in milli seconds.
                      ;* Exit:  no change.
 F550 3436            DELAY   PSHS    D,X,Y
 F552 108E0034        DELAY1  LDY     #52 Delay
 F556 7DDFF9                  TST     PSPEED
 F559 2704                    BEQ     DELAY2
 F55B 108E0068                LDY     #104       ; Twice delay for 2Mhz.
 F55F 3D              DELAY2  MUL
 F560 313F                    LEAY    -1,Y
 F562 26FB                    BNE     DELAY2
 F564 301F                    LEAX    -1,X
 F566 26EA                    BNE     DELAY1
 F568 35B6                    PULS    D,X,Y,PC
                      ;*
                      ;* Build a four hex digit address.
                      ;* Entry: no parameters.
                      ;* Exit:  (X) = Address.
                      ;*        (A) = Destroyed.
                      ;*        (B) = Destroyed.
 F56A 8D09            BADDR   BSR     BYTE       ; Get 1st char.
 F56C 1F89                    TFR     A,B
 F56E 8D05                    BSR     BYTE       ; and next.
 F570 1E89                    EXG     A,B
 F572 1F01                    TFR     D,X                    Put in X.
 F574 39                      RTS
                      ;*
                      ;* Get a two digit hex byte.
                      ;* Entry: no parameters.
                      ;* Exit:  (A) = Byte.
 F575 3404            BYTE    PSHS    B
 F577 8D21                    BSR     INHEX      ; Get hex digit.
 F579 48                      ASLA
 F57A 48                      ASLA               ; Shift to msb.
 F57B 48                      ASLA
 F57C 48                      ASLA
 F57D 1F89                    TFR     A,B        ; Save in B.
 F57F 8D19                    BSR     INHEX      ; Get next digit.
 F581 3404                    PSHS    B
 F583 ABE0                    ADDA    ,S+        ; Add together bytes.
 F585 3584             PULS B,PC
                      ;*
                      ;* Print left hex digit.
                      ;* Entry: (A) = Byte containing digit.
                      ;* Exit:  (A) = Byte containing shifted digit.
 F587 44              OUTHL   LSRA
 F588 44                      LSRA
 F589 44                      LSRA
 F58A 44                      LSRA
                      ;*
                      ;* Output right hex digit.
                      ;* Entry: (A) = Byte containing digit.
                      ;* Exit:  (A) = Ascii coded digit.
 F58B 840F            OUTHR   ANDA    #$0F       ; Get four bits only.
 F58D 8B30                    ADDA    #$30       ; Add ascii zero.
 F58F 8139                    CMPA    #$39       ; Numeric overflow?
 F591 1023FBD9                LBLS    OUTCH
 F595 8B07                    ADDA    #$07       ; Must be hex.
 F597 7EF16E                  JMP    OUTCH
                      ;*
                      ;* Input a valid hex character (If not hex then backspace).
                      ;* Entry: no parameters.
                      ;* Exit:  (A) = Valid hex char.
 F59A BDF16C          INHEX   JSR     INCH
 F59D 8030                    SUBA    #$30       ; Remove ascii bias.
 F59F 2B0F                    BMI     NOTHEX
 F5A1 8109                    CMPA    #$09       ; Number?
 F5A3 2F0A                    BLE     INHEX1     ; Yes.
 F5A5 8111                    CMPA    #$11       ; Keep testing.
 F5A7 2B07                    BMI     NOTHEX
 F5A9 8116                    CMPA    #$16
 F5AB 2E03                    BGT     NOTHEX
 F5AD 8007                    SUBA    #$07
 F5AF 39              INHEX1  RTS
 F5B0 8608            NOTHEX  LDA     #$08       ; If not a number
 F5B2 BDF16E                  JSR     OUTCH      ; Print a backspace and try again.
 F5B5 20E3                    BRA     INHEX
                      ;*
                      ;* Hex print routines.
                      ;* Entry: (X) = Pointer to a one or two byte hex number.
                      ;* Exit:  (A) = Destroyed.
 F5B7 A684            OUT2H   LDA     ,X         ;Output two hex chars.
 F5B9 8DCC            OUT2HA  BSR     OUTHL
 F5BB A680                    LDA     ,X+
 F5BD 20CC                    BRA     OUTHR
 F5BF 8DF6            OUT4HS  BSR     OUT2H      ; Output 4 hex chars + space.
 F5C1 8DF4            OUT2HS  BSR     OUT2H      ; Output 2 hex chars + space.
                      ;*
                      ;* Output a space.
                      ;* Entry: no parameters.
                      ;* Exit   (A) = Destroyed.
 F5C3 8620            OUTS    LDA     #' '       ; Output space.
 F5C5 7EF16E                  JMP    OUTCH
                      ;*
                      ;* Random number generator.
                      ;* Entry: no parameters.
                      ;* Exit:  (A) = Random number from 0 to 255.
 F5C8 3404            RANDOM  PSHS B
 F5CA C608                    LDB #8
 F5CC B6DF9B          RPT     LDA RNDM+3
 F5CF 48                      ASLA
 F5D0 48                      ASLA
 F5D1 48                      ASLA
 F5D2 B8DF9B                  EORA RNDM+3
 F5D5 48                      ASLA
 F5D6 48                      ASLA
 F5D7 79DF98                  ROL RNDM
 F5DA 79DF99                  ROL RNDM+1
 F5DD 79DF9A                  ROL RNDM+2
 F5E0 79DF9B                  ROL RNDM+3
 F5E3 5A                      DECB
 F5E4 26E6                    BNE RPT
 F5E6 B6DF98                  LDA RNDM
 F5E9 3584                    PULS B,PC
                      ;*
                      ;**************************************
                      ;* Extra system subroutines fit here. *
                      ;**************************************
                      ;* LIB SUBS
                      ;*
                      ;* Get Time string from RTC
 F5EB 3416            GETTIM  PSHS    X,D
 F5ED C60A                    LDB     #$0A
 F5EF 8D07            GTIM2   BSR     GETRTC
 F5F1 A780                    STA     ,X+
 F5F3 5A                      DECB
 F5F4 26F9                    BNE     GTIM2
 F5F6 3596                    PULS    PC,X,D
                      ;* Get a byte from RTC
 F5F8 860A            GETRTC  LDA     #$0A
 F5FA B7FF18                  STA     RTC
 F5FD B6FF19                  LDA     RTC+1
 F600 2BF6                    BMI     GETRTC
 F602 F7FF18                  STB     RTC
 F605 B6FF19                  LDA     RTC+1
 F608 39                      RTS
                      ;* Put time string to RTC
 F609 3416            PUTTIM  PSHS    X,D
 F60B C60A                    LDB     #$0A
 F60D A680            PTIM2   LDA     ,X+
 F60F 8D05                    BSR     PUTRTC
 F611 5A                      DECB
 F612 26F9                    BNE     PTIM2
 F614 3596                    PULS    PC,X,D
                      ;* Put a byte to RTC
 F616 3402            PUTRTC  PSHS    A
 F618 860A            PRTC2   LDA     #$0A
 F61A B7FF18                  STA     RTC
 F61D B6FF19                  LDA     RTC+1
 F620 2BF6                    BMI     PRTC2
 F622 F7FF18                  STB     RTC
 F625 3502                    PULS    A
 F627 B7FF19                  STA     RTC+1
 F62A 39                      RTS
                      ;* Sound a tone
 F62B 3412            BEEP    PSHS    X,A
 F62D B6FF02                  LDA     SYSREG
 F630 8A08                    ORA     #$08
 F632 B7FF02                  STA     SYSREG
 F635 8E0064                  LDX     #$0064
 F638 BDF550                  JSR     DELAY
 F63B B6FF02                  LDA     SYSREG
 F63E 84F7                    ANDA    #$F7
 F640 B7FF02                  STA     SYSREG
 F643 3592                    PULS    PC,X,A
                      ;* Enter from monitor JF cmd. on entry X=CD00 or CD03
 F645 B6FF02          MAPOUT  LDA     SYSREG
 F648 84FB                    ANDA    #$FB
 F64A B7FF02                  STA     SYSREG
 F64D 6E84                    JMP     ,X

                      ;*************************************
                      ;* Graphic functions for the NEC7220A
                      ;*************************************
                      ;*
                      ;* Send a command to GDC
 F64F 4D              GCOM    TSTA               ; reset ?
 F650 270B                    BEQ     GCOM2      ; yes, send at once
 F652 3402                    PSHS    A          ; else, savec cmd
 F654 B6FF14          GCOM1   LDA     GDC        ; get status
 F657 8504                    BITA    #$04       ; FIFO empty ?
 F659 27F9                    BEQ     GCOM1      ; no, wait
 F65B 3502                    PULS    A          ; recover command
 F65D B7FF15          GCOM2   STA     GDC+1      ; send it
 F660 39                      RTS
                      ;*
                      ;* Send a parameter to GDC
                      ;*
 F661 3402            GPRM    PSHS    A          ; store parameter
 F663 B6FF14          GPRM2   LDA     GDC        ; wait until FIFO empty
 F666 8504                    BITA    #$04
 F668 27F9                    BEQ     GPRM2
 F66A 3502                    PULS    A
 F66C B7FF14                  STA     GDC        ; send parameter
 F66F 39                      RTS
                      ;*
                      ;* Get a parameter from GDC
                      ;*
 F670 B6FF14          GPRMI   LDA     GDC        ; get status
 F673 8501                    BITA    #$01       ; data ready ?
 F675 27F9                    BEQ     GPRMI      ; no, wait
 F677 B6FF15                  LDA     GDC+1      ; read FIFO
 F67A 39                      RTS
                      ;*
                      ;* Load the mask register
                      ;*
 F67B 3406            MASK    PSHS    D
 F67D 864A                    LDA     #$4A       ; send 'mask' command
 F67F 8DCE                    BSR     GCOM
 F681 1F10                    TFR     X,D        ; get mask bytes
 F683 1E89                    EXG     A,B        ; reverse for FIFO
 F685 8DDA                    BSR     GPRM       ; send 2nd
 F687 1E89                    EXG     A,B
 F689 8DD6                    BSR     GPRM       ; send 1st
 F68B 3586                    PULS    PC,D
                      ;*
                      ;* Define drawing mode
                      ;*
 F68D 3416            SETPEN  PSHS    X,D
 F68F 8403                    ANDA    #$03       ; setup 'w.data' cmd
 F691 8A20                    ORA     #$20
 F693 8DBA                    BSR     GCOM       ; send it
 F695 1F10                    TFR     X,D        ; get profile word
 F697 F7DFC4                  STB     MDFC4      ; save it
 F69A B7DFC3                  STA     GPARAM
 F69D 8EDFBD                  LDX     #PART1+2
 F6A0 8D02                    BSR     SETPAT
 F6A2 3596                    PULS    PC,X,D
                      ;*
                      ;* Define graphics pattern
                      ;*
 F6A4 3416            SETPAT  PSHS    X,D
 F6A6 8678                    LDA     #$78       ; 'pram' cmd starting
 F6A8 8DA5                    BSR     GCOM       ; with param.No.8
 F6AA C608                    LDB     #$08       ; load 8 parameters,
 F6AC 3008                    LEAX    $08,X      ; taken from ram
 F6AE A682            SETP2   LDA     ,-X        ; pointed to by X,
 F6B0 8DAF                    BSR     GPRM       ; in reverse order (FIFO)
 F6B2 5A                      DECB
 F6B3 26F9                    BNE     SETP2
 F6B5 3596                    PULS    PC,X,D
                      ;*
                      ;* Start figure drawing
                      ;*
 F6B7 3416            FIGSF   PSHS    X,D
 F6B9 864C                    LDA     #$4C       ; 'figs' command
 F6BB 8D92                    BSR     GCOM       ; Load [B] drawing parameters
 F6BD 8EDFCD                  LDX     #GFIGS     ; from scratch ram to GDCRAM
 F6C0 A684                    LDA     ,X         ; NB. All 2-byte parameters are
 F6C2 8D9D                    BSR     GPRM       ; loaded low byte first to
 F6C4 5A                      DECB               ; maintain Fifo stack.
 F6C5 270E                    BEQ     FIGS3
 F6C7 A602            FIGS2   LDA     $02,X
 F6C9 8D96                    BSR     GPRM
 F6CB A601                    LDA     $01,X
 F6CD 3002                    LEAX    $02,X
 F6CF 8D90                    BSR     GPRM
 F6D1 5A                      DECB
 F6D2 5A                      DECB
 F6D3 26F2                    BNE     FIGS2
                      ; Load the GDCRAM into the drawing processor & draw.
 F6D5 866C            FIGS3   LDA     #$6C       ; 'figd' command
 F6D7 17FF75                  LBSR    GCOM
 F6DA 3596                    PULS    PC,X,D
                      ;*
                      ;* Start graphics drawing
                      ;*
 F6DC 3416            FIGSG   PSHS    X,D        ; Load [B] drawing parameters
 F6DE 864C                    LDA     #$4C       ; from scratch ram to GDCRAM
 F6E0 17FF6C                  LBSR    GCOM       ; NB. All 2-byte parameters are
 F6E3 8EDFCD                  LDX     #GFIGS     ; loaded low byte first to
 F6E6 A684                    LDA     ,X         ; maintain Fifo stack.
 F6E8 17FF76                  LBSR    GPRM
 F6EB 5A                      DECB
 F6EC 2710                    BEQ     FIGG3
 F6EE A602            FIGG2   LDA     $02,X
 F6F0 17FF6E                  LBSR    GPRM
 F6F3 A601                    LDA     $01,X
 F6F5 3002                    LEAX    $02,X
 F6F7 17FF67                  LBSR    GPRM
 F6FA 5A                      DECB
 F6FB 5A                      DECB
 F6FC 26F0                    BNE     FIGG2
 F6FE 8668            FIGG3   LDA     #$68       ; 'gchrd' command
 F700 17FF4C                  LBSR    GCOM       ; Fill area to pattern stored in GDCRAM
 F703 3596                    PULS    PC,X,D     ; (ie. Draw graphics character)
                      ;*
                      ;* Define display partitions. On entry,
                      ;*     X=Pt.1 start
                      ;*     D=Pt.2 start
                      ;*     Y=Pt.1 length
                      ;*     U=Pt.2 length
                      ;*
 F705 3476            SETPAR  PSHS    U,Y,X,D
 F707 1E89                    EXG     A,B
 F709 FDDFBF                  STD     PART2
 F70C 1F10                    TFR     X,D
 F70E 1E89                    EXG     A,B
 F710 FDDFBB                  STD     PART1
 F713 1F20                    TFR     Y,D
 F715 C40F                    ANDB    #$0F       ; mask off Hi nibble
 F717 8610                    LDA     #$10       ; shift into Hi nibble to
 F719 3D                      MUL                ; form Lo field of length
 F71A F7DFBD                  STB     PART1+2
 F71D 1F20                    TFR     Y,D        ; recover length
 F71F 44                      LSRA               ; shove the last 4 bits overboard
 F720 56                      RORB               ; (we have already dealt with these)
 F721 44                      LSRA
 F722 56                      RORB
 F723 44                      LSRA
 F724 56                      RORB
 F725 44                      LSRA
 F726 56                      RORB               ; use the remaining bits as
 F727 F7DFBE                  STB     PART1+3    ; Hi field of length
 F72A 1F30                    TFR     U,D        ; get Pt.2 length & treat as above
 F72C C40F                    ANDB    #$0F
 F72E 8610                    LDA     #$10
 F730 3D                      MUL
 F731 F7DFC1                  STB     PART2+2
 F734 1F30                    TFR     U,D
 F736 44                      LSRA
 F737 56                      RORB
 F738 44                      LSRA
 F739 56                      RORB
 F73A 44                      LSRA
 F73B 56                      RORB
 F73C 44                      LSRA
 F73D 56                      RORB
 F73E F7DFC2                  STB     PART2+3
 F741 8D14                    BSR     VSYNC      ; wait for sync
 F743 8670                    LDA     #$70       ; 'pram' cmd.
 F745 17FF07                  LBSR    GCOM
 F748 8EDFBB                  LDX     #PART1     ; transfer 8 params
 F74B C608                    LDB     #$08       ; from scratch to GDC
 F74D A680            SPRM2   LDA     ,X+
 F74F 17FF0F                  LBSR    GPRM
 F752 5A                      DECB
 F753 26F8                    BNE     SPRM2
 F755 35F6                    PULS    PC,U,Y,X,D
                      ;*
                      ;* Sync to vertical blanking
                      ;*
 F757 3402            VSYNC   PSHS    A
 F759 B6FF14          VSYN2   LDA     GDC
 F75C 8520                    BITA    #$20
 F75E 26F9                    BNE     VSYN2
 F760 B6FF14          VSYN3   LDA     GDC
 F763 8520                    BITA    #$20
 F765 27F9                    BEQ     VSYN3
 F767 3582                    PULS    PC,A
                      ;*
                      ;* Set graphics cursor
                      ;*
 F769 3436            SETCRG  PSHS    Y,X,D
 F76B BFDFB7                  STX     XCOORD
 F76E 10BFDFB9                STY     YCOORD
 F772 8649                    LDA     #$49       ; 'curs' cmd
 F774 17FED8                  LBSR    GCOM
 F777 1F20                    TFR     Y,D
 F779 58                      ASLB               ; mult Y-coord by 48
 F77A 49                      ROLA               ; to yield number of
 F77B 58                      ASLB               ; words,(16 bit), in
 F77C 49                      ROLA               ; previous lines
 F77D 58                      ASLB
 F77E 49                      ROLA
 F77F 58                      ASLB
 F780 49                      ROLA
 F781 1F02                    TFR     D,Y
 F783 58                      ASLB
 F784 49                      ROLA
 F785 31AB                    LEAY    D,Y
 F787 1F10                    TFR     X,D
 F789 44                      LSRA               ; divide X-coord by 16
 F78A 56                      RORB               ; to yield number of
 F78B 44                      LSRA               ; complete words on
 F78C 56                      RORB               ; this line.Add addr
 F78D 44                      LSRA               ; of 1st word in
 F78E 56                      RORB               ; Partition,to get
 F78F 44                      LSRA               ; addr of current word
 F790 56                      RORB
 F791 31AB                    LEAY    D,Y
 F793 31A95E00                LEAY    $5E00,Y
 F797 58                      ASLB               ; recover X-coord but
 F798 49                      ROLA               ; with l.s. nibble
 F799 58                      ASLB               ; set to 0. Subtract
 F79A 49                      ROLA               ; to yield number of
 F79B 58                      ASLB               ; bits in current word
 F79C 49                      ROLA
 F79D 58                      ASLB
 F79E 49                      ROLA
 F79F 43                      COMA
 F7A0 53                      COMB
 F7A1 C30001                  ADDD    #$0001
 F7A4 308B                    LEAX    D,X
 F7A6 1F20                    TFR     Y,D        ; format to suit GDC
 F7A8 1E89                    EXG     A,B        ; parameter ram and
 F7AA 17FEB4                  LBSR    GPRM       ; load parameters
 F7AD 1E89                    EXG     A,B
 F7AF 17FEAF                  LBSR    GPRM
 F7B2 1F10                    TFR     X,D
 F7B4 8610                    LDA     #$10
 F7B6 3D                      MUL
 F7B7 C4F0                    ANDB    #$F0
 F7B9 1F98                    TFR     B,A
 F7BB 17FEA3                  LBSR    GPRM
 F7BE 35B6                    PULS    PC,Y,X,D
                      ;*
                      ;* Get graphics cursor
                      ;*
 F7C0 3406            GETCRG  PSHS    D
 F7C2 86E0                    LDA     #$E0       ; 'curd' cmd
 F7C4 17FE88                  LBSR    GCOM
 F7C7 17FEA6                  LBSR    GPRMI      ; get cursor word adr
 F7CA 1F89                    TFR     A,B
 F7CC 17FEA1                  LBSR    GPRMI
 F7CF 108E0000                LDY     #$0000     ; zero line count
 F7D3 835E00                  SUBD    #$5E00     ; convert to word #
 F7D6 830030          GCRG1   SUBD    #$0030     ; count lines
 F7D9 2B04                    BMI     GCRG2
 F7DB 3121                    LEAY    $01,Y
 F7DD 20F7                    BRA     GCRG1
 F7DF C30030          GCRG2   ADDD    #$0030
 F7E2 58                      ASLB               ; convert 'words on
 F7E3 49                      ROLA               ; current line' to
 F7E4 58                      ASLB               ; 'bits on current line'
 F7E5 49                      ROLA
 F7E6 58                      ASLB
 F7E7 49                      ROLA
 F7E8 58                      ASLB
 F7E9 49                      ROLA
 F7EA 1F01                    TFR     D,X        ; save in X
 F7EC 17FE81                  LBSR    GPRMI      ; Hi adr.bits.Discard
 F7EF 17FE7E                  LBSR    GPRMI      ; get dot addr
 F7F2 1F89                    TFR     A,B        ; (in 1 of 16 form)
 F7F4 17FE79                  LBSR    GPRMI
 F7F7 1CFE                    ANDCC   #$FE       ; clear carry
 F7F9 44              GCRG3   LSRA               ; count buckshee bits and
 F7FA 56                      RORB               ; increment X accordingly
 F7FB 2504                    BCS     GCRG4
 F7FD 3001                    LEAX    $01,X
 F7FF 20F8                    BRA     GCRG3
 F801 BFDFB7          GCRG4   STX     XCOORD     ; store coordinates
 F804 10BFDFB9                STY     YCOORD
 F808 3586                    PULS    PC,D
                      ;*
                      ;* Turn display off
                      ;*
 F80A 3402            OFF     PSHS    A
 F80C BDF757                  JSR     VSYNC
 F80F 860C                    LDA     #$0C
 F811 17FE3B                  LBSR    GCOM
 F814 3582                    PULS    PC,A
                      ;*
                      ;* Turn display on
                      ;*
 F816 3402            ON      PSHS    A
 F818 BDF757                  JSR     VSYNC
 F81B 860D                    LDA     #$0D
 F81D 17FE2F                  LBSR    GCOM
 F820 3582                    PULS    PC,A
                      ;*
                      ;* Set display to graphics
                      ;*
 F822 3476            GRAPH   PSHS    U,Y,X,D
 F824 5F                      CLRB
 F825 8D16                    BSR     MODE
 F827 8A09                    ORA     #$09
 F829 5A                      DECB
 F82A 8D11                    BSR     MODE       ; set interlaced
 F82C 8E5E00                  LDX     #$5E00     ; set Partitions
 F82F 108E0240                LDY     #$0240
 F833 CC0000                  LDD     #$0000
 F836 1F03                    TFR     D,U
 F838 BDF705                  JSR     SETPAR
 F83B 35F6                    PULS    PC,U,Y,X,D
                      ;*
                      ;* Set GDC mode
                      ;*
 F83D 5D              MODE    TSTB
 F83E 2710                    BEQ     MODE1
 F840 B7DFCB                  STA     GMODE
 F843 3402                    PSHS    A
 F845 860F                    LDA     #$0F       ; 'sync' mode
 F847 17FE05                  LBSR    GCOM
 F84A 3502                    PULS    A
 F84C 17FE12                  LBSR    GPRM
 F84F 39                      RTS
 F850 B6DFCB          MODE1   LDA     GMODE
 F853 39                      RTS
                      ;*
                      ;* Set zoom factor
                      ;*
 F854 5D              ZOOM    TSTB
 F855 2710                    BEQ     ZOOM1
 F857 B7DFCC                  STA     GZOOM
 F85A 3402                    PSHS    A
 F85C 8646                    LDA     #$46       ; 'zoom'command
 F85E 17FDEE                  LBSR    GCOM
 F861 3502                    PULS    A
 F863 17FDFB                  LBSR    GPRM
 F866 39                      RTS
 F867 B6DFCC          ZOOM1   LDA     GZOOM
 F86A 39                      RTS
                      ;*
                      ;* Area fill (On entry, A holds init dir)
                      ;*
 F86B 3436            FILL    PSHS    Y,X,D
 F86D 8487                    ANDA    #$87       ; set 'figs' P1 for graphics char
 F86F 8A10                    ORA     #$10
 F871 B7DFCD                  STA     GFIGS
 F874 313F                    LEAY    -$01,Y     ; DN=(No.of pixels at
 F876 1F20                    TFR     Y,D        ; Rt.Angles to initial
 F878 FDDFCE                  STD     DN         ; direction - 1)
 F87B 1F10                    TFR     X,D        ; D0 & D2=(No.of pixels
 F87D FDDFD0                  STD     D0         ; in initial direction)
 F880 FDDFD2                  STD     D2
 F883 C607                    LDB     #$07       ; load 7 bytes from
 F885 17FE54                  LBSR    FIGSG      ; scratch,then draw
 F888 35B6                    PULS    PC,Y,X,D
                      ;*
                      ;* Clear graphics display
                      ;*
 F88A 3436            CLEAR   PSHS    Y,X,D
 F88C 8E0000                  LDX     #$0000     ; set cursor 0,0
 F88F 1F12                    TFR     X,Y
 F891 BDF769                  JSR     SETCRG
 F894 8E4000                  LDX     #$4000     ; (DN max=$3FFF)
 F897 8602                    LDA     #$02       ; pen type 'reset'
 F899 8D11                    BSR     CLEARX     ; clear this block
 F89B 8E2C30                  LDX     #$2C30     ; now do rest
 F89E 8602                    LDA     #$02
 F8A0 8D0A                    BSR     CLEARX
 F8A2 8E0000                  LDX     #$0000     ; and reset cursor to 0,0
 F8A5 1F12                    TFR     X,Y
 F8A7 BDF769                  JSR     SETCRG
 F8AA 35B6                    PULS    PC,Y,X,D
                      ;*
                      ;* Clear (Xreg) words of display memory
                      ;*
 F8AC 3412            CLEARX  PSHS    X,A
 F8AE 3402                    PSHS    A
 F8B0 301F                    LEAX    -$01,X     ; (DN=W-1)
 F8B2 3410                    PSHS    X
 F8B4 8EFFFF                  LDX     #$FFFF     ; enable all bits
 F8B7 BDF67B                  JSR     MASK
 F8BA 864C                    LDA     #$4C       ; 'figs' command
 F8BC 17FD90                  LBSR    GCOM
 F8BF 8602                    LDA     #$02       ; P1.wdata mode,dir 2
 F8C1 17FD9D                  LBSR    GPRM
 F8C4 3506                    PULS    D
 F8C6 1E89                    EXG     A,B
 F8C8 17FD96                  LBSR    GPRM       ; P2.DN-low
 F8CB 1E89                    EXG     A,B
 F8CD 17FD91                  LBSR    GPRM       ; P3.DN-hi
 F8D0 3502                    PULS    A          ; (pen type 02)
 F8D2 8A20                    ORA     #$20       ; 'wdat' command
 F8D4 17FD78                  LBSR    GCOM
 F8D7 86FF                    LDA     #$FF
 F8D9 17FD85                  LBSR    GPRM       ; data word all 1's
 F8DC 17FD82                  LBSR    GPRM
 F8DF 3592                    PULS    PC,X,A
                      ;*
                      ;* Initialise GDC
                      ;*
 F8E1 3416            GDCINI  PSHS    X,D
 F8E3 4F                      CLRA
 F8E4 17FD68                  LBSR    GCOM       ; 'reset' command
 F8E7 C621                    LDB     #$21
 F8E9 BDF5F8          GDCI2   JSR     GETRTC     ; Load parameter ram from RTC
 F8EC BDF661                  JSR     GPRM
 F8EF 5C                      INCB
 F8F0 C129                    CMPB    #$29
 F8F2 26F5                    BNE     GDCI2
 F8F4 866F                    LDA     #$6F       ; 'vsync' command
 F8F6 17FD56                  LBSR    GCOM
 F8F9 8647                    LDA     #$47       ; 'pitch' command
 F8FB 17FD51                  LBSR    GCOM
 F8FE 8630                    LDA     #$30
 F900 17FD5E                  LBSR    GPRM
 F903 864B                    LDA     #$4B       ; 'cchar' command
 F905 17FD47                  LBSR    GCOM
 F908 4F                      CLRA
 F909 17FD55                  LBSR    GPRM
 F90C 86C0                    LDA     #$C0
 F90E 17FD50                  LBSR    GPRM
 F911 4F                      CLRA
 F912 17FD4C                  LBSR    GPRM
 F915 C601                    LDB     #$01
 F917 4F                      CLRA
 F918 17FF39                  LBSR    ZOOM
 F91B 861F                    LDA     #$1F
 F91D B7DFCB                  STA     GMODE
 F920 866B                    LDA     #$6B       ; 'start' command
 F922 17FD2A                  LBSR    GCOM
 F925 BDFAD0                  JSR     CLEART
 F928 BDFAB2                  JSR     TEXT
 F92B 3596                    PULS    PC,X,D
                      ;*
                      ;* Plot a point
                      ;*
 F92D 3404            POINT   PSHS    B
 F92F 7FDFCD                  CLR     GFIGS
 F932 C601                    LDB     #$01
 F934 17FD80                  LBSR    FIGSF
 F937 3584                    PULS    PC,B
                      ;*
                      ;* Plot a line
                      ;*
 F939 3456            LINE    PSHS    U,X,D
 F93B CEF9B1                  LDU     #P1TBL     ; base adr.of P1 table
 F93E 1F10                    TFR     X,D        ; calc X' (delta X)
 F940 B3DFB7                  SUBD    XCOORD
 F943 10830000                CMPD    #$0000
 F947 2E07                    BGT     LINE1      ; branch if X'>0
 F949 3344                    LEAU    $04,U      ; else,reverse dir &
 F94B 43                      COMA               ; change sign of X'
 F94C 53                      COMB
 F94D C30001                  ADDD    #$0001
 F950 1F01            LINE1   TFR     D,X        ; X=|X'|
 F952 1F20                    TFR     Y,D        ; repeat for Y-axis
 F954 B3DFB9                  SUBD    YCOORD
 F957 10830000                CMPD    #$0000
 F95B 2E07                    BGT     LINE2
 F95D 3342                    LEAU    $02,U
 F95F 43                      COMA
 F960 53                      COMB
 F961 C30001                  ADDD    #$0001
 F964 FDDF94          LINE2   STD     YTEMP
 F967 BFDF92                  STX     XTEMP
 F96A BCDF94                  CMPX    YTEMP
 F96D 2E08                    BGT     LINE3
 F96F 3341                    LEAU    $01,U
 F971 BFDF94                  STX     YTEMP
 F974 FDDF92                  STD     XTEMP
                      ;* At this point,XTEMP=delta large,YTEMP=delta small
 F977 A6C4            LINE3   LDA     ,U         ; get P1
 F979 B7DFCD                  STA     GFIGS      ; put it in scratch
 F97C FCDF94                  LDD     YTEMP      ; calc ---
 F97F B3DF92                  SUBD    XTEMP      ; 2(delta min - delta max)
 F982 58                      ASLB
 F983 49                      ROLA
 F984 843F                    ANDA    #$3F       ; NOT > 63
 F986 FDDFD2                  STD     D2         ; store it
 F989 FCDF94                  LDD     YTEMP
 F98C 58                      ASLB
 F98D 49                      ROLA
 F98E FDDFD4                  STD     D4         ; = 2(delta min)
 F991 B3DF92                  SUBD    XTEMP      ; 2xdelta min-delta max
 F994 843F                    ANDA    #$3F       ; NOT > 63
 F996 FDDFD0                  STD     D0         ; store it
 F999 FCDF92                  LDD     XTEMP
 F99C FDDFCE                  STD     DN         ; = delta max
 F99F C609                    LDB     #$09       ; load 9 params & draw line
 F9A1 17FD13                  LBSR    FIGSF
 F9A4 3556                    PULS    U,X,D
 F9A6 BFDFB7                  STX     XCOORD     ; recover new coordinates
 F9A9 10BFDFB9                STY     YCOORD     ; and update cursor
 F9AD 17FDB9                  LBSR    SETCRG
 F9B0 39                      RTS
                      ;*
                      ;* 'figs' P1 table. (Select initial direction)
                      ;*                1   0   2   3   6   7   5   4
 F9B1 09080A0B0E0F0D  P1TBL   FCB     $09,$08,$0A,$0B,$0E,$0F,$0D,$0C
 F9B8 0C
                      ;*
                      ;* Plot a rectangle
                      ;*
 F9B9 3436            RECT    PSHS    Y,X,D
 F9BB 8407                    ANDA    #$07       ; init.dir. (7 max)
 F9BD 8A40                    ORA     #$40       ; set 'rectangle' bit
 F9BF B7DFCD                  STA     GFIGS      ; store as P1 for 'figs'
 F9C2 CC0003                  LDD     #$0003     ; sides - 1
 F9C5 FDDFCE                  STD     DN
 F9C8 301F                    LEAX    -$01,X
 F9CA 313F                    LEAY    -$01,Y
 F9CC 1F10                    TFR     X,D        ; pix.in init dir. -1
 F9CE FDDFD0                  STD     D0
 F9D1 FDDFD6                  STD     DM
 F9D4 1F20                    TFR     Y,D        ; pix at Rt.A -1
 F9D6 FDDFD2                  STD     D2
 F9D9 CCFFFF                  LDD     #$FFFF     ; (-1)
 F9DC FDDFD4                  STD     D4
 F9DF C60B                    LDB     #$0B       ; load 11 params & draw rectangle
 F9E1 17FCD3                  LBSR    FIGSF
 F9E4 35B6                    PULS    PC,Y,X,D
                      ;*
                      ;* Plot a circle
                      ;*
 F9E6 3436            CIRCLE  PSHS    Y,X,D
 F9E8 BEDFB7                  LDX     XCOORD     ; get coordinates of
 F9EB 10BEDFB9                LDY     YCOORD     ; centre point
 F9EF BFDF92                  STX     XTEMP      ; save them
 F9F2 10BFDF94                STY     YTEMP
 F9F6 3086                    LEAX    A,X        ; add rad to X-coord
 F9F8 C604                    LDB     #$04       ; dir = 4
 F9FA 8D3B                    BSR     ARC        ; 0-45 degrees
 F9FC C607                    LDB     #$07       ; dir = 7
 F9FE 8D37                    BSR     ARC        ; 0-315 degrees
 FA00 BEDF92                  LDX     XTEMP      ; set X-coord to centre
 FA03 31A6                    LEAY    A,Y        ; add rad to Y-coord
 FA05 C602                    LDB     #$02       ; dir = 2
 FA07 8D2E                    BSR     ARC        ; 270-315 degrees
 FA09 C605                    LDB     #$05       ; dir = 5
 FA0B 8D2A                    BSR     ARC        ; 270-225 degrees
 FA0D 10BEDF94                LDY     YTEMP      ; set Y-coord to centre
 FA11 40                      NEGA
 FA12 3086                    LEAX    A,X        ; sub rad from X-coord
 FA14 40                      NEGA
 FA15 5F                      CLRB
 FA16 8D1F                    BSR     ARC        ; 180-225 degrees
 FA18 C603                    LDB     #$03       ; dir = 3
 FA1A 8D1B                    BSR     ARC        ; 180-135 degrees
 FA1C BEDF92                  LDX     XTEMP      ; set X-coord to centre
 FA1F 40                      NEGA
 FA20 31A6                    LEAY    A,Y        ; sub rad from Y-coord
 FA22 40                      NEGA
 FA23 C601                    LDB     #$01       ; dir = 1
 FA25 8D10                    BSR     ARC        ; 90-45 degrees
 FA27 C606                    LDB     #$06       ; dir = 6
 FA29 8D0C                    BSR     ARC        ; 90-135 degrees
 FA2B BEDF92                  LDX     XTEMP      ; recover coordinates
 FA2E 10BEDF94                LDY     YTEMP      ; of centre point &
 FA32 17FD34                  LBSR    SETCRG     ; set cursor
 FA35 35B6                    PULS    PC,Y,X,D
                      ;*
                      ;* Plot an arc (on entry, A = radius, B = initial direction)
                      ;*
 FA37 3406            ARC     PSHS    D
 FA39 17FD2D                  LBSR    SETCRG
 FA3C 3406                    PSHS    D
 FA3E C6B5                    LDB     #$B5       ; (0.707 X 256)
 FA40 3D                      MUL
 FA41 B7DFD8                  STA     CONST      ; 256(R X 0.707).[Hi byte]
 FA44 3506                    PULS    D
 FA46 C407                    ANDB    #$07       ; dir not > 7
 FA48 CA20                    ORB     #$20       ; set 'arc' mode
 FA4A F7DFCD                  STB     GFIGS
 FA4D 4A                      DECA               ; radius - 1
 FA4E 5F                      CLRB
 FA4F B7DFD1                  STA     D1         ; Lo-byte of D = rad-1
 FA52 F7DFD0                  STB     D0         ; Hi-byte of D = 0
 FA55 1E89                    EXG     A,B
 FA57 58                      ASLB
 FA58 49                      ROLA
 FA59 FDDFD2                  STD     D2         ; = 2(radius - 1)
 FA5C F6DFD8                  LDB     CONST
 FA5F 4F                      CLRA
 FA60 FDDFCE                  STD     DN         ; = R x 0.707
 FA63 CCFFFF                  LDD     #$FFFF
 FA66 FDDFD4                  STD     D4         ; = -1
 FA69 CC0000                  LDD     #$0000
 FA6C FDDFD6                  STD     DM
 FA6F C60B                    LDB     #$0B       ; load 11 params & draw arc
 FA71 17FC43                  LBSR    FIGSF
 FA74 3586                    PULS    PC,D
                      ;*
                      ;* Set text cursor
                      ;*
 FA76 3416            SETCRT  PSHS    X,D
 FA78 BFDFE5                  STX     CURSOR
 FA7B 8649                    LDA     #$49       ; 'curs' command
 FA7D 17FBCF                  LBSR    GCOM
 FA80 1F10                    TFR     X,D
 FA82 1E89                    EXG     A,B
 FA84 17FBDA                  LBSR    GPRM       ; P1/2=cursor word
 FA87 1E89                    EXG     A,B        ; adr. Lo/Hi
 FA89 17FBD5                  LBSR    GPRM
 FA8C 8608                    LDA     #$08
 FA8E 17FBD0                  LBSR    GPRM
 FA91 3596                    PULS    PC,X,D
                      ;*
                      ;* Get text cursor
                      ;*
 FA93 3406            GETCRT  PSHS    D
 FA95 86E0                    LDA     #$E0       ; 'curd' command
 FA97 17FBB5                  LBSR    GCOM
 FA9A 17FBD3                  LBSR    GPRMI      ; P1=word adr. Lo
 FA9D 1F89                    TFR     A,B
 FA9F 17FBCE                  LBSR    GPRMI      ; P2=word adr. Hi
 FAA2 1F01                    TFR     D,X
 FAA4 BFDFE5                  STX     CURSOR     ; curs.word adr
 FAA7 17FBC6                  LBSR    GPRMI      ; P3=adr.Hi(not used)
 FAAA 17FBC3                  LBSR    GPRMI      ; P4/5=dot adr.Lo/Hi not
 FAAD 17FBC0                  LBSR    GPRMI      ; used in text mode,discard
 FAB0 3586                    PULS    PC,D
                      ;*
                      ;* Set display to text
                      ;*
 FAB2 3476            TEXT    PSHS    U,Y,X,D
 FAB4 5F                      CLRB
 FAB5 17FD85                  LBSR    MODE       ; get mode
 FAB8 84F6                    ANDA    #$F6
 FABA 5C                      INCB
 FABB 17FD7F                  LBSR    MODE       ; set noninterlaced
 FABE BEDFEC                  LDX     TS1        ; get text
 FAC1 FCDFEE                  LDD     TS2        ; Partition params
 FAC4 10BEDFF0                LDY     TL1
 FAC8 FEDFF2                  LDU     TL2
 FACB BDF705                  JSR     SETPAR     ; load them
 FACE 35F6                    PULS    PC,U,Y,X,D
                      ;*
                      ;* Clear text display (Partition data in scratch ram)
                      ;*
 FAD0 3416            CLEART  PSHS    X,D
 FAD2 8ECA00                  LDX     #TXTRAM    ; point to text ram
 FAD5 8D9F                    BSR     SETCRT
 FAD7 8E3600                  LDX     #$3600     ; 288 lines X 48 words
 FADA 8602                    LDA     #$02
 FADC BDF8AC                  JSR     CLEARX     ; clear text
 FADF 8D1F                    BSR     INITXT     ; setup initial text
 FAE1 7FDFDA                  CLR     COL        ; home cursor
 FAE4 7FDFD9                  CLR     ROW
 FAE7 7FDFEB                  CLR     ESCFLG
 FAEA 8601                    LDA     #$01
 FAEC B7DFEA                  STA     CTYPE      ; solid cursor
 FAEF 8604                    LDA     #$04
 FAF1 B7DFE1                  STA     ATTRI
 FAF4 8DBC                    BSR     TEXT       ; set text mode
 FAF6 7DDFFF                  TST     BLANKD     ; cursor blanked ?
 FAF9 2702                    BEQ     CLTXT      ; no,skip
 FAFB 8D5B                    BSR     FLCUR      ; yes,toggle it
 FAFD 3596            CLTXT   PULS    PC,X,D
 FAFF 39              CLINK   RTS                ; link text parameters
                      ;*
                      ;* Init text mode Partitions
                      ;*
 FB00 8ECA00          INITXT  LDX     #TXTRAM    ; initialise text mode
 FB03 1F10                    TFR     X,D        ; Partition parameters
 FB05 108E0120                LDY     #$0120
 FB09 CE0000                  LDU     #$0000
 FB0C BFDFEC          UPDPA   STX     TS1        ; update Partitions
 FB0F FDDFEE                  STD     TS2
 FB12 10BFDFF0                STY     TL1
 FB16 FFDFF2                  STU     TL2
 FB19 3402                    PSHS    A
 FB1B B6DFCB                  LDA     GMODE
 FB1E 8509                    BITA    #$09       ; if text mode set
 FB20 2702                    BEQ     ITRET      ; load these params
 FB22 3582                    PULS    PC,A       ; else,return
 FB24 3502            ITRET   PULS    A
 FB26 BDF705                  JSR     SETPAR
 FB29 39                      RTS
                      ;*
                      ;* Send a char to video
                      ;*
 FB2A 3476            VIDCH   PSHS    U,Y,X,D
 FB2C BDF341                  JSR     FAST
 FB2F 7DDFFF                  TST     BLANKD     ; cursor blanked ?
 FB32 2702                    BEQ     VIDC1      ; if so,
 FB34 8D22                    BSR     FLCUR      ; toggle it
 FB36 7DDFEB          VIDC1   TST     ESCFLG     ; set ?
 FB39 2705                    BEQ     VIDC2      ; no, continue
 FB3B BDFC78                  JSR     CMOVE      ; else, deal with it
 FB3E 2013                    BRA     VIDC3      ; and exit
 FB40 8120            VIDC2   CMPA    #$20       ; is it a control chr ?
 FB42 257F                    BCS     VIDCC      ; yes,go do it
 FB44 847F                    ANDA    #$7F       ; else,make sure its
 FB46 8D29                    BSR     GPCHR      ; ascii & do it
 FB48 B6DFDA                  LDA     COL
 FB4B 4C                      INCA
 FB4C 816C                    CMPA    #$6C       ; end of line ?
 FB4E 2703                    BEQ     VIDC3      ; yes,exit
 FB50 B7DFDA                  STA     COL        ; no,update col
 FB53 BDF34E          VIDC3   JSR     SLOW
 FB56 35F6                    PULS    PC,U,Y,X,D
                      ;*
                      ;* Flashing cursor
                      ;*
 FB58 3476            FLCUR   PSHS    U,Y,X,D
 FB5A 7DDFEA                  TST     CTYPE
 FB5D 2B10                    BMI     FLC2       ; cursor off,skip
 FB5F 8601                    LDA     #$01       ; (complement mode)
 FB61 BDF68D                  JSR     SETPEN
 FB64 B6DFEA                  LDA     CTYPE
 FB67 8A80                    ORA     #$80       ; adjust for use as index
 FB69 4A                      DECA               ; to char table
 FB6A 8D0D                    BSR     GPCH2      ; toggle cursor
 FB6C 73DFFF                  COM     BLANKD     ; toggle 'blanked' flag
 FB6F 35F6            FLC2    PULS    PC,U,Y,X,D
                      ;*
                      ;* Deal with printable character. (7 bit ascii in ACCA)
                      ;*
 FB71 3406            GPCHR   PSHS    D
 FB73 4F                      CLRA               ; (replace mode)
 FB74 BDF68D                  JSR     SETPEN
 FB77 3506                    PULS    D          ; peek & put back
 FB79 3406            GPCH2   PSHS    D
 FB7B 8D1C                    BSR     CCT2G      ; adjust coordinates
 FB7D 8020                    SUBA    #$20       ; use as index
 FB7F 8EFD0F                  LDX     #CSETB     ; (char set,Normal)
 FB82 C605                    LDB     #$05       ; find character
 FB84 3D                      MUL
 FB85 308B                    LEAX    D,X
 FB87 BDF6A4                  JSR     SETPAT     ; set it up
 FB8A B6DFE1                  LDA     ATTRI
 FB8D 108E0005                LDY     #$0005     ; pixels in init dir
 FB91 8E0008                  LDX     #$0008     ; pixels at Rt.Angles
 FB94 BDF86B                  JSR     FILL       ; and print it
 FB97 3586                    PULS    PC,D
                      ;*
                      ;* Convert coordinates,text to graphic
                      ;*
 FB99 3436            CCT2G   PSHS    Y,X,D
 FB9B B6DFD9                  LDA     ROW        ; row No
 FB9E C60C                    LDB     #$0C       ; lines per row
 FBA0 3D                      MUL
 FBA1 F3DFF2                  ADDD    TL2        ; + overwritten lines
 FBA4 1F02                    TFR     D,Y
 FBA6 108C0120                CMPY    #$0120     ; 2nd time round ?
 FBAA 2D04                    BLT     CCT2       ; no,skip
 FBAC 31A9FEE0                LEAY    $FEE0,Y    ; yes,-len of T ram
 FBB0 31A90248        CCT2    LEAY    $0248,Y    ; +len of G ram
 FBB4 B6DFDA                  LDA     COL
 FBB7 C607                    LDB     #$07       ; (width of box col)
 FBB9 3D                      MUL
 FBBA 1F01                    TFR     D,X
 FBBC 300C                    LEAX    $0C,X      ; +initial offset
 FBBE BDF769                  JSR     SETCRG
 FBC1 35B6                    PULS    PC,Y,X,D
                      ;*
                      ;* Deal with control character (entered from send chr to video)
                      ;*
 FBC3 3416            VIDCC   PSHS    X,D
 FBC5 8EFBCF                  LDX     #TCCACT
 FBC8 48                      ASLA               ; char X 2 is used
 FBC9 AD96                    JSR     [A,X]      ; as index to table
 FBCB 3516                    PULS    X,D
 FBCD 2084                    BRA     VIDC3      ; return to sender
                      ;*
                      ;* Table of control code action routines
                      ;*
 FBCF FC35            TCCACT  FDB     IGNORE
 FBD1 FC35                    FDB     IGNORE
 FBD3 FC35                    FDB     IGNORE
 FBD5 FC35                    FDB     IGNORE
 FBD7 FC35                    FDB     IGNORE
 FBD9 FC35                    FDB     IGNORE
 FBDB FC35                    FDB     IGNORE
 FBDD F62B                    FDB     BEEP       ; bell
 FBDF FC0F                    FDB     CLEFT      ; cursor left
 FBE1 FC19                    FDB     CRIGHT     ; cursor right
 FBE3 FC25                    FDB     CDOWN      ; cursor down
 FBE5 FC36                    FDB     CUP        ; cursor up
 FBE7 FAD0                    FDB     CLEART     ; clear screen
 FBE9 FC44                    FDB     CCR        ; CR
 FBEB FC78                    FDB     CMOVE      ; cursor move
 FBED FC41                    FDB     CHOME      ; cursor home
 FBEF F816                    FDB     ON         ; screen on
 FBF1 F80A                    FDB     OFF        ; screen off
 FBF3 FC51                    FDB     CURON      ; cursor on
 FBF5 FC48                    FDB     CUROFF     ; cursor off
 FBF7 FC5A                    FDB     CURSOL     ; cursor solid
 FBF9 FC60                    FDB     CURBOX     ; cursor box
 FBFB FC66                    FDB     ATTON      ; attributes on
 FBFD FC6F                    FDB     ATTOFF     ; attributes off
 FBFF FC35                    FDB     IGNORE     ; (clear to end of line)
 FC01 FC35                    FDB     IGNORE     ; (clear to end of screen)
 FC03 FCE4                    FDB     CLINE      ; clear line
 FC05 FC35                    FDB     IGNORE
 FC07 FC35                    FDB     IGNORE
 FC09 FC35                    FDB     IGNORE
 FC0B FC35                    FDB     IGNORE
 FC0D FC35                    FDB     IGNORE
                      ;*
                      ;* Action routines for control char
                      ;*
                      ;* Cursor left
 FC0F B6DFDA          CLEFT   LDA     COL
 FC12 4A                      DECA
 FC13 2B03                    BMI     CLEF1      ; if fully left, ignore
 FC15 B7DFDA                  STA     COL
 FC18 39              CLEF1   RTS
                      ;* Cursor right
 FC19 B6DFDA          CRIGHT  LDA     COL
 FC1C 4C                      INCA
 FC1D 816C                    CMPA    #$6C       ; if fully right, ignore
 FC1F 2703                    BEQ     CRIG1
 FC21 B7DFDA                  STA     COL
 FC24 39              CRIG1   RTS
                      ;* Cursor down
 FC25 B6DFD9          CDOWN   LDA     ROW
 FC28 4C                      INCA
 FC29 8118                    CMPA    #$18       ; 24? (N.B. rows=0-23)
 FC2B 2605                    BNE     CRET
 FC2D 8D6B                    BSR     SCRUP      ; scroll up
 FC2F 7EFCE4                  JMP     CLINE      ; clear line.(Btm)
 FC32 B7DFD9          CRET    STA     ROW
                      ;* Control char ignored
 FC35 39              IGNORE  RTS                ; no action
                      ;* Cursor up
 FC36 B6DFD9          CUP     LDA     ROW
 FC39 4A                      DECA
 FC3A 2AF6                    BPL     CRET
 FC3C 8D79                    BSR     SCRDWN     ; scroll down
 FC3E 7EFCE4                  JMP     CLINE      ; clear line.(Top)
                      ;* Cursor home (top-left)
 FC41 7FDFD9          CHOME   CLR     ROW
                      ;* CR (cursor begin of line)
 FC44 7FDFDA          CCR     CLR     COL
 FC47 39                      RTS
                      ;* Cursor off
 FC48 B6DFEA          CUROFF  LDA     CTYPE
 FC4B 8A80                    ORA     #$80
 FC4D B7DFEA                  STA     CTYPE
 FC50 39                      RTS
                      ;* Cursor on
 FC51 B6DFEA          CURON   LDA     CTYPE
 FC54 847F                    ANDA    #$7F
 FC56 B7DFEA                  STA     CTYPE
 FC59 39                      RTS
                      ;* Solid cursor
 FC5A 8601            CURSOL  LDA     #$01
 FC5C B7DFEA                  STA     CTYPE
 FC5F 39                      RTS
                      ;* Box cursor
 FC60 8602            CURBOX  LDA     #$02
 FC62 B7DFEA                  STA     CTYPE
 FC65 39                      RTS
                      ;* Attributes on
 FC66 B6DFE1          ATTON   LDA     ATTRI
 FC69 8A81                    ORA     #$81
 FC6B B7DFE1                  STA     ATTRI
 FC6E 39                      RTS
                      ;* Attributes off
 FC6F B6DFE1          ATTOFF  LDA     ATTRI
 FC72 847E                    ANDA    #$7E
 FC74 B7DFE1                  STA     ATTRI
 FC77 39                      RTS
                      ;*
                      ;* Move cursor (3 pass escape sequence)
                      ;*
 FC78 F6DFEB          CMOVE   LDB     ESCFLG
 FC7B 5D                      TSTB               ; is it set ?
 FC7C 2606                    BNE     CMOV1      ; yes,branch
 FC7E C602                    LDB     #$02       ; no,set it
 FC80 F7DFEB                  STB     ESCFLG
 FC83 39                      RTS
 FC84 C102            CMOV1   CMPB    #$02       ; is it 2 ?
 FC86 2609                    BNE     CMOV2      ; no,branch
 FC88 8020                    SUBA    #$20       ; yes,update row
 FC8A B7DFD9                  STA     ROW
 FC8D 7ADFEB                  DEC     ESCFLG
 FC90 39                      RTS
 FC91 8020            CMOV2   SUBA    #$20       ; update col and
 FC93 B7DFDA                  STA     COL
 FC96 7ADFEB                  DEC     ESCFLG     ; clear flag
 FC99 39                      RTS
                      ;*
                      ;* Scroll up
 FC9A 10BEDFF0        SCRUP   LDY     TL1        ; reduce TL1 by one row
 FC9E 3134                    LEAY    -$0C,Y
 FCA0 2603                    BNE     SCRUP1
 FCA2 16FE5B                  LBRA    INITXT     ; init Part.params
 FCA5 FCDFEE          SCRUP1  LDD     TS2
 FCA8 BEDFEC                  LDX     TS1
 FCAB 30890240                LEAX    $0240,X    ; 12 lines X 48 words
 FCAF FEDFF2                  LDU     TL2        ; (ie. advance 1 row)
 FCB2 334C                    LEAU    $0C,U      ; increment TL2 by one row
 FCB4 16FE55                  LBRA    UPDPA      ; update Part.params
                      ;*
                      ;* Scroll down
 FCB7 FEDFF2          SCRDWN  LDU     TL2        ; if zero,apply
 FCBA 2718                    BEQ     SCRD1      ; cooking factor
 FCBC BEDFEC                  LDX     TS1
 FCBF 3089FDC0                LEAX    -$0240,X   ; retreat one row
 FCC3 FCDFEE                  LDD     TS2
 FCC6 10BEDFF0                LDY     TL1        ; increase TL1 by one row
 FCCA 312C                    LEAY    $0C,Y
 FCCC FEDFF2                  LDU     TL2        ; reduce TL2 by one row
 FCCF 3354                    LEAU    -$0C,U
 FCD1 16FE38                  LBRA    UPDPA      ; update Part.params
 FCD4 8EFDC0          SCRD1   LDX     #$FDC0     ; TS1
 FCD7 CCCA00                  LDD     #TXTRAM    ; TS2
 FCDA 108E000C                LDY     #$000C     ; TL1 (1 row)
 FCDE CE0114                  LDU     #$0114     ; TL2 (23 rows)
 FCE1 16FE28                  LBRA    UPDPA
                      ;*
                      ;* Clear line
 FCE4 3436            CLINE   PSHS    Y,X,D
 FCE6 FCDFD9                  LDD     ROW
 FCE9 C60C                    LDB     #$0C       ; convert to lines
 FCEB 3D                      MUL
 FCEC F3DFF2                  ADDD    TL2        ; +overwritten lines
 FCEF 1F02                    TFR     D,Y
 FCF1 108C0120                CMPY    #$0120     ; 2nd time round ?
 FCF5 2D04                    BLT     CLIN1      ; skip if not
 FCF7 31A9FEE0                LEAY    $FEE0,Y    ; -len of text ram
 FCFB 31A90240        CLIN1   LEAY    $0240,Y    ; +len of graphics ram
 FCFF 8E0000                  LDX     #$0000
 FD02 BDF769                  JSR     SETCRG     ; (to start of row)
 FD05 8E0240                  LDX     #$0240     ; clear one row
 FD08 8602                    LDA     #$02
 FD0A BDF8AC                  JSR     CLEARX
 FD0D 35B6                    PULS    PC,Y,X,D
                      ;*
                      ;* Normal charset bitmap (graphic char as ASCII
                      ;* 7 bits stored as 5 columns x 8 bits images
                      ;*
 FD0F 0000000000      CSETB   FCB     $00,$00,$00,$00,$00 ; space
 FD14 0000FA0000              FCB     $00,$00,$FA,$00,$00 ; !
 FD19 00E000E000              FCB     $00,$E0,$00,$E0,$00 ; "
 FD1E 50F850F850              FCB     $50,$F8,$50,$F8,$50 ; #
 FD23 4854FE5424              FCB     $48,$54,$FE,$54,$24 ; $
 FD28 4626106864              FCB     $46,$26,$10,$68,$64 ; %
 FD2D 0A44AA926C              FCB     $0A,$44,$AA,$92,$6C ; &
 FD32 00E0D00000              FCB     $00,$E0,$D0,$00,$00 ; '
 FD37 0082443800              FCB     $00,$82,$44,$38,$00 ; (
 FD3C 0038448200              FCB     $00,$38,$44,$82,$00 ; )
 FD41 5438FE3854              FCB     $54,$38,$FE,$38,$54 ; *
 FD46 10107C1010              FCB     $10,$10,$7C,$10,$10 ; +
 FD4B 000E0D0000              FCB     $00,$0E,$0D,$00,$00 ; ,
 FD50 1010101010              FCB     $10,$10,$10,$10,$10 ; -
 FD55 0000060600              FCB     $00,$00,$06,$06,$00 ; .
 FD5A 4020100804              FCB     $40,$20,$10,$08,$04 ; /
 FD5F 007C82827C              FCB     $00,$7C,$82,$82,$7C ; 0
 FD64 0000FE4000              FCB     $00,$00,$FE,$40,$00 ; 1
 FD69 6292928A46              FCB     $62,$92,$92,$8A,$46 ; 2
 FD6E CCB2928282              FCB     $CC,$B2,$92,$82,$82 ; 3
 FD73 10FE1010F0              FCB     $10,$FE,$10,$10,$F0 ; 4
 FD78 9CA2A2A2E2              FCB     $9C,$A2,$A2,$A2,$E2 ; 5
 FD7D 0C9292523C              FCB     $0C,$92,$92,$52,$3C ; 6
 FD82 C0A0908886              FCB     $C0,$A0,$90,$88,$86 ; 7
 FD87 6C9292926C              FCB     $6C,$92,$92,$92,$6C ; 8
 FD8C 7894929260              FCB     $78,$94,$92,$92,$60 ; 9
 FD91 00006C6C00              FCB     $00,$00,$6C,$6C,$00 ; :
 FD96 00006E6D00              FCB     $00,$00,$6E,$6D,$00 ; ;
 FD9B 0082442810              FCB     $00,$82,$44,$28,$10 ; <
 FDA0 2828282828              FCB     $28,$28,$28,$28,$28 ; =
 FDA5 1028448200              FCB     $10,$28,$44,$82,$00 ; >
 FDAA 60908A8040              FCB     $60,$90,$8A,$80,$40 ; ?
 FDAF 7AAABA827C              FCB     $7A,$AA,$BA,$82,$7C ; @
 FDB4 7E9090907E              FCB     $7E,$90,$90,$90,$7E ; A
 FDB9 6C929292FE              FCB     $6C,$92,$92,$92,$FE ; B
 FDBE 448282827C              FCB     $44,$82,$82,$82,$7C ; C
 FDC3 7C828282FE              FCB     $7C,$82,$82,$82,$FE ; D
 FDC8 82929292FE              FCB     $82,$92,$92,$92,$FE ; E
 FDCD 80909090FE              FCB     $80,$90,$90,$90,$FE ; F
 FDD2 5E9292827C              FCB     $5E,$92,$92,$82,$7C ; G
 FDD7 FE101010FE              FCB     $FE,$10,$10,$10,$FE ; H
 FDDC 0082FE8200              FCB     $00,$82,$FE,$82,$00 ; I
 FDE1 FC02020204              FCB     $FC,$02,$02,$02,$04 ; J
 FDE6 82442810FE              FCB     $82,$44,$28,$10,$FE ; K
 FDEB 02020202FE              FCB     $02,$02,$02,$02,$FE ; L
 FDF0 FE402040FE              FCB     $FE,$40,$20,$40,$FE ; M
 FDF5 FE102040FE              FCB     $FE,$10,$20,$40,$FE ; N
 FDFA 7C8282827C              FCB     $7C,$82,$82,$82,$7C ; O
 FDFF 60909090FE              FCB     $60,$90,$90,$90,$FE ; P
 FE04 7A848A827C              FCB     $7A,$84,$8A,$82,$7C ; Q
 FE09 62949890FE              FCB     $62,$94,$98,$90,$FE ; R
 FE0E 4C92929264              FCB     $4C,$92,$92,$92,$64 ; S
 FE13 8080FE8080              FCB     $80,$80,$FE,$80,$80 ; T
 FE18 FC020202FC              FCB     $FC,$02,$02,$02,$FC ; U
 FE1D F8040204F8              FCB     $F8,$04,$02,$04,$F8 ; V
 FE22 FE041804FE              FCB     $FE,$04,$18,$04,$FE ; W
 FE27 C6281028C6              FCB     $C6,$28,$10,$28,$C6 ; X
 FE2C E0100E10E0              FCB     $E0,$10,$0E,$10,$E0 ; Y
 FE31 C2A2928A86              FCB     $C2,$A2,$92,$8A,$86 ; Z
 FE36 008282FE00              FCB     $00,$82,$82,$FE,$00 ; [
 FE3B 0408102040              FCB     $04,$08,$10,$20,$40 ; \
 FE40 00FE828200              FCB     $00,$FE,$82,$82,$00 ; ]
 FE45 2040FE4020              FCB     $20,$40,$FE,$40,$20 ; ^
 FE4A 0101010101              FCB     $01,$01,$01,$01,$01 ; _
 FE4F 0000D0E000              FCB     $00,$00,$D0,$E0,$00 ; `
 FE54 021E2A2A0E              FCB     $02,$1E,$2A,$2A,$0E ; a
 FE59 3C2222FE02              FCB     $3C,$22,$22,$FE,$02 ; b
 FE5E 1222221C00              FCB     $12,$22,$22,$1C,$00 ; c
 FE63 02FE22221C              FCB     $02,$FE,$22,$22,$1C ; d
 FE68 122A2A1C00              FCB     $12,$2A,$2A,$1C,$00 ; e
 FE6D 40503E1000              FCB     $40,$50,$3E,$10,$00 ; f
 FE72 3E25251900              FCB     $3E,$25,$25,$19,$00 ; g
 FE77 1E2020FE00              FCB     $1E,$20,$20,$FE,$00 ; h
 FE7C 00005E0000              FCB     $00,$00,$5E,$00,$00 ; i
 FE81 002E010200              FCB     $00,$2E,$01,$02,$00 ; j
 FE86 2214087E00              FCB     $22,$14,$08,$7E,$00 ; k
 FE8B 00027E4000              FCB     $00,$02,$7E,$40,$00 ; l
 FE90 1E203E203E              FCB     $1E,$20,$3E,$20,$3E ; m
 FE95 1E20203E00              FCB     $1E,$20,$20,$3E,$00 ; n
 FE9A 1C22221C00              FCB     $1C,$22,$22,$1C,$00 ; o
 FE9F 1824243F00              FCB     $18,$24,$24,$3F,$00 ; p
 FEA4 013F242418              FCB     $01,$3F,$24,$24,$18 ; q
 FEA9 2020103E00              FCB     $20,$20,$10,$3E,$00 ; r
 FEAE 242A2A1200              FCB     $24,$2A,$2A,$12,$00 ; s
 FEB3 04227C2000              FCB     $04,$22,$7C,$20,$00 ; t
 FEB8 023E02023C              FCB     $02,$3E,$02,$02,$3C ; u
 FEBD 300C020C30              FCB     $30,$0C,$02,$0C,$30 ; v
 FEC2 3C020C023C              FCB     $3C,$02,$0C,$02,$3C ; w
 FEC7 22121C2422              FCB     $22,$12,$1C,$24,$22 ; x
 FECC 3F05043800              FCB     $3F,$05,$04,$38,$00 ; y
 FED1 20322A2602              FCB     $20,$32,$2A,$26,$02 ; z
 FED6 82826C1000              FCB     $82,$82,$6C,$10,$00 ; {
 FEDB 0000EE0000              FCB     $00,$00,$EE,$00,$00 ; |
 FEE0 106C828200              FCB     $10,$6C,$82,$82,$00 ; }
 FEE5 1C10101010              FCB     $1C,$10,$10,$10,$10 ; ~
 FEEA AA55AA55AA              FCB     $AA,$55,$AA,$55,$AA ; chess pattern
 FEEF FFFFFFFFFF              FCB     $FF,$FF,$FF,$FF,$FF ; bloc pattern
 FEF4 C3810081C3              FCB     $C3,$81,$00,$81,$C3 ; angle pattern
 FEF9 F8FF29                  FCB     $F8,$FF,$29         ; void...
                      ;*
                      ;* SAM space : not used, except $FFF0-$FFFF (vectors)
                      ;* $FF60-$FFBF is readable too (boot ROM) but seems not used
                      ;*

                              ORG     $FF00

 FF00 FFBB                    FDB     $FFBB                    ;FF00: FF BB
 FF02 0216                    FDB     $0216                    ;FF02: 02 16
 FF04 FFB9                    FDB     $FFB9                    ;FF04: FF B9
 FF06 0216                    FDB     $0216                    ;FF06: 02 16
 FF08 FFB3                    FDB     $FFB3                    ;FF08: FF B3
 FF0A 0216                    FDB     $0216                    ;FF0A: 02 16
 FF0C FFBB                    FDB     $FFBB                    ;FF0C: FF BB
 FF0E 0216                    FDB     $0216                    ;FF0E: 02 16
 FF10 FFBB                    FDB     $FFBB                    ;FF10: FF BB
 FF12 0014                    FDB     $0014                    ;FF12: 00 14
 FF14 FFBB                    FDB     $FFBB                    ;FF14: FF BB
 FF16 0214                    FDB     $0214                    ;FF16: 02 14
 FF18 FFBB                    FDB     $FFBB                    ;FF18: FF BB
 FF1A 0216FFBB                FDB     $0216,$FFBB              ;FF1A: 02 16 FF BB
 FF1E 0014                    FDB     $0014                    ;FF1E: 00 14
 FF20 FFB90216FFBB00          FDB     $FFB9,$0216,$FFBB,$0016  ;FF20: FF B9 02 16 FF BB 00 16
 FF27 16
 FF28 FFB30212FFB302          FDB     $FFB3,$0212,$FFB3,$0216  ;FF28: FF B3 02 12 FF B3 02 16
 FF2F 16
 FF30 FFF30016FFBB00          FDB     $FFF3,$0016,$FFBB,$0014  ;FF30: FF F3 00 16 FF BB 00 14
 FF37 14
 FF38 FFB30014FFB300          FDB     $FFB3,$0014,$FFB3,$001C  ;FF38: FF B3 00 14 FF B3 00 1C
 FF3F 1C
 FF40 1000BFFF1000BF          FDB     $1000,$BFFF,$1000,$BFFF  ;FF40: 10 00 BF FF 10 00 BF FF
 FF47 FF
 FF48 1000BFFF1000BF          FDB     $1000,$BFFF,$1000,$BFFF  ;FF48: 10 00 BF FF 10 00 BF FF
 FF4F FF
 FF50 1000BFFF1000FF          FDB     $1000,$BFFF,$1000,$FFFF  ;FF50: 10 00 BF FF 10 00 FF FF
 FF57 FF
 FF58 1000BFFF1000FF          FDB     $1000,$BFFF,$1000,$FFFF  ;FF58: 10 00 BF FF 10 00 FF FF
 FF5F FF
 FF60 1000BFFF1000BF          FDB     $1000,$BFFF,$1000,$BFFF  ;FF60: 10 00 BF FF 10 00 BF FF
 FF67 FF
 FF68 1000FFFF1000BF          FDB     $1000,$FFFF,$1000,$BFFF  ;FF68: 10 00 FF FF 10 00 BF FF
 FF6F FF
 FF70 1000FFFF1000BF          FDB     $1000,$FFFF,$1000,$BFFF  ;FF70: 10 00 FF FF 10 00 BF FF
 FF77 FF
 FF78 1000BFFF1000FF          FDB     $1000,$BFFF,$1000,$FFFF  ;FF78: 10 00 BF FF 10 00 FF FF
 FF7F FF
 FF80 B9FF1400B8FF16          FDB     $B9FF,$1400,$B8FF,$1600  ;FF80: B9 FF 14 00 B8 FF 16 00
 FF87 00
 FF88 BBFF1600B9FD14          FDB     $BBFF,$1600,$B9FD,$1402  ;FF88: BB FF 16 00 B9 FD 14 02
 FF8F 02
 FF90 B9FF1600B1FD16          FDB     $B9FF,$1600,$B1FD,$1602  ;FF90: B9 FF 16 00 B1 FD 16 02
 FF97 02
 FF98 B9FF1600B9FD14          FDB     $B9FF,$1600,$B9FD,$1402  ;FF98: B9 FF 16 00 B9 FD 14 02
 FF9F 02
 FFA0 B1FF1600B9FD16          FDB     $B1FF,$1600,$B9FD,$1602  ;FFA0: B1 FF 16 00 B9 FD 16 02
 FFA7 02
 FFA8 BBFF1600B8FF16          FDB     $BBFF,$1600,$B8FF,$1602  ;FFA8: BB FF 16 00 B8 FF 16 02
 FFAF 02
 FFB0 B9FF1600B9FD16          FDB     $B9FF,$1600,$B9FD,$1602  ;FFB0: B9 FF 16 00 B9 FD 16 02
 FFB7 02
 FFB8 B9FF1600B9FD16          FDB     $B9FF,$1600,$B9FD,$1602  ;FFB8: B9 FF 16 00 B9 FD 16 02
 FFBF 02
 FFC0 0010FFBF0010FF          FDB     $0010,$FFBF,$0010,$FFBF  ;FFC0: 00 10 FF BF 00 10 FF BF
 FFC7 BF
 FFC8 0010FFBF0010FF          FDB     $0010,$FFBF,$0010,$FFBF  ;FFC8: 00 10 FF BF 00 10 FF BF
 FFCF BF
 FFD0 0010FFBF0010            FDB     $0010,$FFBF,$0010        ;FFD0: 00 10 FF BF 00 10
 FFD6 FFBF                    FDB     $FFBF                    ;FFD6: FF BF
 FFD8 0010                    FDB     $0010                    ;FFD8: 00 10
 FFDA FFBF                    FDB     $FFBF                    ;FFDA: FF BF
 FFDC 0010                    FDB     $0010                    ;FFDC: 00 10
 FFDE FFFF                    FDB     $FFFF                    ;FFDE: FF FF
 FFE0 0010FFBF0010FF          FDB     $0010,$FFBF,$0010,$FFBF  ;FFE0: 00 10 FF BF 00 10 FF BF
 FFE7 BF
 FFE8 0010FFBF0010FF          FDB     $0010,$FFBF,$0010,$FFBF  ;FFE8: 00 10 FF BF 00 10 FF BF
 FFEF BF
                      ;*
                      ;* Restart control vectors.
                      ;*
                                ORG (PROM+$1FF0)

 FFF0 F08E                      FDB      RESET               Not implemented in 6809.
 FFF2 F12C                      FDB      SWI3                Software interupt three.
 FFF4 F128                      FDB      SWI2                Software interupt two.
 FFF6 F124                      FDB      FIRQ                Fast interupt request.
 FFF8 F120                      FDB      IRQ                 Interupt request.
 FFFA E572                      FDB      SWI                 Software interupt.
 FFFC F11C                      FDB      NMI                 Non-maskable interupt.
 FFFE F08E            VCRST     FDB      RESET               Cold start.
                      ;*
                      ;*
                                END

SYMBOL TABLE
     ACIA1 00 FF08     ACIA2 00 FF04       ARC 02 FA37   ASCLOOP 02 E609
    ATTOFF 02 FC6F     ATTON 02 FC66     ATTRI 00 DFE1     BADDR 02 F56A
      BAUD 00 FF0C      BEEP 02 F62B        BF 02 EC19    BLANKD 00 DFFF
        BO 02 E326       BO1 02 E33E       BO2 02 E34F       BO3 02 E355
       BO4 02 E368       BO5 02 E372     BODIS 02 E31E    BOFAIL 02 E37C
     BOFL1 02 E38F     BOFL2 02 E39F     BOFL3 02 E3B3     BOFL4 02 E3C0
     BOMES 02 E2F8    BSYBIT 00 0080    BUFFER 02 DE80      BYTE 02 F575
     CALD1 02 E476    CALDIS 02 E453       CCR 02 FC44      CCT2 02 FBB0
     CCT2G 02 FB99        CD 02 E49E       CD1 02 E4C9     CDOWN 02 FC25
     CFMST 02 E092     CFSLV 02 E0A5    CHKDRQ 02 F435    CHKDT2 02 F43E
    CHKRDY 02 F4F5    CHKVEC 02 DFAB     CHOME 02 FC41    CINCHN 00 D3E5
    CIRCLE 02 F9E6     CLEAR 02 F88A    CLEART 02 FAD0    CLEARX 02 F8AC
     CLEF1 02 FC18     CLEFT 02 FC0F     CLIN1 02 FCFB     CLINE 02 FCE4
     CLINK 02 FAFF    CLR_R0 00 FFD6    CLR_R1 00 FFD8     CLTXT 02 FAFD
   CMDWAIT 02 F3B6     CMOV1 02 FC84     CMOV2 02 FC91     CMOVE 02 FC78
       COL 00 DFDA     COLDS 00 CD00    COMREG 00 FF10    COMTAB 02 E1FD
    CONPRS 02 E4DD     CONST 00 DFD8   CONTINI 02 E1F2    CONTRL 02 F0DF
        CP 02 E4F4     CPRTC 02 E40D      CRET 02 FC32     CRIG1 02 FC24
    CRIGHT 02 FC19     CRLFS 02 F51D     CSETB 02 FD0F     CTYPE 00 DFEA
       CUP 02 FC36    CURBOX 02 FC60    CURDRV 00 DFB6    CUROFF 02 FC48
     CURON 02 FC51    CURSOL 02 FC5A    CURSOR 00 DFE5    CWLOOP 02 F3B8
        D0 00 DFD0        D1 00 DFD1        D2 00 DFD2        D4 00 DFD4
    DATREG 00 FF13   DATWAIT 02 F3C1        DC 02 EC39     DCMES 02 EC22
      DDEN 02 F2E1    DDSTAB 02 DF9D     DELAY 02 F550    DELAY1 02 F552
    DELAY2 02 F55F       DEN 00 DFF4      DEN1 00 DFF5        DF 02 E9E7
     DINIT 02 F4FD    DINIT1 02 F4FE    DINIT2 02 F50C    DISFOS 02 E9A6
    DISRES 02 E717        DM 00 DFD6        DN 00 DFCE        DR 02 E758
       DR1 02 E75E     DRIVE 02 DF8E    DRIVE1 02 F4DA    DRIVE2 02 F4E8
    DROMSZ 00 DFFB    DRQBIT 00 0008       DRV 02 F4C5    DRVDT2 02 F367
    DRVERR 02 F389    DRVVEC 02 DFA9     DUMMY 02 F130     EBAUD 02 EECE
     EBRNK 02 EDDC     EBSMS 02 ED06 ENDDRVDT2 02 F382  ENDIDERW 02 F3F4
    ENDINI 02 F4A8      ERR1 02 E8CB      ERR2 02 EB62    ERRBIT 00 0001
    ESCFLG 00 DFEB      FAST 02 F341      FCMD 02 F222        FI 02 ED1C
       FI1 02 ED3E       FI2 02 ED55       FI3 02 ED63       FI4 02 ED71
       FI5 02 ED74       FI6 02 ED8D       FI7 02 EDA5       FI8 02 EDAD
     FIGG2 02 F6EE     FIGG3 02 F6FE     FIGS2 02 F6C7     FIGS3 02 F6D5
     FIGSF 02 F6B7     FIGSG 02 F6DC      FILL 02 F86B    FILMES 02 E4FF
     FIMES 02 ECEE      FIRQ 02 F124     FIRQV 02 DF86     FLASH 00 DFFD
      FLC2 02 FB6F     FLCUR 02 FB58        FM 02 E520       FM1 02 E53F
       FMT 02 EA0B      FMT1 02 EA14      FMT2 02 EA36      FMT3 02 EA7B
      FMT4 02 EAA2      FMT5 02 EAAE     FROMS 02 E94D      GCOM 02 F64F
     GCOM1 02 F654     GCOM2 02 F65D     GCRG1 02 F7D6     GCRG2 02 F7DF
     GCRG3 02 F7F9     GCRG4 02 F801       GDC 00 FF14     GDCI2 02 F8E9
    GDCINI 02 F8E1     GETA1 02 F193     GETA2 02 F199    GETCRG 02 F7C0
    GETCRT 02 FA93    GETRTC 02 F5F8    GETTIM 02 F5EB     GFIGS 00 DFCD
     GMODE 00 DFCB     GOFLX 02 E417    GPARAM 00 DFC3     GPCH2 02 FB79
     GPCHR 02 FB71      GPRM 02 F661     GPRM2 02 F663     GPRMI 02 F670
     GRAPH 02 F822     GTIM2 02 F5EF     GZOOM 00 DFCC        HD 02 E5D0
       HD1 02 E5ED       HD2 02 E5F5       HD3 02 E604       HD4 02 E5DC
    HDCONT 02 E615    HDMES1 02 E599       HDR 02 E000    HEXDUS 02 E57F
    IDE_A0 00 0001    IDE_A1 00 0002    IDE_A2 00 0004 IDE_CMD_READ 00 0020
 IDE_CMD_SET_FEAT 00 00EF IDE_CMD_WRITE 00 0030 IDE_COMMAND 00 000F   IDE_CS0 00 0008
   IDE_CS1 00 0010  IDE_DATA 00 0008   IDE_ERR 00 0009 IDE_FEA_16BIT 00 0081
  IDE_LBA0 00 000B  IDE_LBA1 00 000C  IDE_LBA2 00 000D  IDE_LBA3 00 000E
    IDE_RD 00 0040   IDE_RST 00 0080 IDE_SEC_CNT 00 000A IDE_SET_FEAT 00 0009
 IDE_STATUS 00 000F    IDE_WR 00 0020    IGNORE 02 FC35    ILOOP1 02 F472
    ILOOP2 02 F492      INC1 02 F155      INC2 02 F161      INCH 02 F16C
     INCH1 02 F153     INHEX 02 F59A    INHEX1 02 F5AF    INIDT2 02 F45F
     INIT2 02 E121     INIT3 02 E15E     INIT4 02 E18A    INITXT 02 FB00
    INIVEC 02 DFAF     INKEY 02 F18D        IO 00 FF00     IPORT 02 DF8C
       IRQ 02 F120      IRQV 02 DF84      IRTC 02 E117     ITRET 02 FB24
        JF 02 E2A1     JFMES 02 E287        JU 02 E27B     JUMES 02 E266
        L1 02 F09F      LBA0 02 DE7A      LBA1 02 DE7B      LBA2 02 DE7C
      LBA3 02 DE7D   LBA3MST 00 00E0   LBA3SLV 00 00F0     LDTB1 02 E3E5
     LDTB2 02 E3F5     LDTBL 02 E3DE    LENGHS 02 E7A4      LINE 02 F939
     LINE1 02 F950     LINE2 02 F964     LINE3 02 F977        LK 02 E685
       LK1 02 E696    LOAKES 02 E65C   LOOPRST 02 E1B0     LOOPW 02 EFD2
    MAPOUT 02 F645      MASK 02 F67B        MC 02 ECA9       MC1 02 ECB4
       MC2 02 ECDE       MC3 02 ECE5     MCA02 00 CA02     MCMES 02 EC8C
     MDFC4 00 DFC4     MDFFA 00 DFFA        ME 02 E6DE       ME1 02 E6E7
       ME2 02 E6FB       MED 02 E701    MEMEXS 02 E6A2    MINIT1 02 E0E9
    MINITR 02 F0D9      MODE 02 F83D     MODE1 02 F850   MSTCFOK 02 DE7E
     MSTOK 02 F481      NEXT 02 F0FA     NEXT2 02 E3DB     NEXTB 02 E3C5
       NMI 02 F11C      NMIV 02 DF82     NOFLX 02 E30A      NOPE 02 F101
     NORAM 02 E6C3    NOTHEX 02 F5B0    NOTPRT 02 E613    NOTRDY 02 F45A
    NOTTHS 02 E02A    NVC0Z1 02 F336    NVZ0C1 02 F33B       OFF 02 F80A
        ON 02 F816     OPORT 02 DF8D     OUT2H 02 F5B7    OUT2HA 02 F5B9
    OUT2HS 02 F5C1    OUT4HS 02 F5BF     OUTCH 02 F16E     OUTHL 02 F587
     OUTHR 02 F58B      OUTS 02 F5C3         P 02 F529     P1TBL 02 F9B1
   PARMLOP 02 F39C     PARSE 02 F0F7     PART1 00 DFBB     PART2 00 DFBF
     PAUS1 02 F22A     PAUS2 02 F22D     PAUS3 02 F230     PAUSE 02 F227
     PBLIN 02 EC73     PCRLF 02 F520    PDATA1 02 F52C     PFAIL 02 E066
      PIA1 00 FF00      PIA2 00 FF1C        PM 02 E643     POINT 02 F92D
    POKMES 02 E632     PORTA 00 FF1C     PORTB 00 FF1D     PORTC 00 FF1E
  PORTCTRL 00 FF1F    PRINTA 02 F538    PRINTX 02 F544      PROM 00 E000
    PROMPT 02 E025     PRTC2 02 F618    PSPEED 00 DFF9    PSTRNG 02 F533
     PTIM2 02 F60D     PUTA1 02 F1A2     PUTA2 02 F1AD    PUTRTC 02 F616
    PUTTIM 02 F609    PUTVID 02 F19F     QBUSY 02 F21A     QINT0 02 F1B8
     QINT1 02 F1BE     QINT2 02 F1C4     QUICK 02 F4F9    QUIVEC 02 DFAD
       RAM 00 DE00    RANDOM 02 F5C8     RDDT2 02 F3FB     RDFL1 02 F23F
     RDFL2 02 F24B     RDFL3 02 F251     RDFL4 02 F25A     RDFL5 02 F26F
     RDFLP 02 F231    RDLOOP 02 F407     RDSEC 02 E385       RDY 02 F455
    RDYBIT 00 0040 RD_IDE_8255 00 0092      READ 02 F4B0  READ_IDE 02 F3E2
    REASES 02 E89E    REAVEC 02 DFA1      RECT 02 F9B9     REGDP 00 DFFC
     RESET 02 F08E      RNDM 02 DF98       ROW 00 DFD9        RP 02 E55E
       RP1 02 E56D       RPT 02 F5CC        RS 02 E8E0     RSFLP 02 F2AE
       RST 02 F4BC      RST1 02 F4C1    RSTRNG 02 E72F    RSTVEC 02 DFA7
       RTC 00 FF18   RTCFAIL 00 DFB5     RTCOK 02 E19F    RUNPRS 02 E54B
    RWEXIT 02 F430        SB 02 EDF2       SB1 02 EE15       SB2 02 EE2A
       SB3 02 EE5B       SB4 02 EE6C     SBMES 02 EDB5     SBRMS 02 EDCE
     SCRAT 00 DF80     SCRD1 02 FCD4    SCRDWN 02 FCB7     SCRUP 02 FC9A
    SCRUP1 02 FCA5    SCTCNT 02 DE79      SDEN 02 F2DD      SECS 02 E8C2
    SECTOR 02 DF90      SEEK 02 F519    SEEVEC 02 DFB3     SELD0 02 F2FC
     SELD1 02 F306    SETCRG 02 F769    SETCRT 02 FA76      SETD 02 F30E
    SETFEA 02 DE78    SETLBA 02 F38D     SETP2 02 F6AE    SETPAR 02 F705
    SETPAT 02 F6A4    SETPEN 02 F68D    SET_R0 00 FFD7    SET_R1 00 FFD9
    SHIMES 02 E787        SI 02 E2C1     SIMES 02 E2AD     SKFL1 02 F2E7
     SKFL2 02 F2E9     SKFLP 02 F2C4      SLOW 02 F34E     SLOW2 02 F366
   SLVCFOK 02 DE7F     SLVOK 02 F4A1        SM 02 E7AD       SM1 02 E7CE
        SO 02 E2E7     SOMES 02 E2D2     SPEED 00 DFF7     SPRM2 02 F74D
    SSTACK 00 DE6F     STACK 02 DF80     STAT1 02 F143     STAT2 02 F148
    STATUS 02 F131      STEP 00 DFF6     SURES 02 E9CE       SWI 02 E572
      SWI2 02 F128     SWI2V 02 DF88      SWI3 02 F12C     SWI3V 02 DF8A
    SYSREG 00 FF02     TABIN 02 F17B    TABLE1 02 E41D    TABLE2 02 E435
    TABOUT 02 F181    TABSRT 02 F1CA     TBAUD 02 EE74    TCCACT 02 FBCF
    TCONST 02 E0B7        TD 02 EB73    TDLOOP 02 EB8B     TDLP2 02 EB99
     TDLP9 02 EBBE     TDMES 02 EB2F    TDMES1 02 EB4D      TEMP 02 DF91
    TESMES 02 E7DB      TEXT 02 FAB2   TFRPARM 02 F393       TL1 00 DFF0
       TL2 00 DFF2        TM 02 E823       TM1 02 E84C       TM2 02 E86C
       TM3 02 E869       TM4 02 E852       TM5 02 E841      TMS1 02 E7EE
      TMS2 02 E804      TMS3 02 E810       TOS 02 E471     TQINT 02 F187
     TRACK 02 DF8F     TRACS 02 E8BA        TS 02 EBF4       TS1 00 DFEC
       TS2 00 DFEE    TSLOOP 02 EC06    TSMESS 02 EBDB     TSTEP 00 DFF8
       TTO 02 DF96     TTYBS 00 CC00    TXTRAM 00 CA00        U1 02 F0B3
       U1L 02 F0BA     UNEXP 02 F111    UNMESS 02 E03E     UPDPA 02 FB0C
    VALUES 02 E496     VCRST 02 FFFE    VERIFY 02 F4B8    VERVEC 02 DFA5
     VIDC1 02 FB36     VIDC2 02 FB40     VIDC3 02 FB53     VIDCC 02 FBC3
     VIDCH 02 FB2A     VRFLP 02 F2A3     VSYN2 02 F759     VSYN3 02 F760
     VSYNC 02 F757      WABT 02 EB26     WABT1 02 EB28   WAIT1MS 02 EFD0
      WARM 02 F515     WARMS 02 DF9C    WARVEC 02 DFB1      WHAT 02 F109
     WRDT2 02 F415     WRFL1 02 F27F     WRFL2 02 F28B     WRFL3 02 F291
     WRFL4 02 F29A     WRFLP 02 F272    WRIMES 02 E932     WRITE 02 F4B4
    WRIVEC 02 DFA3    WRLOOP 02 F422   WRT_IDE 02 F3CA WR_IDE_8255 00 0080
        WS 02 E954    XCOORD 00 DFB7     XTEMP 02 DF92    YCOORD 00 DFB9
     YTEMP 02 DF94      ZOOM 02 F854     ZOOM1 02 F867
539 SYMBOLS

0 error(s), 0 warning(s)
